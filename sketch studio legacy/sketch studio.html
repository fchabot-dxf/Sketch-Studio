<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fusion 360 Sketch Master</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --fusion-dark: #2C2C2C;
            --fusion-orange: #EA580C;
            --fusion-blue: #3B82F6;
        }
        body { font-family: 'Inter', sans-serif; touch-action: none; overflow: hidden; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        .cursor-select { cursor: default; }
        .cursor-draw { cursor: crosshair; }
        .cursor-pan { cursor: grab; }
        .cursor-pan:active { cursor: grabbing; }
        /* Custom SVG cursors */
        .cursor-coincident { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><line x1="4" y1="20" x2="14" y2="10" stroke="%23EA580C" stroke-width="2.5" stroke-linecap="round"/><line x1="18" y1="6" x2="28" y2="16" stroke="%23EA580C" stroke-width="2.5" stroke-linecap="round"/><circle cx="16" cy="13" r="2.5" fill="%23EA580C"/></svg>') 16 16, auto; }
        .cursor-parallel { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><line x1="6" y1="10" x2="26" y2="10" stroke="%233B82F6" stroke-width="2"/><line x1="6" y1="22" x2="26" y2="22" stroke="%233B82F6" stroke-width="2"/><line x1="16" y1="0" x2="16" y2="32" stroke="%23EA580C" stroke-width="1" stroke-dasharray="2"/></svg>') 16 16, auto; }
        .cursor-perpend { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><line x1="4" y1="16" x2="28" y2="16" stroke="%23000000" stroke-width="2.5" stroke-linecap="round"/><line x1="16" y1="28" x2="16" y2="4" stroke="%23EA580C" stroke-width="2.5" stroke-linecap="round"/></svg>') 16 16, auto; }
        .cursor-tangent { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><circle cx="16" cy="12" r="6" fill="none" stroke="%233B82F6" stroke-width="2"/><line x1="6" y1="24" x2="26" y2="24" stroke="%233B82F6" stroke-width="2"/><circle cx="16" cy="24" r="2" fill="%23EA580C"/></svg>') 16 16, auto; }
        .cursor-dimension { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><line x1="2" y1="16" x2="30" y2="16" stroke="%233B82F6" stroke-width="2"/><line x1="2" y1="12" x2="2" y2="20" stroke="%233B82F6" stroke-width="2"/><line x1="30" y1="12" x2="30" y2="20" stroke="%233B82F6" stroke-width="2"/><text x="16" y="28" font-size="10" font-weight="bold" fill="%23EA580C" text-anchor="middle">L</text></svg>') 16 16, auto; }

        .tool-btn {
            transition: all 0.15s;
            border: 1px solid transparent;
        }
        .tool-btn:hover {
            background-color: #f0f0f0;
        }
        .tool-btn.active {
            background-color: #3B82F6;
            color: white;
            border: 1px solid #1E40AF;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        .tool-btn.active span {
            color: white;
        }
        .tool-btn.active i {
            color: white;
        }

        #canvas-svg { width: 100%; height: 100%; touch-action: none; background-color: #ffffff; }
        
        .constraint-glyph { cursor: pointer; pointer-events: auto; }
        .constraint-glyph rect { transition: all 0.1s; stroke-width: 0.5px; stroke: #CBD5E1; }
        .constraint-glyph.selected rect { stroke: var(--fusion-orange); stroke-width: 2px; fill: #fff7ed; }
        .constraint-glyph:hover rect { fill: #f1f5f9; }
        
        .dim-line { pointer-events: none; }
        .dim-container { cursor: pointer; pointer-events: auto; }
        .dim-container:hover rect { stroke: var(--fusion-orange); fill: #fff7ed; }
        .dim-input { 
            position: absolute; background: white; border: 2px solid var(--fusion-orange);
            border-radius: 4px; padding: 2px 4px; font-weight: bold; font-size: 11px;
            outline: none; text-align: center; z-index: 100; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .dim-input.hidden {
            display: none;
        }
        .hover-highlight { stroke: var(--fusion-orange) !important; stroke-width: 4px !important; opacity: 0.6; }
    </style>
</head>
<body class="flex flex-col h-screen bg-[#F0F0F0] select-none text-xs">

    <!-- HEADER -->
    <header class="bg-[#2C2C2C] text-white px-4 py-2 flex justify-between items-center z-50 shadow-lg shrink-0">
        <div class="flex items-center gap-4">
            <div class="bg-orange-600 p-1 rounded shadow-inner"><i data-lucide="maximize" class="w-4 h-4"></i></div>
            <span class="text-[11px] font-bold uppercase tracking-widest text-slate-200">Fusion 360 Sketch Master</span>
        </div>
        <div class="flex items-center gap-4 text-[10px] font-bold text-slate-400">
            <span class="hidden md:flex items-center gap-2 opacity-80 border border-slate-700 px-2 py-0.5 rounded">
                <i data-lucide="move" class="text-orange-500 w-3"></i> Synchronized Grid Pan
            </span>
            <span class="text-orange-500 uppercase">Grid: 20mm</span>
        </div>
    </header>

    <!-- TOOLS RIBBON -->
    <div class="bg-white border-b border-slate-300 p-1 flex gap-1 z-40 overflow-x-auto no-scrollbar shadow-sm shrink-0">
        <div class="flex flex-col items-center px-2 border-r border-slate-200">
            <div class="flex gap-0.5">
                <button onclick="setTool('select')" id="btn-select" class="tool-btn active flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                    <i data-lucide="mouse-pointer-2" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Select</span>
                </button>
                <button onclick="setTool('line')" id="btn-line" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                    <i data-lucide="minus" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Line</span>
                </button>
                <button onclick="setTool('midpointline')" id="btn-midpointline" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                    <i data-lucide="move-right" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">MLine</span>
                </button>
                <div class="relative group">
                    <button onclick="setTool('rect')" id="btn-rect" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                        <i data-lucide="square" class="w-[18px]"></i>
                        <span class="text-[8px] font-black uppercase mt-1">Rect</span>
                    </button>
                    <div class="absolute left-0 top-full hidden group-hover:block bg-white border border-slate-300 rounded shadow-lg z-50 w-32 text-left">
                        <button onclick="setRectMode('normal'); setTool('rect')" class="w-full px-3 py-2 text-[10px] hover:bg-blue-100 border-b border-slate-200">Normal</button>
                        <button onclick="setRectMode('midpoint'); setTool('rect')" class="w-full px-3 py-2 text-[10px] hover:bg-blue-100 border-b border-slate-200">Midpoint</button>
                        <button onclick="setRectMode('3point'); setTool('rect')" class="w-full px-3 py-2 text-[10px] hover:bg-blue-100">3-Point</button>
                    </div>
                </div>
                <button onclick="setTool('circle')" id="btn-circle" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                    <i data-lucide="circle" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Circle</span>
                </button>
                <div class="relative group">
                    <button onclick="setTool('arc')" id="btn-arc" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                        <i data-lucide="arc-right" class="w-[18px]"></i>
                        <span class="text-[8px] font-black uppercase mt-1">Arc</span>
                    </button>
                    <div class="absolute left-0 top-full hidden group-hover:block bg-white border border-slate-300 rounded shadow-lg z-50 w-32 text-left">
                        <button onclick="setArcMode('3point'); setTool('arc')" class="w-full px-3 py-2 text-[10px] hover:bg-blue-100 border-b border-slate-200">3-Point Arc</button>
                        <button onclick="setArcMode('center'); setTool('arc')" class="w-full px-3 py-2 text-[10px] hover:bg-blue-100 border-b border-slate-200">Center-Radius</button>
                        <button onclick="setArcMode('tangent'); setTool('arc')" class="w-full px-3 py-2 text-[10px] hover:bg-blue-100">Tangent Arc</button>
                    </div>
                </div>
                <button onclick="setTool('polygon')" id="btn-polygon" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                    <i data-lucide="hexagon" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Poly</span>
                </button>
                <button onclick="setTool('ellipse')" id="btn-ellipse" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                    <i data-lucide="oval" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Ellip</span>
                </button>
                <button onclick="setTool('slot')" id="btn-slot" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                    <i data-lucide="rectangle-horizontal" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Slot</span>
                </button>
                <button onclick="setTool('spline')" id="btn-spline" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                    <i data-lucide="wave-square" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Spline</span>
                </button>
            </div>
            <span class="text-[8px] font-black uppercase text-slate-300 mt-1">Create</span>
        </div>

        <div class="flex flex-col items-center px-2 border-r border-slate-200">
            <div class="flex gap-0.5">
                <button onclick="setTool('coincident')" id="btn-coinc" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                    <i data-lucide="x" class="w-[18px] text-blue-500"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Coinc</span>
                </button>
                <button onclick="setTool('horiz')" id="btn-horiz" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                    <i data-lucide="unfold-horizontal" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Horiz</span>
                </button>
                <button onclick="setTool('vert')" id="btn-vert" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                    <i data-lucide="unfold-vertical" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Vert</span>
                </button>
                <button onclick="setTool('parallel')" id="btn-parallel" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                    <i data-lucide="rows" class="w-[18px] rotate-45"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Para</span>
                </button>
                <button onclick="setTool('perpend')" id="btn-perpend" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                    <i data-lucide="corner-down-right" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Perp</span>
                </button>
                <button onclick="setTool('tangent')" id="btn-tangent" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                    <i data-lucide="circle-dot" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Tan</span>
                </button>
                <button onclick="setTool('colinear')" id="btn-colinear" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                    <i data-lucide="slash" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Clin</span>
                </button>
                <button onclick="setTool('midpoint')" id="btn-midpoint" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                    <i data-lucide="dot" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Mid</span>
                </button>
            </div>
            <span class="text-[8px] font-black uppercase text-slate-300 mt-1">Constrain</span>
        </div>

        <div class="flex flex-col items-center px-2">
            <div class="flex gap-0.5">
                <button onclick="setTool('dimension')" id="btn-dimension" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded transition-all">
                    <i data-lucide="hash" class="w-[18px] text-slate-500"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Dim</span>
                </button>
            </div>
            <span class="text-[8px] font-black uppercase text-slate-300 mt-1">Inspect</span>
        </div>

        <div class="ml-auto flex items-center gap-2 pr-4 shrink-0">
            <button onclick="undo()" class="p-2 hover:bg-slate-100 rounded text-slate-400" title="Undo"><i data-lucide="undo-2" class="w-4"></i></button>
            <button onclick="exportSketch()" class="p-2 hover:bg-slate-100 rounded text-slate-400" title="Export sketch as JSON"><i data-lucide="download" class="w-4"></i></button>
            <button onclick="importSketch()" class="p-2 hover:bg-slate-100 rounded text-slate-400" title="Import sketch from JSON"><i data-lucide="upload" class="w-4"></i></button>
            <button onclick="clearCanvas()" class="p-2 hover:bg-red-50 rounded text-slate-400 hover:text-red-500" title="Clear"><i data-lucide="trash-2" class="w-4"></i></button>
            <button id="lock-btn" onclick="toggleLock()" class="px-4 py-1.5 rounded text-[10px] font-bold border bg-blue-600 text-white border-blue-700 shadow-sm uppercase tracking-widest">
                Edit
            </button>
        </div>
        <input type="file" id="import-file" accept=".json" style="display:none" onchange="loadImportedFile(event)" />
    </div>

    <!-- MAIN VIEWPORT -->
    <main class="flex-1 relative bg-[#DBDBDB] flex flex-col overflow-hidden p-2 md:p-4" id="viewport-container">
        <div class="flex-1 bg-white rounded shadow-inner border border-slate-300 relative overflow-hidden">
            <svg id="canvas-svg">
                <defs>
                    <!-- Small Grid Lines -->
                    <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                        <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#F1F5F9" stroke-width="0.5"/>
                    </pattern>
                    <!-- Large Grid Lines with PatternTransform -->
                    <pattern id="grid-heavy" width="100" height="100" patternUnits="userSpaceOnUse">
                        <rect width="100" height="100" fill="url(#grid)" />
                        <path d="M 100 0 L 0 0 0 100" fill="none" stroke="#E2E8F0" stroke-width="1"/>
                    </pattern>
                </defs>
                
                <!-- BACKGROUND GRID (Fixed size, moving pattern) -->
                <rect id="infinite-grid" width="100%" height="100%" fill="url(#grid-heavy)" />

                <!-- WORLD GROUP -->
                <g id="world-group">
                    <!-- ORIGIN DATUM (0,0) -->
                    <g id="origin-datum">
                        <circle r="4" fill="none" stroke="#64748B" stroke-width="1.5" />
                        <line x1="-8" y1="0" x2="8" y2="0" stroke="#64748B" stroke-width="1" />
                        <line x1="0" y1="-8" x2="0" y2="8" stroke="#64748B" stroke-width="1" />
                    </g>
                    <g id="shapes-layer"></g>
                    <g id="dimension-layer"></g>
                    <g id="preview-layer"></g>
                    <!-- Snap indicator inside world so it aligns with geometry -->
                    <g id="snap-layer"></g>
                </g>
            </svg>
            
            <!-- Dimension Input Box -->
            <input type="number" id="dim-input" placeholder="Dimension (optional)" class="dim-input hidden" step="0.1" min="0.1" />
        </div>
    </main>

    <footer class="bg-slate-100 border-t border-slate-300 px-4 py-1.5 flex justify-between items-center text-[10px] font-bold text-slate-400 uppercase tracking-tighter shrink-0">
        <div class="flex gap-4"><span id="mode-text">MODE: SELECT</span></div>
        <div><span id="status-text" class="text-blue-500">GRID SYNC ACTIVE</span></div>
    </footer>

    <script>
        // --- CONFIG & STATE ---
        const ORIGIN = { x: 0, y: 0, jointId: 'origin-fixed' };
        let viewPan = { x: 0, y: 0 };
        let shapes = [];
        let dimensions = [];
        let currentTool = 'select';
        let isLocked = false;
        
        let activeShape = null;
        let dragTarget = null;
        let panStart = null;
        let selectedConstraint = null;
        let multiRefs = [];
        let hoverTarget = null;
        let selectedShapes = new Set();
        
        // Animation frame batching for smooth performance
        let pendingRender = false;
        let pendingCoords = null;
        let pendingSnap = null;
        let coincidentFirstRef = null;
        let rectangleMode = 'normal'; // 'normal', 'midpoint', '3point'
        let rectModePoints = []; // for 3point mode
        let parallelFirstLine = null;
        let perpendFirstLine = null;
        let tangentFirstShape = null;
        let colinearFirstLine = null;
        let midpointFirstLine = null;
        let arcMode = '3point'; // '3point', 'center', 'tangent'
        let arcPoints = []; // for arc creation
        let polygonPoints = []; // for polygon creation
        let splinePoints = []; // for spline creation
        let lastCreatedShapeId = null;
        let dimInputVisible = false;

        const SNAP_DIST = 15;
        const HIT_DIST = 22;

        const svg = document.getElementById('canvas-svg');
        const worldGroup = document.getElementById('world-group');
        const shapesLayer = document.getElementById('shapes-layer');
        const dimLayer = document.getElementById('dimension-layer');
        const previewLayer = document.getElementById('preview-layer');
        const snapLayer = document.getElementById('snap-layer');
        const gridPattern = document.getElementById('grid-heavy');

        lucide.createIcons();

        // --- VIEWPORT & GRID SYNC ---
        function centerOrigin() {
            const rect = svg.getBoundingClientRect();
            viewPan.x = rect.width / 2;
            viewPan.y = rect.height / 2;
            updateViewportTransform();
        }

        function updateViewportTransform() {
            // Move and scale the geometry
            const scale = worldGroup.getAttribute('data-scale') || 1;
            worldGroup.setAttribute('transform', `translate(${viewPan.x}, ${viewPan.y}) scale(${scale})`);
            // Move and scale the background pattern 1:1 with the geometry
            gridPattern.setAttribute('patternTransform', `translate(${viewPan.x}, ${viewPan.y}) scale(${scale})`);
        }

        window.addEventListener('resize', centerOrigin);
        setTimeout(centerOrigin, 10);

        // --- MATH ---
        function getDist(p1, p2) { return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2); }
        function getAngle(p1, p2) { return Math.atan2(p2.y - p1.y, p2.x - p1.x); }

        function projectPointOnLine(pt, start, end) {
            const dx = end.x - start.x, dy = end.y - start.y;
            const L2 = dx*dx + dy*dy;
            if (L2 === 0) return { ...start };
            const t = ((pt.x - start.x) * dx + (pt.y - start.y) * dy) / L2;
            const tClamped = Math.max(0, Math.min(1, t));
            return { x: Math.round(start.x + tClamped * dx), y: Math.round(start.y + tClamped * dy) };
        }

        function projectPointOnLineInfinite(pt, start, end) {
            // Project point onto infinite line (not clamped to segment)
            const dx = end.x - start.x, dy = end.y - start.y;
            const L2 = dx*dx + dy*dy;
            if (L2 === 0) return { ...start };
            const t = ((pt.x - start.x) * dx + (pt.y - start.y) * dy) / L2;
            return { x: Math.round(start.x + t * dx), y: Math.round(start.y + t * dy) };
        }

        function getArcCenter(p1, p2, p3) {
            // Calculate center of circle passing through 3 points
            const ax = p1.x, ay = p1.y;
            const bx = p2.x, by = p2.y;
            const cx = p3.x, cy = p3.y;
            
            const d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));
            if (Math.abs(d) < 0.0001) return null;
            
            const ux = ((ax*ax + ay*ay) * (by - cy) + (bx*bx + by*by) * (cy - ay) + (cx*cx + cy*cy) * (ay - by)) / d;
            const uy = ((ax*ax + ay*ay) * (cx - bx) + (bx*bx + by*by) * (ax - cx) + (cx*cx + cy*cy) * (bx - ax)) / d;
            
            return { x: Math.round(ux), y: Math.round(uy) };
        }

        function normalizeAngle(angle) {
            while (angle < 0) angle += 2 * Math.PI;
            while (angle >= 2 * Math.PI) angle -= 2 * Math.PI;
            return angle;
        }

        function getJointId(x, y) {
            if (Math.abs(ORIGIN.x - x) < 3 && Math.abs(ORIGIN.y - y) < 3) return ORIGIN.jointId;
            for (let s of shapes) {
                if (Math.abs(s.start.x - x) < 2 && Math.abs(s.start.y - y) < 2) return s.startJointId || (s.startJointId = Math.random().toString(36).substr(2, 9));
                if (Math.abs(s.end.x - x) < 2 && Math.abs(s.end.y - y) < 2) return s.endJointId || (s.endJointId = Math.random().toString(36).substr(2, 9));
            }
            return Math.random().toString(36).substr(2, 9);
        }

        function getCoords(e) {
            const pt = svg.createSVGPoint();
            pt.x = e.clientX; pt.y = e.clientY;
            const inverted = pt.matrixTransform(worldGroup.getScreenCTM().inverse());
            return { x: Math.round(inverted.x), y: Math.round(inverted.y) };
        }

        function findSnap(coords) {
            if (getDist(coords, ORIGIN) < SNAP_DIST) return { ...ORIGIN, type: 'point', jointId: ORIGIN.jointId, id: 'fixed-origin' };
            let anchors = [];
            shapes.forEach(s => { anchors.push({ ...s.start, id: s.id, jointId: s.startJointId, part: 'start' }, { ...s.end, id: s.id, jointId: s.endJointId, part: 'end' }); });
            for (let a of anchors) { if (getDist(coords, a) < SNAP_DIST) return { ...a, type: 'point' }; }
            for (let s of shapes) {
                if (s.type === 'line') {
                    const proj = projectPointOnLine(coords, s.start, s.end);
                    if (getDist(coords, proj) < SNAP_DIST) return { ...proj, type: 'line', lineId: s.id };
                }
            }
            return null;
        }

        function findAllConnectedJoints(jointId) {
            // Find all joint IDs connected to this one through coincident constraints
            let connected = new Set([jointId]);
            let found = true;
            while (found) {
                found = false;
                for (let s of shapes) {
                    if (connected.has(s.startJointId) && !connected.has(s.endJointId)) {
                        connected.add(s.endJointId);
                        found = true;
                    }
                    if (connected.has(s.endJointId) && !connected.has(s.startJointId)) {
                        connected.add(s.startJointId);
                        found = true;
                    }
                }
            }
            return connected;
        }

        function findHit(coords) {
            if (getDist(coords, ORIGIN) < HIT_DIST) return { shape: { id: 'fixed-origin', start: ORIGIN, end: ORIGIN, type: 'point', startJointId: ORIGIN.jointId }, part: 'start' };
            for (let s of shapes) {
                if (s.locked) continue;
                if (getDist(coords, s.start) < HIT_DIST) return { shape: s, part: 'start' };
                if (getDist(coords, s.end) < HIT_DIST) return { shape: s, part: 'end' };
                if (s.type === 'line') {
                    const proj = projectPointOnLine(coords, s.start, s.end);
                    if (getDist(coords, proj) < HIT_DIST) return { shape: s, part: 'all' };
                }
                if (s.type === 'circle') {
                    const r = getDist(s.start, s.end), d = getDist(coords, s.start);
                    if (Math.abs(d - r) < HIT_DIST) return { shape: s, part: 'all' };
                }
            }
            return null;
        }

        // --- INTERACTION ---
        svg.onpointerdown = (e) => {
            const raw = getCoords(e);
            const snap = findSnap(raw);
            const coords = snap || raw;

            // Pan Logic (MMB or Background)
            if (e.button === 1 || (currentTool === 'select' && !findHit(raw))) {
                svg.setPointerCapture(e.pointerId);
                panStart = { x: e.clientX, y: e.clientY, prevPan: {...viewPan} };
                svg.classList.add('cursor-pan');
                return;
            }

            if (e.target.closest('.constraint-glyph') === null) { selectedConstraint = null; render(); }

            if (currentTool === 'dimension') {
                const hit = findHit(coords);
                if (hit) {
                    if (hit.part === 'all') {
                        dimensions.push({ ref1: { shapeId: hit.shape.id, part: 'start' }, ref2: { shapeId: hit.shape.id, part: 'end' }, value: getDist(hit.shape.start, hit.shape.end) });
                        setTool('select');
                    } else {
                        multiRefs.push({ shapeId: hit.shape.id, part: hit.part });
                        if (multiRefs.length === 2) {
                            const s1 = multiRefs[0].shapeId === 'fixed-origin' ? {start: ORIGIN} : shapes.find(s => s.id === multiRefs[0].shapeId);
                            const s2 = multiRefs[1].shapeId === 'fixed-origin' ? {start: ORIGIN} : shapes.find(s => s.id === multiRefs[1].shapeId);
                            dimensions.push({ ref1: multiRefs[0], ref2: multiRefs[1], value: getDist(s1[multiRefs[0].part], s2[multiRefs[1].part]) });
                            setTool('select');
                        }
                    }
                }
                return;
            }

            if (currentTool === 'select') {
                const hit = findHit(coords);
                if (hit && hit.shape.id !== 'fixed-origin') {
                    // Toggle selection with Ctrl/Cmd, otherwise single select
                    if (e.ctrlKey || e.metaKey) {
                        if (selectedShapes.has(hit.shape.id)) {
                            selectedShapes.delete(hit.shape.id);
                        } else {
                            selectedShapes.add(hit.shape.id);
                        }
                    } else {
                        // Single select: if already selected, prepare to drag; otherwise select only this
                        if (!selectedShapes.has(hit.shape.id)) {
                            selectedShapes.clear();
                            selectedShapes.add(hit.shape.id);
                        }
                    }
                    render();
                    
                    svg.setPointerCapture(e.pointerId);
                    
                    // Determine which joints move with the drag
                    // The constraint solver will enforce all constraints (rotation, sliding, dimensions, etc)
                    let bondedJointIds = [];
                    if (hit.part !== 'all') {
                        // Dragging a specific endpoint
                        const jointId = hit.shape[hit.part + 'JointId'];
                        
                        // Check if shape has relational constraints that lock both endpoints together
                        // (parallel, perpendicular, tangent, colinear all require the whole shape to move)
                        const hasRigidConstraints = hit.shape.constraints && 
                            (hit.shape.constraints.includes('parallel') || 
                             hit.shape.constraints.includes('perpendicular') || 
                             hit.shape.constraints.includes('tangent') || 
                             hit.shape.constraints.includes('colinear'));
                        
                        if (hasRigidConstraints) {
                            // Both endpoints move together - solver will then rotate/slide as needed
                            bondedJointIds = [hit.shape.startJointId, hit.shape.endJointId];
                        } else {
                            // Only dragged endpoint moves - line can stretch
                            // Solver enforces coincident constraints and dimensions
                            bondedJointIds = Array.from(findAllConnectedJoints(jointId));
                        }
                    } else {
                        // Dragging the whole shape - move both endpoints
                        bondedJointIds.push(hit.shape.startJointId, hit.shape.endJointId);
                    }
                    
                    dragTarget = { hit, bondedJointIds, originalCoords: {...coords}, originalShapes: JSON.parse(JSON.stringify(shapes)) };
                } else {
                    // Clicking empty space deselects
                    selectedShapes.clear();
                    render();
                }
                return;
            }

            // Constraints
            if (['horiz', 'vert', 'parallel', 'perpend', 'coincident', 'colinear', 'midpoint'].includes(currentTool)) {
                const hit = findHit(coords);
                if (!hit) return;
                
                // Horiz/Vert - auto-detect based on angle
                if (currentTool === 'horiz' || currentTool === 'vert') {
                    if (hit.shape.type !== 'line') return;
                    const angle = getAngle(hit.shape.start, hit.shape.end);
                    const normalizedAngle = Math.abs(angle) % Math.PI;
                    // If closer to 0 or PI, make horizontal; if closer to PI/2, make vertical
                    const isMoreHorizontal = normalizedAngle < Math.PI / 4 || normalizedAngle > 3 * Math.PI / 4;
                    
                    if (isMoreHorizontal) {
                        // Check for over-constraining: can't be both horiz and vert
                        if (!hit.shape.constraints.includes('horiz') && !hit.shape.constraints.includes('vert')) {
                            hit.shape.constraints.push('horiz');
                            hit.shape.end.y = hit.shape.start.y;
                        }
                    } else {
                        if (!hit.shape.constraints.includes('vert') && !hit.shape.constraints.includes('horiz')) {
                            hit.shape.constraints.push('vert');
                            hit.shape.end.x = hit.shape.start.x;
                        }
                    }
                    render();
                    return;
                }
                
                if (currentTool === 'colinear') {
                    if (hit.shape.type !== 'line') return;
                    
                    if (!colinearFirstLine) {
                        colinearFirstLine = hit.shape.id;
                        render();
                    } else {
                        const line1 = shapes.find(s => s.id === colinearFirstLine);
                        const line2 = hit.shape;
                        
                        if (line1 && line2 && line1.id !== line2.id) {
                            // Check for over-constraining: can't be colinear with multiple lines
                            if (!line1.colinearWith && !line2.colinearWith) {
                                line1.constraints.push('colinear');
                                line2.constraints.push('colinear');
                                // Link them
                                line1.colinearWith = line2.id;
                                line2.colinearWith = line1.id;
                            }
                        }
                        
                        colinearFirstLine = null;
                        setTool('select');
                        render();
                    }
                    return;
                }
                
                if (currentTool === 'midpoint') {
                    // Midpoint: first click is the line, second click is the point
                    if (!midpointFirstLine) {
                        if (hit.shape.type === 'line') {
                            midpointFirstLine = hit.shape.id;
                            render();
                        }
                    } else {
                        // Second selection should be a point (endpoint)
                        const line = shapes.find(s => s.id === midpointFirstLine);
                        const point = hit.shape;
                        
                        if (line && point) {
                            // Move the point to the midpoint of the line
                            const midX = (line.start.x + line.end.x) / 2;
                            const midY = (line.start.y + line.end.y) / 2;
                            
                            if (hit.part === 'start') {
                                point.start.x = Math.round(midX);
                                point.start.y = Math.round(midY);
                            } else {
                                point.end.x = Math.round(midX);
                                point.end.y = Math.round(midY);
                            }
                            
                            line.constraints.push('midpoint');
                            point.constraints.push('midpoint');
                            line.midpointWith = point.id;
                            point.midpointWith = line.id;
                        }
                        
                        midpointFirstLine = null;
                        setTool('select');
                        render();
                    }
                    return;
                }
                
                // Parallel and perpendicular only work on lines
                if (currentTool === 'parallel') {
                    if (hit.shape.type !== 'line') return;
                    
                    if (!parallelFirstLine) {
                        parallelFirstLine = hit.shape.id;
                        render();
                    } else {
                        const line1 = shapes.find(s => s.id === parallelFirstLine);
                        const line2 = hit.shape;
                        
                        if (line1 && line2 && line1.id !== line2.id) {
                            // Check for over-constraining: can't be both parallel and perpendicular
                            if (!line1.constraints.includes('perpendicular') && !line2.constraints.includes('perpendicular')) {
                                // Also check they're not already parallel to each other
                                if (!(line1.parallelWith === line2.id || line2.parallelWith === line1.id)) {
                                    line1.constraints.push('parallel');
                                    line2.constraints.push('parallel');
                                    // Link them via a constraint reference
                                    line1.parallelWith = line2.id;
                                    line2.parallelWith = line1.id;
                                }
                            }
                        }
                        
                        parallelFirstLine = null;
                        setTool('select');
                        render();
                    }
                    return;
                }
                
                if (currentTool === 'perpend') {
                    if (hit.shape.type !== 'line') return;
                    
                    if (!perpendFirstLine) {
                        perpendFirstLine = hit.shape.id;
                        render();
                    } else {
                        const line1 = shapes.find(s => s.id === perpendFirstLine);
                        const line2 = hit.shape;
                        
                        if (line1 && line2 && line1.id !== line2.id) {
                            // Check for over-constraining: can't be both perpendicular and parallel
                            if (!line1.constraints.includes('parallel') && !line2.constraints.includes('parallel')) {
                                // Also check they're not already perpendicular to each other
                                if (!(line1.perpendicularWith === line2.id || line2.perpendicularWith === line1.id)) {
                                    line1.constraints.push('perpendicular');
                                    line2.constraints.push('perpendicular');
                                    // Link them via a constraint reference
                                    line1.perpendicularWith = line2.id;
                                    line2.perpendicularWith = line1.id;
                                }
                            }
                        }
                        
                        perpendFirstLine = null;
                        setTool('select');
                        render();
                    }
                    return;
                }
                
                if (currentTool === 'tangent') {
                    // Tangent works on lines and circles only
                    if (hit.shape.type !== 'line' && hit.shape.type !== 'circle') return;
                    
                    if (!tangentFirstShape) {
                        tangentFirstShape = hit.shape.id;
                        render();
                    } else {
                        const shape1 = shapes.find(s => s.id === tangentFirstShape);
                        const shape2 = hit.shape;
                        
                        if (shape1 && shape2 && shape1.id !== shape2.id) {
                            // Check for over-constraining: can't be tangent with multiple shapes
                            if (!shape1.tangentWith && !shape2.tangentWith) {
                                shape1.constraints.push('tangent');
                                shape2.constraints.push('tangent');
                                // Link them via a constraint reference
                                shape1.tangentWith = shape2.id;
                                shape2.tangentWith = shape1.id;
                            }
                        }
                        
                        tangentFirstShape = null;
                        setTool('select');
                        render();
                    }
                    return;
                }
                
                if (currentTool === 'coincident') {
                    // If snapping to existing geometry, auto-apply coincident
                    if (snap && snap.type === 'point') {
                        // Snap to a point - apply coincident between clicked geometry and snap target
                        const hitRef = { shapeId: hit.shape.id, part: hit.part };
                        const snapRef = { shapeId: snap.id || 'fixed-origin', part: 'start' };
                        
                        // Get the shapes
                        const hitShape = hit.shape;
                        const snapShape = snap.id ? shapes.find(s => s.id === snap.id) : null;
                        
                        if (hitShape && (snapShape || snap.id === 'fixed-origin' || !snap.id)) {
                            const hitJoint = hitShape[hitRef.part + 'JointId'] || hitShape.startJointId;
                            const snapJoint = snap.jointId || ORIGIN.jointId;
                            
                            if (hitJoint !== snapJoint) {
                                // Merge joints
                                if (snap.id === 'fixed-origin' || !snap.id) {
                                    // Moving to origin
                                    hitShape[hitRef.part].x = ORIGIN.x;
                                    hitShape[hitRef.part].y = ORIGIN.y;
                                    shapes.forEach(s => {
                                        if (s.startJointId === hitJoint) s.startJointId = ORIGIN.jointId;
                                        if (s.endJointId === hitJoint) s.endJointId = ORIGIN.jointId;
                                    });
                                } else if (snapShape) {
                                    // Merge into snap joint
                                    const snapPoint = snapShape[snapRef.part];
                                    hitShape[hitRef.part].x = snapPoint.x;
                                    hitShape[hitRef.part].y = snapPoint.y;
                                    shapes.forEach(s => {
                                        if (s.startJointId === hitJoint) s.startJointId = snapJoint;
                                        if (s.endJointId === hitJoint) s.endJointId = snapJoint;
                                    });
                                }
                            }
                            coincidentFirstRef = null;
                            setTool('select');
                            render();
                            return;
                        }
                    }
                    
                    // Otherwise, use two-click selection
                    if (!coincidentFirstRef) {
                        // First selection - store the reference
                        coincidentFirstRef = { shapeId: hit.shape.id, part: hit.part };
                        render();
                    } else {
                        // Second selection - merge joint IDs
                        const ref1 = coincidentFirstRef;
                        const ref2 = { shapeId: hit.shape.id, part: hit.part };
                        
                        // Get the shapes and joint IDs
                        const s1 = ref1.shapeId === 'fixed-origin' ? {start: ORIGIN, startJointId: ORIGIN.jointId} : shapes.find(s => s.id === ref1.shapeId);
                        const s2 = ref2.shapeId === 'fixed-origin' ? {start: ORIGIN, startJointId: ORIGIN.jointId} : shapes.find(s => s.id === ref2.shapeId);
                        
                        if (!s1 || !s2) return;
                        
                        const j1 = s1[ref1.part + 'JointId'] || s1.startJointId;
                        const j2 = s2[ref2.part + 'JointId'] || s2.startJointId;
                        
                        // Don't merge if same joint
                        if (j1 === j2) {
                            coincidentFirstRef = null;
                            render();
                            return;
                        }
                        
                        // If coinciding with origin, move first point to origin
                        if (ref2.shapeId === 'fixed-origin') {
                            const s1Shape = shapes.find(sh => sh.id === ref1.shapeId);
                            if (s1Shape) {
                                s1Shape[ref1.part].x = ORIGIN.x;
                                s1Shape[ref1.part].y = ORIGIN.y;
                            }
                        } else if (ref1.shapeId === 'fixed-origin') {
                            const s2Shape = shapes.find(sh => sh.id === ref2.shapeId);
                            if (s2Shape) {
                                s2Shape[ref2.part].x = ORIGIN.x;
                                s2Shape[ref2.part].y = ORIGIN.y;
                            }
                        }
                        
                        // Merge j2 into j1 - replace all j2 references with j1
                        shapes.forEach(s => {
                            if (s.startJointId === j2) s.startJointId = j1;
                            if (s.endJointId === j2) s.endJointId = j1;
                        });
                        
                        // Also update dimensions that reference j2
                        dimensions.forEach(d => {
                            const ds1 = d.ref1.shapeId === 'fixed-origin' ? {startJointId: ORIGIN.jointId} : shapes.find(sh => sh.id === d.ref1.shapeId);
                            const ds2 = d.ref2.shapeId === 'fixed-origin' ? {startJointId: ORIGIN.jointId} : shapes.find(sh => sh.id === d.ref2.shapeId);
                            
                            const dj1 = ds1[d.ref1.part + 'JointId'] || ds1.startJointId;
                            const dj2 = ds2[d.ref2.part + 'JointId'] || ds2.startJointId;
                            
                            if (dj1 === j2) d.ref1.jointId = j1;
                            if (dj2 === j2) d.ref2.jointId = j1;
                        });
                        
                        coincidentFirstRef = null;
                        setTool('select');
                        render();
                    }
                }
            }

            // Draw
            if (!activeShape) {
                let jId;
                if (snap) {
                    // Snapped to existing point/line - use that joint ID (creates coincident constraint)
                    jId = snap.jointId;
                } else {
                    // New point - create unique joint ID
                    jId = getJointId(coords.x, coords.y);
                }
                activeShape = { id: Date.now(), start: coords, end: coords, type: currentTool, constraints: [], startJointId: jId };
            } else {
                let jId;
                if (snap) {
                    // Snapped end point - use snapped joint ID (creates coincident constraint)
                    jId = snap.jointId;
                } else {
                    // New point - create unique joint ID
                    jId = getJointId(coords.x, coords.y);
                }
                
                if (currentTool === 'rect') {
                    if (rectangleMode === 'normal') {
                        // Normal rectangle: opposite corners
                        const s = activeShape.start, e = coords;
                        const c1 = {x: s.x, y: s.y}, c2 = {x: e.x, y: s.y}, c3 = {x: e.x, y: e.y}, c4 = {x: s.x, y: e.y};
                        const j1 = activeShape.startJointId, j2 = getJointId(c2.x, c2.y), j3 = getJointId(c3.x, c3.y), j4 = getJointId(c4.x, c4.y);
                        // All 4 sides with shared corner joint IDs - ensures corners stay together
                        [{s:c1,e:c2,jS:j1,jE:j2,c:['horiz','coincident']},{s:c2,e:c3,jS:j2,jE:j3,c:['vert','coincident']},{s:c3,e:c4,jS:j3,jE:j4,c:['horiz','coincident']},{s:c4,e:c1,jS:j4,jE:j1,c:['vert','coincident']}]
                        .forEach(l => shapes.push({ id: Math.random(), type: 'line', start: l.s, end: l.e, startJointId: l.jS, endJointId: l.jE, constraints: l.c }));
                        activeShape = null; rectModePoints = []; setTool('select');
                    } else if (rectangleMode === 'midpoint') {
                        // Midpoint rectangle: center and corner
                        const center = activeShape.start, corner = coords;
                        const hw = Math.abs(corner.x - center.x), hh = Math.abs(corner.y - center.y);
                        const c1 = {x: center.x - hw, y: center.y - hh}, c2 = {x: center.x + hw, y: center.y - hh},
                              c3 = {x: center.x + hw, y: center.y + hh}, c4 = {x: center.x - hw, y: center.y + hh};
                        const j1 = getJointId(c1.x, c1.y), j2 = getJointId(c2.x, c2.y), j3 = getJointId(c3.x, c3.y), j4 = getJointId(c4.x, c4.y);
                        // All 4 sides with shared corner joint IDs - ensures corners stay together
                        [{s:c1,e:c2,jS:j1,jE:j2,c:['horiz','coincident']},{s:c2,e:c3,jS:j2,jE:j3,c:['vert','coincident']},{s:c3,e:c4,jS:j3,jE:j4,c:['horiz','coincident']},{s:c4,e:c1,jS:j4,jE:j1,c:['vert','coincident']}]
                        .forEach(l => shapes.push({ id: Math.random(), type: 'line', start: l.s, end: l.e, startJointId: l.jS, endJointId: l.jE, constraints: l.c }));
                        activeShape = null; rectModePoints = []; setTool('select');
                    } else if (rectangleMode === '3point') {
                        // 3-point rectangle: first corner, second corner, third corner (defines rotation)
                        if (rectModePoints.length === 0) {
                            rectModePoints.push(activeShape.start);
                            activeShape = null;
                        } else if (rectModePoints.length === 1) {
                            rectModePoints.push(coords);
                            activeShape = null;
                        } else if (rectModePoints.length === 2) {
                            rectModePoints.push(coords);
                            const p1 = rectModePoints[0], p2 = rectModePoints[1], p3 = rectModePoints[2];
                            // Vector from p1 to p2
                            const v1x = p2.x - p1.x, v1y = p2.y - p1.y;
                            // Vector from p1 to p3
                            const v2x = p3.x - p1.x, v2y = p3.y - p1.y;
                            // Fourth corner completes the rectangle
                            const c1 = p1, c2 = p2, c4 = p3, c3 = {x: p2.x + v2x, y: p2.y + v2y};
                            const j1 = getJointId(c1.x, c1.y), j2 = getJointId(c2.x, c2.y), j3 = getJointId(c3.x, c3.y), j4 = getJointId(c4.x, c4.y);
                            // Add perpendicular + horiz/vert constraints to fully constrain rectangle corners
                            [{s:c1,e:c2,jS:j1,jE:j2,c:['perpendicular','horiz']},{s:c2,e:c3,jS:j2,jE:j3,c:['perpendicular','vert']},{s:c3,e:c4,jS:j3,jE:j4,c:['perpendicular','horiz']},{s:c4,e:c1,jS:j4,jE:j1,c:['perpendicular','vert']}]
                            .forEach(l => shapes.push({ id: Math.random(), type: 'line', start: l.s, end: l.e, startJointId: l.jS, endJointId: l.jE, constraints: [...l.c, 'coincident'] }));
                            activeShape = null; rectModePoints = []; setTool('select');
                        }
                    }
                } else if (currentTool === 'circle') {
                    const newCircle = { ...activeShape, end: coords, endJointId: jId }; 
                    newCircle.id = Math.random();
                    shapes.push(newCircle);
                    if (dimInputVisible) {
                        document.getElementById('dim-input').classList.add('hidden');
                        dimInputVisible = false;
                    }
                    showDimensionInput(newCircle.id);
                    activeShape = null; 
                } else if (currentTool === 'ellipse') {
                    const newEllipse = { ...activeShape, end: coords, endJointId: jId, type: 'ellipse' };
                    newEllipse.id = Math.random();
                    shapes.push(newEllipse);
                    if (dimInputVisible) {
                        document.getElementById('dim-input').classList.add('hidden');
                        dimInputVisible = false;
                    }
                    showDimensionInput(newEllipse.id);
                    activeShape = null;
                } else if (currentTool === 'midpointline') {
                    // Midpoint line: first click is center, second is end
                    const center = activeShape.start;
                    const endpoint = coords;
                    const dx = endpoint.x - center.x;
                    const dy = endpoint.y - center.y;
                    const otherEnd = {x: center.x - dx, y: center.y - dy};
                    const line = {...activeShape, start: otherEnd, end: endpoint, endJointId: jId, type: 'line'};
                    line.id = Math.random();
                    shapes.push(line);
                    if (dimInputVisible) {
                        document.getElementById('dim-input').classList.add('hidden');
                        dimInputVisible = false;
                    }
                    showDimensionInput(line.id);
                    activeShape = null;
                } else if (currentTool === 'polygon') {
                    // Polygon: multi-click to add points
                    if (!activeShape.points) activeShape.points = [activeShape.start];
                    polygonPoints.push(coords);
                    if (polygonPoints.length > 1) {
                        // Check if snapped to first point (closing polygon)
                        const firstPt = polygonPoints[0];
                        if (snap && Math.hypot(coords.x - firstPt.x, coords.y - firstPt.y) < SNAP_DIST) {
                            // Close the polygon
                            const polygon = {id: Math.random(), type: 'polygon', start: polygonPoints[0], end: polygonPoints[polygonPoints.length - 1], points: [...polygonPoints, polygonPoints[0]], constraints: []};
                            shapes.push(polygon);
                            activeShape = null;
                            polygonPoints = [];
                            setTool('select');
                        } else {
                            // Add another point
                            activeShape = {id: Date.now(), start: coords, end: coords, type: 'polygon', points: polygonPoints, constraints: []};
                        }
                    }
                } else if (currentTool === 'slot') {
                    const newSlot = {...activeShape, end: coords, endJointId: jId, type: 'slot'};
                    newSlot.id = Math.random();
                    shapes.push(newSlot);
                    activeShape = null;
                } else if (currentTool === 'spline') {
                    // Spline: multi-click to add control points
                    if (!splinePoints.length) splinePoints.push(activeShape.start);
                    splinePoints.push(coords);
                    
                    if (splinePoints.length > 1) {
                        // Check if escape was pressed or double-click on same point
                        if (snap && Math.hypot(coords.x - splinePoints[splinePoints.length - 2].x, coords.y - splinePoints[splinePoints.length - 2].y) < SNAP_DIST) {
                            // Finish spline
                            const spline = {id: Math.random(), type: 'spline', start: splinePoints[0], end: splinePoints[splinePoints.length - 1], points: splinePoints, constraints: []};
                            shapes.push(spline);
                            activeShape = null;
                            splinePoints = [];
                            setTool('select');
                        } else {
                            // Continue adding points
                            activeShape = {id: Date.now(), start: coords, end: coords, type: 'spline', points: splinePoints, constraints: []};
                        }
                    } 
                } else {
                    const final = { ...activeShape, end: coords, endJointId: jId };
                    if (!final.id) final.id = Math.random();
                    shapes.push(final);
                    
                    if (snap) { 
                        // Snapped to existing point - end polyline
                        if (dimInputVisible) {
                            document.getElementById('dim-input').classList.add('hidden');
                            dimInputVisible = false;
                        }
                        activeShape = null;
                        setTool('select');
                    } else { 
                        // Continue drawing polyline - DON'T show input, just continue
                        // Start next segment from the end of this one
                        activeShape = { id: Date.now(), start: coords, end: coords, type: 'line', constraints: [], startJointId: jId }; 
                    }
                }
                render();
            }
        };

        // Constraint solver - propagates constraints through geometry
        function solveDrag(dx, dy) {
            // First pass: move directly dragged geometry
            shapes.forEach((s, i) => {
                const origS = dragTarget.originalShapes[i];
                if (s.startJointId !== ORIGIN.jointId && dragTarget.bondedJointIds.includes(s.startJointId)) {
                    s.start.x = origS.start.x + dx;
                    s.start.y = origS.start.y + dy;
                }
                if (s.endJointId !== ORIGIN.jointId && dragTarget.bondedJointIds.includes(s.endJointId)) {
                    s.end.x = origS.end.x + dx;
                    s.end.y = origS.end.y + dy;
                }
            });

            // First-and-half pass: enforce coincident constraints (make points at same joint ID be at same location)
            shapes.forEach(s => {
                // Find all shapes that share the same start joint ID and align their start points
                const startJointShapes = shapes.filter(sh => sh.startJointId === s.startJointId && sh.id !== s.id);
                if (startJointShapes.length > 0) {
                    startJointShapes.forEach(sh => {
                        sh.start.x = s.start.x;
                        sh.start.y = s.start.y;
                    });
                }
                // Same for end joint ID
                const endJointShapes = shapes.filter(sh => sh.endJointId === s.endJointId && sh.id !== s.id);
                if (endJointShapes.length > 0) {
                    endJointShapes.forEach(sh => {
                        sh.end.x = s.end.x;
                        sh.end.y = s.end.y;
                    });
                }
            });

            // Second pass: enforce simple constraints (horiz/vert)
            shapes.forEach(s => {
                if (s.constraints.includes('horiz')) {
                    s.end.y = s.start.y;
                }
                if (s.constraints.includes('vert')) {
                    s.end.x = s.start.x;
                }
            });

            // Third pass: enforce parallel/perpendicular/tangent/colinear
            shapes.forEach(s => {
                if (s.constraints.includes('parallel') && s.parallelWith) {
                    const otherLine = shapes.find(sh => sh.id === s.parallelWith);
                    if (otherLine) {
                        const refAngle = getAngle(otherLine.start, otherLine.end);
                        const currLen = getDist(s.start, s.end);
                        if (currLen > 1) {
                            s.end.x = Math.round(s.start.x + currLen * Math.cos(refAngle));
                            s.end.y = Math.round(s.start.y + currLen * Math.sin(refAngle));
                        }
                    }
                }
                
                if (s.constraints.includes('perpendicular') && s.perpendicularWith) {
                    const otherLine = shapes.find(sh => sh.id === s.perpendicularWith);
                    if (otherLine) {
                        const refAngle = getAngle(otherLine.start, otherLine.end);
                        const perpAngle = refAngle + Math.PI / 2;
                        const currLen = getDist(s.start, s.end);
                        if (currLen > 1) {
                            s.end.x = Math.round(s.start.x + currLen * Math.cos(perpAngle));
                            s.end.y = Math.round(s.start.y + currLen * Math.sin(perpAngle));
                        }
                    }
                }
                
                if (s.constraints.includes('colinear') && s.colinearWith) {
                    const otherLine = shapes.find(sh => sh.id === s.colinearWith);
                    if (otherLine) {
                        // Project start point onto the other line's infinite extension
                        const refAngle = getAngle(otherLine.start, otherLine.end);
                        const closestPt = projectPointOnLineInfinite(s.start, otherLine.start, otherLine.end);
                        s.start.x = closestPt.x;
                        s.start.y = closestPt.y;
                        // Keep the same length but align with reference angle
                        const currLen = getDist(s.start, s.end);
                        if (currLen > 1) {
                            s.end.x = Math.round(s.start.x + currLen * Math.cos(refAngle));
                            s.end.y = Math.round(s.start.y + currLen * Math.sin(refAngle));
                        }
                    }
                }
                
                if (s.constraints.includes('midpoint') && s.midpointWith) {
                    const otherLine = shapes.find(sh => sh.id === s.midpointWith);
                    if (otherLine) {
                        // Move this point to the midpoint of the other line
                        const mx = (otherLine.start.x + otherLine.end.x) / 2;
                        const my = (otherLine.start.y + otherLine.end.y) / 2;
                        s.start.x = Math.round(mx);
                        s.start.y = Math.round(my);
                    }
                }
            });

            // Fourth pass: enforce tangent constraints
            shapes.forEach(s => {
                if (s.constraints.includes('tangent') && s.tangentWith) {
                    const otherShape = shapes.find(sh => sh.id === s.tangentWith);
                    if (!otherShape) return;

                    if (s.type === 'line' && otherShape.type === 'circle') {
                        // Line is tangent to circle
                        const circleCenter = otherShape.start;
                        const circleRadius = getDist(otherShape.start, otherShape.end);
                        const closestPt = projectPointOnLine(circleCenter, s.start, s.end);
                        const distToLine = getDist(circleCenter, closestPt);
                        
                        if (Math.abs(distToLine - circleRadius) > 0.5) {
                            // Calculate the normal vector from line to circle center
                            const lineLen = getDist(s.start, s.end);
                            if (lineLen > 1) {
                                const lineDir = {x: (s.end.x - s.start.x) / lineLen, y: (s.end.y - s.start.y) / lineLen};
                                const normal = {x: -lineDir.y, y: lineDir.x};
                                const moveDistance = circleRadius - distToLine;
                                // Move the entire line perpendicular to itself
                                s.start.x += normal.x * moveDistance;
                                s.start.y += normal.y * moveDistance;
                                s.end.x += normal.x * moveDistance;
                                s.end.y += normal.y * moveDistance;
                            }
                        }
                    } 
                    else if (s.type === 'circle' && otherShape.type === 'line') {
                        // Circle is tangent to line
                        const radius = getDist(s.start, s.end);
                        const closestPt = projectPointOnLine(s.start, otherShape.start, otherShape.end);
                        const distToLine = getDist(s.start, closestPt);
                        
                        if (Math.abs(distToLine - radius) > 0.5) {
                            // Move circle center perpendicular to the line
                            const lineLen = getDist(otherShape.start, otherShape.end);
                            if (lineLen > 1) {
                                const lineDir = {x: (otherShape.end.x - otherShape.start.x) / lineLen, y: (otherShape.end.y - otherShape.start.y) / lineLen};
                                const normal = {x: -lineDir.y, y: lineDir.x};
                                const moveDistance = (radius - distToLine) * (distToLine > 0 ? 1 : 1);
                                s.start.x = closestPt.x + normal.x * radius;
                                s.start.y = closestPt.y + normal.y * radius;
                            }
                        }
                    } 
                    else if (s.type === 'circle' && otherShape.type === 'circle') {
                        // Circle-to-circle tangency (external)
                        const r1 = getDist(s.start, s.end);
                        const r2 = getDist(otherShape.start, otherShape.end);
                        const dist = getDist(s.start, otherShape.start);
                        const targetDist = r1 + r2;
                        
                        if (Math.abs(dist - targetDist) > 0.5 && dist > 0.5) {
                            const dirX = (otherShape.start.x - s.start.x) / dist;
                            const dirY = (otherShape.start.y - s.start.y) / dist;
                            s.start.x = otherShape.start.x - dirX * targetDist;
                            s.start.y = otherShape.start.y - dirY * targetDist;
                        }
                    }
                }
            });

            // Fifth pass: enforce dimensions - iterate multiple times for convergence
            for (let iter = 0; iter < 3; iter++) {
                dimensions.forEach(dim => {
                    const s1 = dim.ref1.shapeId === 'fixed-origin' ? {start: ORIGIN, startJointId: ORIGIN.jointId} : shapes.find(sh => sh.id === dim.ref1.shapeId);
                    const s2 = dim.ref2.shapeId === 'fixed-origin' ? {start: ORIGIN, startJointId: ORIGIN.jointId} : shapes.find(sh => sh.id === dim.ref2.shapeId);
                    
                    if (!s1 || !s2) return;
                    
                    const p1 = s1[dim.ref1.part];
                    const p2 = s2[dim.ref2.part];
                    const j1 = s1[dim.ref1.part + 'JointId'] || s1.startJointId;
                    const j2 = s2[dim.ref2.part + 'JointId'] || s2.startJointId;
                    
                    const currDist = getDist(p1, p2);
                    if (currDist < 1) return;
                    
                    const targetDist = dim.value;
                    const error = Math.abs(currDist - targetDist);
                    
                    // Only apply if error is significant
                    if (error > 0.1) {
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        
                        // If dragging p2, move it to maintain distance from p1
                        if (dragTarget.bondedJointIds.includes(j2) && !dragTarget.bondedJointIds.includes(j1)) {
                            const scale = targetDist / currDist;
                            p2.x = p1.x + dx * scale;
                            p2.y = p1.y + dy * scale;
                        }
                        // If dragging p1, move it to maintain distance from p2
                        else if (dragTarget.bondedJointIds.includes(j1) && !dragTarget.bondedJointIds.includes(j2)) {
                            const scale = targetDist / currDist;
                            p1.x = p2.x - dx * scale;
                            p1.y = p2.y - dy * scale;
                        }
                    }
                });
            }

            // Final pass: re-enforce coincident constraints to ensure all connected joints are at same location
            shapes.forEach(s => {
                const startJointShapes = shapes.filter(sh => sh.startJointId === s.startJointId && sh.id !== s.id);
                startJointShapes.forEach(sh => {
                    sh.start.x = s.start.x;
                    sh.start.y = s.start.y;
                });
                const endJointShapes = shapes.filter(sh => sh.endJointId === s.endJointId && sh.id !== s.id);
                endJointShapes.forEach(sh => {
                    sh.end.x = s.end.x;
                    sh.end.y = s.end.y;
                });
            });
        }

        svg.onpointermove = (e) => {
            const raw = getCoords(e);
            const snap = findSnap(raw);
            const coords = snap || raw;

            // Snap indicator logic
            snapLayer.innerHTML = snap ? `<rect x="${snap.x-4}" y="${snap.y-4}" width="8" height="8" fill="none" stroke="#3B82F6" stroke-width="2"/>` : '';

            if (panStart) {
                viewPan.x = panStart.prevPan.x + (e.clientX - panStart.x);
                viewPan.y = panStart.prevPan.y + (e.clientY - panStart.y);
                updateViewportTransform();
                return;
            }

            // Update hover target for highlight
            if (!dragTarget && !activeShape && currentTool === 'select') {
                const hit = findHit(raw);
                hoverTarget = hit ? hit.shape.id : null;
                render();
            } else if (dragTarget) {
                hoverTarget = null;  // Clear hover while dragging
            }

            if (dragTarget) {
                const dx = coords.x - dragTarget.originalCoords.x;
                const dy = coords.y - dragTarget.originalCoords.y;
                solveDrag(dx, dy);
                render();
            } else if (activeShape) { 
                activeShape.end = coords; 
                render(); 
            }
        };

        svg.onpointerup = (e) => { 
            if (dragTarget) { svg.releasePointerCapture(e.pointerId); dragTarget = null; } 
            if (panStart) { svg.releasePointerCapture(e.pointerId); panStart = null; svg.classList.remove('cursor-pan'); }
        };

        // Scroll wheel zoom
        svg.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoom = 1.1;
            const factor = e.deltaY > 0 ? 1 / zoom : zoom;
            const rect = svg.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Store old scale
            const oldScale = worldGroup.getAttribute('data-scale') || 1;
            const newScale = Math.max(0.1, Math.min(10, oldScale * factor));
            worldGroup.setAttribute('data-scale', newScale);
            
            // Adjust pan to zoom toward mouse position
            viewPan.x = mouseX + (viewPan.x - mouseX) * (newScale / oldScale);
            viewPan.y = mouseY + (viewPan.y - mouseY) * (newScale / oldScale);
            
            updateViewportTransform();
            render();
        }, { passive: false });

        // Space bar pan (hold space and drag)
        let spacePressed = false;
        let spacePanStart = null;

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                spacePressed = true;
                svg.classList.add('cursor-pan');
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                spacePressed = false;
                spacePanStart = null;
                svg.classList.remove('cursor-pan');
            }
        });

        svg.addEventListener('pointerdown', (e) => {
            if (spacePressed && !panStart && !dragTarget) {
                svg.setPointerCapture(e.pointerId);
                spacePanStart = { x: e.clientX, y: e.clientY, prevPan: {...viewPan}, pointerId: e.pointerId };
            }
        });

        svg.addEventListener('pointermove', (e) => {
            if (spacePanStart && spacePanStart.pointerId === e.pointerId) {
                viewPan.x = spacePanStart.prevPan.x + (e.clientX - spacePanStart.x);
                viewPan.y = spacePanStart.prevPan.y + (e.clientY - spacePanStart.y);
                updateViewportTransform();
                return;
            }
        });

        svg.addEventListener('pointerup', (e) => {
            if (spacePanStart && spacePanStart.pointerId === e.pointerId) {
                svg.releasePointerCapture(e.pointerId);
                spacePanStart = null;
            }
        });

        // Pinch zoom (touch)
        let touchDistance = 0;
        svg.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                const p1 = e.touches[0];
                const p2 = e.touches[1];
                touchDistance = Math.sqrt(
                    Math.pow(p2.clientX - p1.clientX, 2) + 
                    Math.pow(p2.clientY - p1.clientY, 2)
                );
            }
        });

        svg.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                const p1 = e.touches[0];
                const p2 = e.touches[1];
                const newDistance = Math.sqrt(
                    Math.pow(p2.clientX - p1.clientX, 2) + 
                    Math.pow(p2.clientY - p1.clientY, 2)
                );
                
                if (touchDistance > 0) {
                    const factor = newDistance / touchDistance;
                    const oldScale = worldGroup.getAttribute('data-scale') || 1;
                    const newScale = Math.max(0.1, Math.min(10, oldScale * factor));
                    worldGroup.setAttribute('data-scale', newScale);
                    
                    // Zoom toward midpoint between fingers
                    const rect = svg.getBoundingClientRect();
                    const midX = (p1.clientX + p2.clientX) / 2 - rect.left;
                    const midY = (p1.clientY + p2.clientY) / 2 - rect.top;
                    viewPan.x = midX + (viewPan.x - midX) * (newScale / oldScale);
                    viewPan.y = midY + (viewPan.y - midY) * (newScale / oldScale);
                    
                    touchDistance = newDistance;
                    updateViewportTransform();
                    render();
                }
            }
        });

        // --- CONSTRAINT & DIMENSION MANAGEMENT ---
        function setRectMode(mode) {
            rectangleMode = mode;
            rectModePoints = [];
            document.getElementById('mode-text').innerText = 'MODE: RECT (' + mode.toUpperCase() + ')';
        }

        function setArcMode(mode) {
            arcMode = mode;
            arcPoints = [];
            document.getElementById('mode-text').innerText = 'MODE: ARC (' + mode.toUpperCase() + ')';
        }

        function showDimensionInput(shapeId) {
            lastCreatedShapeId = shapeId;
            const shape = shapes.find(s => s.id === shapeId);
            if (!shape) return;
            
            const dimInput = document.getElementById('dim-input');
            const svg = document.getElementById('canvas-svg');
            const rect = svg.getBoundingClientRect();
            
            // Calculate center of shape in viewport coordinates
            const centerX = shape.start.x + (shape.end.x - shape.start.x) / 2;
            const centerY = shape.start.y + (shape.end.y - shape.start.y) / 2;
            
            // Transform to screen coordinates
            const pt = svg.createSVGPoint();
            pt.x = centerX;
            pt.y = centerY;
            const screenPt = pt.matrixTransform(worldGroup.getCTM());
            
            // Position input at shape center
            dimInput.style.left = (screenPt.x - 30) + 'px';
            dimInput.style.top = (screenPt.y - 15) + 'px';
            dimInput.value = '';
            dimInput.classList.remove('hidden');
            dimInput.focus();
            dimInputVisible = true;
        }

        function showDimensionInputForActiveShape() {
            if (!activeShape) return;
            
            const dimInput = document.getElementById('dim-input');
            const svg = document.getElementById('canvas-svg');
            
            // Calculate center of active shape
            const centerX = activeShape.start.x;
            const centerY = activeShape.start.y;
            
            // Transform to screen coordinates
            const pt = svg.createSVGPoint();
            pt.x = centerX;
            pt.y = centerY;
            const screenPt = pt.matrixTransform(worldGroup.getCTM());
            
            // Position input at shape start point
            dimInput.style.left = (screenPt.x - 30) + 'px';
            dimInput.style.top = (screenPt.y - 15) + 'px';
            dimInput.value = '';
            dimInput.classList.remove('hidden');
            dimInput.focus();
            dimInputVisible = true;
        }

        function applyDimensionFromInput() {
            if (!lastCreatedShapeId) return;
            const dimInput = document.getElementById('dim-input');
            const value = parseFloat(dimInput.value);
            
            if (!isNaN(value) && value > 0) {
                const shape = shapes.find(s => s.id === lastCreatedShapeId);
                if (shape) {
                    const dimValue = getDist(shape.start, shape.end);
                    dimensions.push({ 
                        ref1: { shapeId: shape.id, part: 'start' }, 
                        ref2: { shapeId: shape.id, part: 'end' }, 
                        value: value 
                    });
                    // Scale the shape to match the input dimension
                    if (dimValue > 0) {
                        const scale = value / dimValue;
                        shape.end.x = shape.start.x + (shape.end.x - shape.start.x) * scale;
                        shape.end.y = shape.start.y + (shape.end.y - shape.start.y) * scale;
                    }
                }
            }
            
            dimInput.classList.add('hidden');
            dimInputVisible = false;
            lastCreatedShapeId = null;
            render();
        }

        function selectConstraint(shapeId, index) {
            selectedConstraint = { shapeId, index };
            render();
        }

        function deleteActiveConstraint() {
            if (selectedConstraint) {
                const shape = shapes.find(s => s.id === selectedConstraint.shapeId);
                if (shape && shape.constraints) {
                    shape.constraints.splice(selectedConstraint.index, 1);
                    selectedConstraint = null;
                    render();
                }
            }
        }

        function editDimension(dimIndex) {
            const dim = dimensions[dimIndex];
            if (!dim) return;
            
            const newValue = prompt(`Edit dimension (current: ${dim.value.toFixed(1)}):`, dim.value.toFixed(1));
            if (newValue !== null) {
                const parsed = parseFloat(newValue);
                if (!isNaN(parsed) && parsed > 0) {
                    dim.value = parsed;
                    // Solve constraints to adjust geometry to match new dimension
                    solveDimensionConstraint(dimIndex);
                    render();
                }
            }
        }

        function solveDimensionConstraint(dimIndex) {
            const dim = dimensions[dimIndex];
            if (!dim) return;

            const s1 = dim.ref1.shapeId === 'fixed-origin' ? {start: ORIGIN, startJointId: ORIGIN.jointId} : shapes.find(sh => sh.id === dim.ref1.shapeId);
            const s2 = dim.ref2.shapeId === 'fixed-origin' ? {start: ORIGIN, startJointId: ORIGIN.jointId} : shapes.find(sh => sh.id === dim.ref2.shapeId);
            
            if (!s1 || !s2) return;
            
            const p1 = s1[dim.ref1.part];
            const p2 = s2[dim.ref2.part];
            const j1 = s1[dim.ref1.part + 'JointId'] || s1.startJointId;
            const j2 = s2[dim.ref2.part + 'JointId'] || s2.startJointId;
            
            const currDist = getDist(p1, p2);
            if (currDist < 1) return;
            
            // Scale p2 to maintain dimension (assuming p1 is fixed)
            const scale = dim.value / currDist;
            p2.x = p1.x + (p2.x - p1.x) * scale;
            p2.y = p1.y + (p2.y - p1.y) * scale;
            
            // Re-enforce horiz/vert constraints
            shapes.forEach(s => {
                if (s.constraints.includes('horiz')) s.end.y = s.start.y;
                if (s.constraints.includes('vert')) s.end.x = s.start.x;
            });
        }

        // --- RENDER ---
        function setTool(tool) {
            currentTool = tool; multiRefs = []; hoverTarget = null; selectedConstraint = null; selectedShapes.clear(); coincidentFirstRef = null; parallelFirstLine = null; perpendFirstLine = null; tangentFirstShape = null; colinearFirstLine = null; midpointFirstLine = null; polygonPoints = []; splinePoints = [];
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            const idMap = { select: 'btn-select', line: 'btn-line', midpointline: 'btn-midpointline', rect: 'btn-rect', circle: 'btn-circle', polygon: 'btn-polygon', ellipse: 'btn-ellipse', slot: 'btn-slot', spline: 'btn-spline', arc: 'btn-arc', coincident: 'btn-coinc', horiz: 'btn-horiz', vert: 'btn-vert', parallel: 'btn-parallel', perpend: 'btn-perpend', tangent: 'btn-tangent', colinear: 'btn-colinear', midpoint: 'btn-midpoint', dimension: 'btn-dimension' };
            if (idMap[tool]) document.getElementById(idMap[tool]).classList.add('active');
            document.getElementById('mode-text').innerText = 'MODE: ' + tool.toUpperCase();
            
            // Update cursor based on tool
            svg.classList.remove('cursor-select', 'cursor-draw', 'cursor-pan', 'cursor-coincident', 'cursor-parallel', 'cursor-perpend', 'cursor-tangent', 'cursor-dimension');
            if (['line', 'midpointline', 'circle', 'rect', 'arc', 'polygon', 'ellipse', 'slot', 'spline'].includes(tool)) svg.classList.add('cursor-draw');
            else if (tool === 'coincident') svg.classList.add('cursor-coincident');
            else if (tool === 'parallel') svg.classList.add('cursor-parallel');
            else if (tool === 'perpend') svg.classList.add('cursor-perpend');
            else if (tool === 'tangent') svg.classList.add('cursor-tangent');
            else if (tool === 'dimension') svg.classList.add('cursor-dimension');
            else svg.classList.add('cursor-select');
            
            activeShape = null; render();
        }

        function render() {
            shapesLayer.innerHTML = shapes.map(s => {
                const color = s.locked ? "#0F172A" : "#3B82F6";
                
                // Highlight first selected line in parallel/perpendicular mode
                const isParallelSelected = parallelFirstLine === s.id;
                const isPerpendSelected = perpendFirstLine === s.id;
                const isShapeSelected = selectedShapes.has(s.id);
                const isShapeHovered = hoverTarget === s.id && currentTool === 'select';
                
                // Priority: constraint mode > selection > hover > normal
                let lineColor = color;
                let lineWidth = 2.5;
                if (isParallelSelected || isPerpendSelected) {
                    lineColor = '#EA580C';
                    lineWidth = 4;
                } else if (isShapeSelected) {
                    lineColor = '#EA580C';
                    lineWidth = 3.5;
                } else if (isShapeHovered) {
                    lineColor = '#F97316';
                    lineWidth = 3;
                }
                
                let html = '';
                if (s.type === 'circle') {
                    html = `<circle cx="${s.start.x}" cy="${s.start.y}" r="${getDist(s.start, s.end)}" fill="none" stroke="${lineColor}" stroke-width="${lineWidth}" />`;
                } else if (s.type === 'ellipse') {
                    const rx = Math.abs(s.end.x - s.start.x);
                    const ry = Math.abs(s.end.y - s.start.y);
                    html = `<ellipse cx="${s.start.x}" cy="${s.start.y}" rx="${rx}" ry="${ry}" fill="none" stroke="${lineColor}" stroke-width="${lineWidth}" />`;
                } else if (s.type === 'polygon' && s.points && s.points.length > 0) {
                    const points = s.points.map(p => `${p.x},${p.y}`).join(' ');
                    html = `<polygon points="${points}" fill="none" stroke="${lineColor}" stroke-width="${lineWidth}" />`;
                } else if (s.type === 'spline' && s.points && s.points.length > 1) {
                    const pathData = s.points.reduce((path, point, i) => {
                        if (i === 0) return `M ${point.x} ${point.y}`;
                        return path + ` L ${point.x} ${point.y}`;
                    }, '');
                    html = `<path d="${pathData}" fill="none" stroke="${lineColor}" stroke-width="${lineWidth}" />`;
                } else if (s.type === 'slot') {
                    // Slot: rectangle with semi-circular ends
                    const w = Math.abs(s.end.x - s.start.x);
                    const h = Math.abs(s.end.y - s.start.y);
                    const x = Math.min(s.start.x, s.end.x);
                    const y = Math.min(s.start.y, s.end.y);
                    const isHorizontal = w > h;
                    if (isHorizontal) {
                        const r = h / 2;
                        html = `<g><rect x="${x + r}" y="${y}" width="${w - 2*r}" height="${h}" fill="none" stroke="${lineColor}" stroke-width="${lineWidth}" />
                                <circle cx="${x + r}" cy="${y + r}" r="${r}" fill="none" stroke="${lineColor}" stroke-width="${lineWidth}" />
                                <circle cx="${x + w - r}" cy="${y + r}" r="${r}" fill="none" stroke="${lineColor}" stroke-width="${lineWidth}" /></g>`;
                    } else {
                        const r = w / 2;
                        html = `<g><rect x="${x}" y="${y + r}" width="${w}" height="${h - 2*r}" fill="none" stroke="${lineColor}" stroke-width="${lineWidth}" />
                                <circle cx="${x + r}" cy="${y + r}" r="${r}" fill="none" stroke="${lineColor}" stroke-width="${lineWidth}" />
                                <circle cx="${x + r}" cy="${y + h - r}" r="${r}" fill="none" stroke="${lineColor}" stroke-width="${lineWidth}" /></g>`;
                    }
                } else {
                    html = `<line x1="${s.start.x}" y1="${s.start.y}" x2="${s.end.x}" y2="${s.end.y}" stroke="${lineColor}" stroke-width="${lineWidth}" stroke-linecap="round" />`;
                }
                
                // Highlight first selected point in coincident mode
                const startSelected = coincidentFirstRef && coincidentFirstRef.shapeId === s.id && coincidentFirstRef.part === 'start';
                const endSelected = coincidentFirstRef && coincidentFirstRef.shapeId === s.id && coincidentFirstRef.part === 'end';
                
                const startColor = startSelected ? '#EA580C' : color;
                const endColor = endSelected ? '#EA580C' : color;
                const startRadius = startSelected ? 6 : 3;
                const endRadius = endSelected ? 6 : 3;
                
                if (s.type !== 'polygon' && s.type !== 'spline') {
                    html += `<circle cx="${s.start.x}" cy="${s.start.y}" r="${startRadius}" fill="white" stroke="${startColor}" stroke-width="${startSelected ? 3 : 1.5}" />
                             <circle cx="${s.end.x}" cy="${s.end.y}" r="${endRadius}" fill="white" stroke="${endColor}" stroke-width="${endSelected ? 3 : 1.5}" />`;
                }
                
                const mx = (s.start.x + s.end.x)/2, my = (s.start.y + s.end.y)/2;
                s.constraints?.forEach((c, i) => {
                    const cType = typeof c === 'string' ? c : c.type;
                    const isS = selectedConstraint && selectedConstraint.shapeId === s.id && selectedConstraint.index === i;
                    const ico = cType === 'horiz' ? '-' : cType === 'vert' ? '|' : cType === 'perpendicular' ? '' : cType === 'parallel' ? '' : cType === 'colinear' ? '/' : cType === 'midpoint' ? '' : 'X';
                    let tx = (cType === 'coincident') ? s.start.x + 8 : mx + (i * 12);
                    let ty = (cType === 'coincident') ? s.start.y - 8 : my - 12;
                    html += `<g class="constraint-glyph ${isS ? 'selected' : ''}" onpointerdown="event.stopPropagation(); selectConstraint(${s.id}, ${i})" transform="translate(${tx}, ${ty})">
                        <rect x="-5" y="-5" width="10" height="10" fill="white" rx="1.5"/><text y="3" text-anchor="middle" font-size="7" font-weight="900" fill="${isS ? '#EA580C' : '#64748B'}">${ico}</text></g>`;
                });
                return html;
            }).join('');

            dimLayer.innerHTML = dimensions.map((d, i) => {
                const s1 = d.ref1.shapeId === 'fixed-origin' ? {start: ORIGIN, part: 'start'} : shapes.find(s => s.id === d.ref1.shapeId);
                const s2 = d.ref2.shapeId === 'fixed-origin' ? {start: ORIGIN, part: 'start'} : shapes.find(s => s.id === d.ref2.shapeId);
                const p1 = s1[d.ref1.part], p2 = s2[d.ref2.part];
                const mx = (p1.x + p2.x)/2, my = (p1.y + p2.y)/2;
                return `<g class="dim-container"><line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="#EA580C" stroke-width="1" stroke-dasharray="2"/>
                    <g transform="translate(${mx}, ${my})"><rect x="-20" y="-8" width="40" height="16" fill="white" rx="2" stroke="#EA580C" stroke-width="0.5"/>
                    <text y="3.5" text-anchor="middle" fill="#EA580C" font-weight="bold" font-size="9">${d.value.toFixed(1)}</text></g></g>`;
            }).join('');

            // Preview for active shape being drawn
            let previewHtml = '';
            if (activeShape) {
                if (activeShape.type === 'rect') {
                    // Show rectangle outline while dragging
                    const s = activeShape.start, e = activeShape.end;
                    const c1 = {x: s.x, y: s.y}, c2 = {x: e.x, y: s.y}, c3 = {x: e.x, y: e.y}, c4 = {x: s.x, y: e.y};
                    previewHtml = `<g opacity="0.7">
                        <line x1="${c1.x}" y1="${c1.y}" x2="${c2.x}" y2="${c2.y}" stroke="#3B82F6" stroke-width="2" stroke-dasharray="4" />
                        <line x1="${c2.x}" y1="${c2.y}" x2="${c3.x}" y2="${c3.y}" stroke="#3B82F6" stroke-width="2" stroke-dasharray="4" />
                        <line x1="${c3.x}" y1="${c3.y}" x2="${c4.x}" y2="${c4.y}" stroke="#3B82F6" stroke-width="2" stroke-dasharray="4" />
                        <line x1="${c4.x}" y1="${c4.y}" x2="${c1.x}" y2="${c1.y}" stroke="#3B82F6" stroke-width="2" stroke-dasharray="4" />
                        <circle cx="${c1.x}" cy="${c1.y}" r="2" fill="#3B82F6" />
                        <circle cx="${c2.x}" cy="${c2.y}" r="2" fill="#3B82F6" />
                        <circle cx="${c3.x}" cy="${c3.y}" r="2" fill="#3B82F6" />
                        <circle cx="${c4.x}" cy="${c4.y}" r="2" fill="#3B82F6" />
                    </g>`;
                } else if (activeShape.type === 'circle') {
                    // Show circle outline while dragging
                    const radius = getDist(activeShape.start, activeShape.end);
                    previewHtml = `<circle cx="${activeShape.start.x}" cy="${activeShape.start.y}" r="${radius}" fill="none" stroke="#3B82F6" stroke-width="2" stroke-dasharray="4" opacity="0.7" />`;
                } else if (activeShape.type === 'ellipse') {
                    const rx = Math.abs(activeShape.end.x - activeShape.start.x);
                    const ry = Math.abs(activeShape.end.y - activeShape.start.y);
                    previewHtml = `<ellipse cx="${activeShape.start.x}" cy="${activeShape.start.y}" rx="${rx}" ry="${ry}" fill="none" stroke="#3B82F6" stroke-width="2" stroke-dasharray="4" opacity="0.7" />`;
                } else if (activeShape.type === 'slot') {
                    const w = Math.abs(activeShape.end.x - activeShape.start.x);
                    const h = Math.abs(activeShape.end.y - activeShape.start.y);
                    const x = Math.min(activeShape.start.x, activeShape.end.x);
                    const y = Math.min(activeShape.start.y, activeShape.end.y);
                    const isHorizontal = w > h;
                    if (isHorizontal) {
                        const r = h / 2;
                        previewHtml = `<g opacity="0.7"><rect x="${x + r}" y="${y}" width="${w - 2*r}" height="${h}" fill="none" stroke="#3B82F6" stroke-width="2" stroke-dasharray="4" />
                                <circle cx="${x + r}" cy="${y + r}" r="${r}" fill="none" stroke="#3B82F6" stroke-width="2" stroke-dasharray="4" />
                                <circle cx="${x + w - r}" cy="${y + r}" r="${r}" fill="none" stroke="#3B82F6" stroke-width="2" stroke-dasharray="4" /></g>`;
                    } else {
                        const r = w / 2;
                        previewHtml = `<g opacity="0.7"><rect x="${x}" y="${y + r}" width="${w}" height="${h - 2*r}" fill="none" stroke="#3B82F6" stroke-width="2" stroke-dasharray="4" />
                                <circle cx="${x + r}" cy="${y + r}" r="${r}" fill="none" stroke="#3B82F6" stroke-width="2" stroke-dasharray="4" />
                                <circle cx="${x + r}" cy="${y + h - r}" r="${r}" fill="none" stroke="#3B82F6" stroke-width="2" stroke-dasharray="4" /></g>`;
                    }
                } else if (activeShape.type === 'polygon' && polygonPoints.length > 0) {
                    const points = polygonPoints.map(p => `${p.x},${p.y}`).join(' ');
                    previewHtml = `<g opacity="0.7"><polyline points="${points} ${activeShape.end.x},${activeShape.end.y}" fill="none" stroke="#3B82F6" stroke-width="2" stroke-dasharray="4" />
                        ${polygonPoints.map((p, i) => `<circle cx="${p.x}" cy="${p.y}" r="2" fill="#3B82F6" />`).join('')}
                        <circle cx="${activeShape.end.x}" cy="${activeShape.end.y}" r="2" fill="#3B82F6" /></g>`;
                } else if (activeShape.type === 'spline' && splinePoints.length > 0) {
                    const pathData = [...splinePoints, activeShape.end].reduce((path, point, i) => {
                        if (i === 0) return `M ${point.x} ${point.y}`;
                        return path + ` L ${point.x} ${point.y}`;
                    }, '');
                    previewHtml = `<g opacity="0.7"><path d="${pathData}" fill="none" stroke="#3B82F6" stroke-width="2" stroke-dasharray="4" />
                        ${splinePoints.map(p => `<circle cx="${p.x}" cy="${p.y}" r="2" fill="#3B82F6" />`).join('')}
                        <circle cx="${activeShape.end.x}" cy="${activeShape.end.y}" r="2" fill="#3B82F6" /></g>`;
                } else {
                    // Show line preview
                    previewHtml = `<line x1="${activeShape.start.x}" y1="${activeShape.start.y}" x2="${activeShape.end.x}" y2="${activeShape.end.y}" stroke="#3B82F6" stroke-width="2" stroke-dasharray="4" />`;
                }
            }
            previewLayer.innerHTML = previewHtml;
        }

        function undo() { shapes.pop(); render(); }
        function clearCanvas() { shapes = []; dimensions = []; render(); }
        function toggleLock() { isLocked = !isLocked; shapes.forEach(s => s.locked = isLocked); document.getElementById('lock-btn').innerText = isLocked ? 'LOCKED' : 'EDIT'; render(); }

        // Auto-save to localStorage
        function autoSave() {
            const sketch = { shapes, dimensions };
            localStorage.setItem('fusion360sketch', JSON.stringify(sketch));
        }

        // Auto-load from localStorage
        function autoLoad() {
            const saved = localStorage.getItem('fusion360sketch');
            if (saved) {
                try {
                    const sketch = JSON.parse(saved);
                    shapes = sketch.shapes || [];
                    dimensions = sketch.dimensions || [];
                    render();
                    console.log('Sketch loaded from localStorage');
                } catch (e) {
                    console.error('Failed to load sketch:', e);
                }
            }
        }

        // Export sketch as JSON file
        function exportSketch() {
            const sketch = { shapes, dimensions, exportDate: new Date().toISOString() };
            const json = JSON.stringify(sketch, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `sketch_${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // Import sketch from JSON file
        function importSketch() {
            document.getElementById('import-file').click();
        }

        function loadImportedFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const sketch = JSON.parse(e.target.result);
                    shapes = sketch.shapes || [];
                    dimensions = sketch.dimensions || [];
                    render();
                    autoSave();
                    console.log('Sketch imported successfully');
                } catch (err) {
                    alert('Failed to import sketch: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input
        }

        window.onkeydown = (e) => { 
            const k = e.key.toLowerCase();
            
            if (k === 'l') setTool('line'); if (k === 'r') setTool('rect'); if (k === 'c') setTool('circle'); if (k === 'd') setTool('dimension');
            if (e.key === 'Escape') setTool('select'); if (e.key === 'Delete' || e.key === 'Backspace') deleteActiveConstraint();
        };

        // Auto-save every 5 seconds
        // setInterval(autoSave, 5000);

        // Load on startup
        // window.addEventListener('load', autoLoad);

        // Dimension input handlers
        const dimInput = document.getElementById('dim-input');
        dimInput.addEventListener('keydown', (e) => {
            e.stopPropagation();
            if (e.key === 'Enter') {
                applyDimensionFromInput();
                setTool('select');
            }
        });
        dimInput.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        dimInput.addEventListener('pointerdown', (e) => {
            e.stopPropagation();
        });
        
        // Close dimension input on canvas click (when clicking elsewhere, not on input)
        svg.addEventListener('pointerdown', (e) => {
            if (dimInputVisible && e.target !== dimInput && !dimInput.contains(e.target)) {
                dimInput.classList.add('hidden');
                dimInputVisible = false;
                lastCreatedShapeId = null;
                setTool('select');
                render();
            }
        }, true);
    </script>
</body>
</html>

