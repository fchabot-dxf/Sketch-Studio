<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sketch Studio Ultimate - CAD Solver</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono&display=swap');
        
        :root {
            --accent: #EA580C;
            --accent-soft: #FFF7ED;
            --primary: #3B82F6;
            --bg-dark: #1E293B;
        }

        body { 
            font-family: 'Inter', sans-serif; 
            touch-action: none; 
            overflow: hidden; 
            background: #F1F5F9;
        }

        .tool-btn { 
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1); 
            border: 1px solid transparent;
            color: #64748B;
        }
        .tool-btn:hover { background-color: #F1F5F9; color: var(--primary); }
        .tool-btn.active { 
            background-color: var(--primary); 
            color: white !important; 
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
        }
        .tool-btn.active i, .tool-btn.active span { color: white !important; }

        #canvas-svg { width: 100%; height: 100%; touch-action: none; cursor: crosshair; }
        .cursor-select { cursor: default; }
        
        .dim-input { 
            position: absolute; background: white; border: 2px solid var(--accent);
            border-radius: 6px; padding: 4px 8px; font-weight: 800; font-size: 12px;
            outline: none; text-align: center; z-index: 100; box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
            font-family: 'JetBrains Mono', monospace;
        }
        .hidden { display: none; }

        .constraint-glyph { cursor: pointer; pointer-events: auto; }
        .constraint-glyph rect { fill: white; stroke: #CBD5E1; stroke-width: 1px; rx: 3px; }
        .constraint-glyph:hover rect { fill: #F8FAFC; stroke: var(--primary); }
        .constraint-glyph.selected rect { fill: var(--accent-soft); stroke: var(--accent); stroke-width: 2px; }
        .constraint-glyph.selected text { fill: var(--accent); }

        .no-scrollbar::-webkit-scrollbar { display: none; }
        
        .badge {
            font-size: 9px;
            padding: 1px 4px;
            border-radius: 3px;
            font-weight: 900;
            text-transform: uppercase;
        }
    </style>
</head>
<body class="flex flex-col h-screen select-none text-xs">

    <header class="bg-[#1E293B] text-white px-4 py-2.5 flex justify-between items-center z-50 shadow-md">
        <div class="flex items-center gap-3">
            <div class="bg-orange-600 p-1.5 rounded-lg shadow-lg rotate-3">
                <i data-lucide="component" class="w-4 h-4 text-white"></i>
            </div>
            <div>
                <h1 class="text-[11px] font-extrabold uppercase tracking-widest text-white leading-none">Sketch Studio</h1>
                <span class="text-[9px] text-slate-400 font-bold tracking-tighter">ULTIMATE SOLVER V2.8</span>
            </div>
        </div>
        <div class="flex items-center gap-6">
            <div class="flex items-center gap-2">
                <span class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
                <span class="text-[10px] font-bold text-slate-300 uppercase">Solver: Converged</span>
            </div>
            <div id="coords-display" class="font-mono text-[10px] text-slate-400 bg-slate-800 px-2 py-1 rounded">X: 0 Y: 0</div>
        </div>
    </header>

    <div class="bg-white border-b border-slate-200 p-1 flex gap-1 z-40 overflow-x-auto no-scrollbar shadow-sm">
        <div class="flex gap-1 pr-2 border-r border-slate-100">
            <button onclick="setTool('select')" id="btn-select" class="tool-btn active flex flex-col items-center justify-center min-w-[50px] h-14 rounded-lg">
                <i data-lucide="mouse-pointer-2" class="w-5 mb-1"></i>
                <span class="text-[8px] font-bold uppercase">Select</span>
            </button>
        </div>

        <div class="flex gap-1 px-2 border-r border-slate-100">
            <button onclick="setTool('line')" id="btn-line" class="tool-btn flex flex-col items-center justify-center min-w-[50px] h-14 rounded-lg">
                <i data-lucide="minus" class="w-5 mb-1"></i>
                <span class="text-[8px] font-bold uppercase">Line</span>
            </button>
            <button onclick="setTool('rect')" id="btn-rect" class="tool-btn flex flex-col items-center justify-center min-w-[50px] h-14 rounded-lg">
                <i data-lucide="square" class="w-5 mb-1"></i>
                <span class="text-[8px] font-bold uppercase">Rect</span>
            </button>
            <button onclick="setTool('circle')" id="btn-circle" class="tool-btn flex flex-col items-center justify-center min-w-[50px] h-14 rounded-lg">
                <i data-lucide="circle" class="w-5 mb-1"></i>
                <span class="text-[8px] font-bold uppercase">Circle</span>
            </button>
        </div>

        <div class="flex gap-1 px-2 border-r border-slate-100">
            <button onclick="setTool('coincident')" id="btn-coincident" class="tool-btn flex flex-col items-center justify-center min-w-[50px] h-14 rounded-lg">
                <i data-lucide="link" class="w-5 mb-1 text-blue-500"></i>
                <span class="text-[8px] font-bold uppercase">Coinc</span>
            </button>
            <button onclick="setTool('hv')" id="btn-hv" class="tool-btn flex flex-col items-center justify-center min-w-[50px] h-14 rounded-lg">
                <i data-lucide="split" class="w-5 mb-1"></i>
                <span class="text-[8px] font-bold uppercase">H / V</span>
            </button>
            <button onclick="setTool('parallel')" id="btn-parallel" class="tool-btn flex flex-col items-center justify-center min-w-[50px] h-14 rounded-lg">
                <i data-lucide="columns-2" class="w-5 mb-1 rotate-45"></i>
                <span class="text-[8px] font-bold uppercase">Para</span>
            </button>
            <button onclick="setTool('perpend')" id="btn-perpend" class="tool-btn flex flex-col items-center justify-center min-w-[50px] h-14 rounded-lg">
                <i data-lucide="corner-down-right" class="w-5 mb-1"></i>
                <span class="text-[8px] font-bold uppercase">Perp</span>
            </button>
            <button onclick="setTool('midpoint')" id="btn-midpoint" class="tool-btn flex flex-col items-center justify-center min-w-[50px] h-14 rounded-lg">
                <i data-lucide="dot" class="w-5 mb-1"></i>
                <span class="text-[8px] font-bold uppercase">Mid</span>
            </button>
            <button onclick="setTool('tangent')" id="btn-tangent" class="tool-btn flex flex-col items-center justify-center min-w-[50px] h-14 rounded-lg">
                <i data-lucide="circle-dot" class="w-5 mb-1 text-purple-600"></i>
                <span class="text-[8px] font-bold uppercase">Tangent</span>
            </button>
        </div>

        <div class="flex gap-1 px-2">
            <button onclick="setTool('dimension')" id="btn-dimension" class="tool-btn flex flex-col items-center justify-center min-w-[50px] h-14 rounded-lg">
                <i data-lucide="hash" class="w-5 mb-1 text-orange-600"></i>
                <span class="text-[8px] font-bold uppercase">Dim</span>
            </button>
        </div>

        <div class="ml-auto flex items-center gap-2 pr-4">
            <button onclick="undo()" class="p-2 hover:bg-slate-100 rounded-lg text-slate-400 transition-colors"><i data-lucide="undo-2" class="w-4"></i></button>
            <button onclick="clearCanvas()" class="p-2 hover:bg-red-50 rounded-lg text-slate-400 hover:text-red-500 transition-colors"><i data-lucide="trash-2" class="w-4"></i></button>
        </div>
    </div>

    <main class="flex-1 relative bg-slate-200 p-2 md:p-4 overflow-hidden">
        <div id="viewport-container" class="w-full h-full bg-white rounded-xl shadow-2xl border border-slate-300 relative overflow-hidden">
            <svg id="canvas-svg">
                <defs>
                    <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                        <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#F1F5F9" stroke-width="0.5"/>
                    </pattern>
                    <pattern id="grid-heavy" width="100" height="100" patternUnits="userSpaceOnUse">
                        <rect width="100" height="100" fill="url(#grid)" />
                        <path d="M 100 0 L 0 0 0 100" fill="none" stroke="#E2E8F0" stroke-width="1"/>
                    </pattern>
                </defs>
                <rect id="infinite-grid" width="100%" height="100%" fill="url(#grid-heavy)" />
                <g id="world-group">
                    <g id="origin-datum">
                        <circle r="5" fill="none" stroke="#64748B" stroke-width="1.5" />
                        <line x1="-10" y1="0" x2="10" y2="0" stroke="#64748B" stroke-width="1" />
                        <line x1="0" y1="-10" x2="0" y2="10" stroke="#64748B" stroke-width="1" />
                    </g>
                    <g id="shapes-layer"></g>
                    <g id="constraints-layer"></g>
                    <g id="preview-layer"></g>
                    <g id="snap-layer"></g>
                </g>
            </svg>
            <div id="floating-status" class="absolute top-4 right-4 bg-white/80 backdrop-blur border border-slate-200 px-3 py-1.5 rounded-lg shadow-sm pointer-events-none flex items-center gap-3">
                <span id="active-tool-badge" class="badge bg-slate-800 text-white">Select</span>
                <span id="selection-count" class="text-[9px] font-black text-slate-400 uppercase">Ready</span>
            </div>
            <input type="number" id="dim-input" class="dim-input hidden" step="1" />
        </div>
    </main>

    <footer class="bg-white border-t border-slate-200 px-4 py-1 flex justify-between items-center text-[10px] font-bold text-slate-400">
        <div class="flex gap-4 uppercase tracking-tighter">
            <span>Scroll to Zoom</span>
            <span>Middle Click / Space to Pan</span>
            <span>Esc to Reset Selection</span>
        </div>
        <div class="flex items-center gap-1 text-slate-500">
            <i data-lucide="layers" class="w-3"></i>
            <span id="stats-text">0 Objects | 0 Constraints</span>
        </div>
    </footer>

    <script>
        // --- CORE STATE ---
        let joints = new Map(); 
        let shapes = [];        
        let constraints = [];   
        let currentTool = 'select';
        let viewPan = { x: 0, y: 0 };
        let viewScale = 1;
        let dragTarget = null;
        let activeShape = null; 
        let selectionBuffer = [];
        let selectedConstraint = null; 
        let snapTarget = null;
        let jointIdCounter = 0;
        let dimensionPhase = 0;
        let activeDimTarget = null;

        const svg = document.getElementById('canvas-svg');
        const worldGroup = document.getElementById('world-group');
        const shapesLayer = document.getElementById('shapes-layer');
        const constraintsLayer = document.getElementById('constraints-layer');
        const previewLayer = document.getElementById('preview-layer');
        const snapLayer = document.getElementById('snap-layer');
        const dimInput = document.getElementById('dim-input');

        joints.set('origin', { x: 0, y: 0, fixed: true });

        function init() {
            lucide.createIcons();
            centerOrigin();
            window.addEventListener('resize', centerOrigin);
            window.addEventListener('keydown', handleKeyDown);
            dimInput.addEventListener('keydown', handleDimInputKey);
            svg.addEventListener('wheel', handleWheel, { passive: false });
            svg.onpointerdown = handlePointerDown;
            svg.onpointermove = handlePointerMove;
            svg.onpointerup = handlePointerUp;
            requestAnimationFrame(engineLoop);
        }

        function engineLoop() {
            solve();
            draw();
            requestAnimationFrame(engineLoop);
        }

        // --- SOLVER ENGINE ---
        function solve() {
            const iterations = 60;
            for (let i = 0; i < iterations; i++) {
                for (const c of constraints) {
                    const j1 = joints.get(c.joints[0]);
                    const j2 = joints.get(c.joints[1]);
                    if (!j1 || !j2) continue;

                    switch (c.type) {
                        case 'coincident': {
                            const mx = (j1.x + j2.x) / 2, my = (j1.y + j2.y) / 2;
                            if (!j1.fixed) { j1.x = mx; j1.y = my; }
                            if (!j2.fixed) { j2.x = mx; j2.y = my; }
                            break;
                        }
                        case 'horizontal': {
                            const my = (j1.y + j2.y) / 2;
                            if (!j1.fixed) j1.y = my;
                            if (!j2.fixed) j2.y = my;
                            break;
                        }
                        case 'vertical': {
                            const mx = (j1.x + j2.x) / 2;
                            if (!j1.fixed) j1.x = mx;
                            if (!j2.fixed) j2.x = mx;
                            break;
                        }
                        case 'distance': {
                            const dx = j2.x - j1.x, dy = j2.y - j1.y;
                            const cur = Math.hypot(dx, dy);
                            if (cur < 0.1) continue;
                            const diff = (cur - c.value) / cur;
                            const ox = dx * diff * 0.5, oy = dy * diff * 0.5;
                            if (!j1.fixed) { j1.x += ox; j1.y += oy; }
                            if (!j2.fixed) { j2.x -= ox; j2.y -= oy; }
                            break;
                        }
                        case 'parallel':
                        case 'perpendicular': {
                            const j3 = joints.get(c.joints[2]), j4 = joints.get(c.joints[3]);
                            if (!j3 || !j4) continue;
                            const dxRef = j2.x - j1.x, dyRef = j2.y - j1.y;
                            const angRef = Math.atan2(dyRef, dxRef);
                            
                            let targetAng = (c.type === 'parallel') ? angRef : angRef + Math.PI / 2;
                            
                            // Prevent Flip Logic for Parallel
                            if (c.type === 'parallel') {
                                const dxCur = j4.x - j3.x, dyCur = j4.y - j3.y;
                                // Dot product to see if they are roughly in the same direction or opposite
                                if (dxRef * dxCur + dyRef * dyCur < 0) {
                                    targetAng += Math.PI;
                                }
                            }

                            const len2 = Math.hypot(j4.x - j3.x, j4.y - j3.y);
                            const cx = (j3.x + j4.x) / 2, cy = (j3.y + j4.y) / 2;
                            if (!j3.fixed) { j3.x = cx - Math.cos(targetAng) * len2 * 0.5; j3.y = cy - Math.sin(targetAng) * len2 * 0.5; }
                            if (!j4.fixed) { j4.x = cx + Math.cos(targetAng) * len2 * 0.5; j4.y = cy + Math.sin(targetAng) * len2 * 0.5; }
                            break;
                        }
                        case 'midpoint': {
                            const j3 = joints.get(c.joints[2]);
                            if (!j3) continue;
                            const mx = (j1.x + j2.x) / 2, my = (j1.y + j2.y) / 2;
                            if (!j3.fixed) { j3.x = mx; j3.y = my; }
                            break;
                        }
                        case 'point-on-line': {
                            const j3 = joints.get(c.joints[2]);
                            if (!j3) continue;
                            const dx = j3.x - j2.x, dy = j3.y - j2.y;
                            const l2 = dx*dx + dy*dy;
                            if (l2 < 0.1) continue;
                            const t = ((j1.x - j2.x) * dx + (j1.y - j2.y) * dy) / l2;
                            const px = j2.x + t * dx, py = j2.y + t * dy;
                            if (!j1.fixed) { j1.x = px; j1.y = py; }
                            break;
                        }
                        case 'point-on-curve': {
                            const center = j2, radiusJoint = joints.get(c.joints[2]);
                            if (!radiusJoint) continue;
                            const r = Math.hypot(radiusJoint.x - center.x, radiusJoint.y - center.y);
                            const d = Math.hypot(j1.x - center.x, j1.y - center.y);
                            if (d < 0.1) continue;
                            const s = r / d;
                            if (!j1.fixed) { j1.x = center.x + (j1.x - center.x) * s; j1.y = center.y + (j1.y - center.y) * s; }
                            break;
                        }
                        case 'tangent': {
                            if (c.joints.length === 4) {
                                const j3 = joints.get(c.joints[2]), j4 = joints.get(c.joints[3]);
                                if (!j3 || !j4) continue;
                                const s1 = shapes.find(s => s.joints.includes(c.joints[0]) && s.joints.includes(c.joints[1]));
                                const s2 = shapes.find(s => s.joints.includes(c.joints[2]) && s.joints.includes(c.joints[3]));
                                if (s1?.type === 'circle' && s2?.type === 'circle') {
                                    const r1 = Math.hypot(j2.x - j1.x, j2.y - j1.y);
                                    const r2 = Math.hypot(j4.x - j3.x, j4.y - j3.y);
                                    const dist = Math.hypot(j3.x - j1.x, j3.y - j1.y);
                                    if (dist < 0.1) continue;
                                    const diff = (dist - (r1 + r2)) / dist;
                                    const ox = (j3.x - j1.x) * diff * 0.5, oy = (j3.y - j1.y) * diff * 0.5;
                                    if (!j1.fixed) { j1.x += ox; j1.y += oy; }
                                    if (!j3.fixed) { j3.x -= ox; j3.y -= oy; }
                                } else {
                                    const center = j1, radiusJoint = j2, l1 = j3, l2 = j4;
                                    const r = Math.hypot(radiusJoint.x - center.x, radiusJoint.y - center.y);
                                    const dx = l2.x - l1.x, dy = l2.y - l1.y, l_sq = dx*dx + dy*dy;
                                    if (l_sq < 0.1) continue;
                                    const t = ((center.x - l1.x) * dx + (center.y - l1.y) * dy) / l_sq;
                                    const px = l1.x + t * dx, py = l1.y + t * dy;
                                    const d = Math.hypot(center.x - px, center.y - py);
                                    if (d < 0.1) continue;
                                    const diff = (d - r) / d;
                                    const ox = (center.x - px) * diff, oy = (center.y - py) * diff;
                                    if (!center.fixed) { center.x -= ox; center.y -= oy; }
                                }
                            }
                            break;
                        }
                    }
                }
            }
        }

        function handlePointerDown(e) {
            const coords = getCoords(e);
            const cTarget = e.target.closest('.constraint-glyph');
            if (cTarget) {
                const idx = parseInt(cTarget.getAttribute('data-index'));
                selectedConstraint = constraints[idx];
                if (selectedConstraint?.type === 'distance') showDimInputAt(e.clientX, e.clientY, selectedConstraint.value);
                return;
            }
            selectedConstraint = null;
            dimInput.classList.add('hidden');
            const hit = findHit(coords);

            if (currentTool === 'select' || e.button === 1) {
                if (e.button === 1) dragTarget = { type: 'pan', start: { x: e.clientX, y: e.clientY }, initPan: { ...viewPan } };
                else if (hit?.type === 'joint') dragTarget = { type: 'joint', id: hit.id };
                else if (hit?.shape) {
                    const initJoints = new Map();
                    hit.shape.joints.forEach(id => initJoints.set(id, { ...joints.get(id) }));
                    dragTarget = { type: 'shape', shape: hit.shape, initJoints, startCoords: { ...coords } };
                } else dragTarget = { type: 'pan', start: { x: e.clientX, y: e.clientY }, initPan: { ...viewPan } };
                svg.setPointerCapture(e.pointerId);
            }
            else if (['line', 'rect', 'circle'].includes(currentTool)) {
                if (!activeShape) {
                    const startId = (hit?.type === 'joint') ? hit.id : genJointId();
                    if (!joints.has(startId)) joints.set(startId, { ...coords, fixed: false });
                    activeShape = { startId, temp: { ...coords } };
                } else {
                    const endId = (hit?.type === 'joint') ? hit.id : genJointId();
                    if (!joints.has(endId)) joints.set(endId, { ...coords, fixed: false });
                    if (currentTool === 'line') {
                        shapes.push({ type: 'line', joints: [activeShape.startId, endId] });
                        if (hit) activeShape = null; else activeShape = { startId: endId, temp: { ...coords } };
                    } else if (currentTool === 'circle') {
                        shapes.push({ type: 'circle', joints: [activeShape.startId, endId] });
                        activeShape = null;
                    } else if (currentTool === 'rect') {
                        const j1 = joints.get(activeShape.startId), j3 = joints.get(endId);
                        const j2Id = genJointId(), j4Id = genJointId();
                        joints.set(j2Id, { x: j3.x, y: j1.y, fixed: false }); joints.set(j4Id, { x: j1.x, y: j3.y, fixed: false });
                        const gid = 'rect_' + Date.now();
                        shapes.push({ type: 'line', joints: [activeShape.startId, j2Id], gid }, { type: 'line', joints: [j2Id, endId], gid }, { type: 'line', joints: [endId, j4Id], gid }, { type: 'line', joints: [j4Id, activeShape.startId], gid });
                        constraints.push({ type: 'horizontal', joints: [activeShape.startId, j2Id], gid }, { type: 'vertical', joints: [j2Id, endId], gid }, { type: 'horizontal', joints: [endId, j4Id], gid }, { type: 'vertical', joints: [j4Id, activeShape.startId], gid });
                        activeShape = null;
                    }
                }
            }
            else if (['coincident', 'hv', 'midpoint', 'tangent', 'parallel', 'perpend'].includes(currentTool)) {
                if (hit) {
                    if (!selectionBuffer.some(s => s.shape === hit.shape && s.id === hit.id)) selectionBuffer.push(hit);

                    if (currentTool === 'hv' && hit.shape?.type === 'line') {
                        const j = hit.shape.joints;
                        const j1 = joints.get(j[0]), j2 = joints.get(j[1]);
                        constraints.push({ type: Math.abs(j2.x - j1.x) > Math.abs(j2.y - j1.y) ? 'horizontal' : 'vertical', joints: [...j] });
                        selectionBuffer = []; // Persistence maintained: stay in HV tool
                    }
                    else if (selectionBuffer.length === 2) {
                        const h1 = selectionBuffer[0], h2 = selectionBuffer[1];
                        if (currentTool === 'coincident') {
                            if (h1.type === 'joint' && h2.type === 'joint') constraints.push({ type: 'coincident', joints: [h1.id, h2.id] });
                            else if (h1.type === 'joint' && h2.shape) constraints.push({ type: (h2.shape.type === 'line' ? 'point-on-line' : 'point-on-curve'), joints: [h1.id, ...h2.shape.joints] });
                            else if (h2.type === 'joint' && h1.shape) constraints.push({ type: (h1.shape.type === 'line' ? 'point-on-line' : 'point-on-curve'), joints: [h2.id, ...h1.shape.joints] });
                        } 
                        else if (currentTool === 'midpoint' && h1.shape?.type === 'line' && h2.type === 'joint') constraints.push({ type: 'midpoint', joints: [...h1.shape.joints, h2.id] });
                        else if (currentTool === 'tangent' && h1.shape && h2.shape) constraints.push({ type: 'tangent', joints: [...h1.shape.joints, ...h2.shape.joints] });
                        else if (['parallel', 'perpend'].includes(currentTool) && h1.shape?.type === 'line' && h2.shape?.type === 'line') {
                            constraints.push({ type: (currentTool === 'perpend' ? 'perpendicular' : 'parallel'), joints: [...h1.shape.joints, ...h2.shape.joints] });
                        }
                        selectionBuffer = []; // Persistence maintained: tool stays active
                    }
                }
            }
            else if (currentTool === 'dimension') {
                if (dimensionPhase === 0 && hit) {
                    if (hit.shape?.type === 'line') { activeDimTarget = { joints: [...hit.shape.joints] }; dimensionPhase = 1; }
                    else if (hit.type === 'joint') { selectionBuffer.push(hit.id); if (selectionBuffer.length === 2) { activeDimTarget = { joints: [...selectionBuffer] }; selectionBuffer = []; dimensionPhase = 1; } }
                } else if (dimensionPhase === 1) {
                    const j1 = joints.get(activeDimTarget.joints[0]), j2 = joints.get(activeDimTarget.joints[1]);
                    const val = Math.hypot(j2.x - j1.x, j2.y - j1.y);
                    const nc = { type: 'distance', joints: activeDimTarget.joints, value: val, offset: { x: coords.x, y: coords.y } };
                    constraints.push(nc); selectedConstraint = nc;
                    showDimInputAt(e.clientX, e.clientY, val.toFixed(0));
                    dimensionPhase = 0; activeDimTarget = null;
                }
            }
        }

        function handlePointerMove(e) {
            const raw = getCoords(e);
            let coords = raw;
            document.getElementById('coords-display').innerText = `X: ${coords.x} Y: ${coords.y}`;
            const exId = (dragTarget?.type === 'joint') ? dragTarget.id : null;
            snapTarget = findHit(coords, 12, exId);
            if (dragTarget) {
                if (snapTarget?.point) coords = snapTarget.point;
                if (dragTarget.type === 'joint') {
                    const j = joints.get(dragTarget.id);
                    if (j && !j.fixed) { j.x = coords.x; j.y = coords.y; }
                } else if (dragTarget.type === 'shape') {
                    const dx = coords.x - dragTarget.startCoords.x, dy = coords.y - dragTarget.startCoords.y;
                    dragTarget.shape.joints.forEach(id => {
                        const initJ = dragTarget.initJoints.get(id);
                        const j = joints.get(id);
                        if (j && !j.fixed) { j.x = initJ.x + dx; j.y = initJ.y + dy; }
                    });
                } else if (dragTarget.type === 'pan') {
                    viewPan.x = dragTarget.initPan.x + (e.clientX - dragTarget.start.x);
                    viewPan.y = dragTarget.initPan.y + (e.clientY - dragTarget.start.y);
                    updateViewport();
                }
            } else if (activeShape) {
                if (snapTarget?.point) coords = snapTarget.point;
                activeShape.temp = coords;
            }
        }

        function handlePointerUp() { dragTarget = null; }

        function draw() {
            document.getElementById('stats-text').innerText = `${shapes.length} Objects | ${constraints.length} Constraints`;
            document.getElementById('active-tool-badge').innerText = currentTool;
            document.getElementById('selection-count').innerText = selectionBuffer.length > 0 ? `Step ${selectionBuffer.length}/2` : 'Ready';

            let sHtml = '';
            for (const s of shapes) {
                const j1 = joints.get(s.joints[0]), j2 = joints.get(s.joints[1]);
                if (!j1 || !j2) continue;
                const isS = selectionBuffer.some(h => h.shape === s);
                const col = isS ? 'var(--accent)' : 'var(--primary)';
                const w = (isS ? 4.5 : 2.5) / viewScale;
                if (s.type === 'line') sHtml += `<line x1="${j1.x}" y1="${j1.y}" x2="${j2.x}" y2="${j2.y}" stroke="${col}" stroke-width="${w}" stroke-linecap="round" />`;
                else if (s.type === 'circle') sHtml += `<circle cx="${j1.x}" cy="${j1.y}" r="${Math.hypot(j2.x-j1.x, j2.y-j1.y)}" fill="none" stroke="${col}" stroke-width="${w}" />`;
            }
            for (const [id, j] of joints.entries()) {
                const isO = (id === 'origin'), isS = selectionBuffer.some(h => h.id === id);
                const fill = isO ? '#64748B' : 'white';
                const str = j.fixed ? (isO ? '#000' : '#64748B') : (isS ? 'var(--accent)' : 'var(--primary)');
                const r = (isO ? 5 : (isS ? 6 : 3.5)) / viewScale;
                sHtml += `<circle cx="${j.x}" cy="${j.y}" r="${r}" fill="${fill}" stroke="${str}" stroke-width="${1.5/viewScale}" />`;
            }
            shapesLayer.innerHTML = sHtml;

            let cHtml = '';
            constraints.forEach((c, idx) => {
                const j1 = joints.get(c.joints[0]), j2 = joints.get(c.joints[1]);
                if (!j1 || !j2) return;
                if (c.type === 'distance') {
                    const ox = c.offset.x, oy = c.offset.y, isS = (c === selectedConstraint);
                    cHtml += `<g class="constraint-glyph ${isS?'selected':''}" data-index="${idx}">
                        <line x1="${j1.x}" y1="${j1.y}" x2="${ox + (j1.x-(j1.x+j2.x)/2)}" y2="${oy + (j1.y-(j1.y+j2.y)/2)}" stroke="var(--accent)" stroke-width="${0.5/viewScale}" stroke-dasharray="${2/viewScale}" />
                        <line x1="${j2.x}" y1="${j2.y}" x2="${ox + (j2.x-(j1.x+j2.x)/2)}" y2="${oy + (j2.y-(j1.y+j2.y)/2)}" stroke="var(--accent)" stroke-width="${0.5/viewScale}" stroke-dasharray="${2/viewScale}" />
                        <rect x="${ox - 20/viewScale}" y="${oy - 9/viewScale}" width="${40/viewScale}" height="${18/viewScale}" rx="${3/viewScale}" />
                        <text x="${ox}" y="${oy + 4.5/viewScale}" font-size="${10/viewScale}" text-anchor="middle" font-weight="900" fill="var(--accent)" style="font-family:'JetBrains Mono'">${c.value.toFixed(0)}</text>
                    </g>`;
                    return;
                }
                const content = { horizontal: '-', vertical: '|', parallel: '//', perpendicular: '⊥', coincident: 'X', midpoint: '•', tangent: '○', 'point-on-curve': 'X', 'point-on-line': 'X' }[c.type];
                let mx = (j1.x + j2.x)/2, my = (j1.y + j2.y)/2;
                if (c.type === 'midpoint') { const j3 = joints.get(c.joints[2]); if (j3) { mx = j3.x; my = j3.y - 15/viewScale; } }
                else if (['point-on-line', 'point-on-curve'].includes(c.type)) { mx = j1.x + 10/viewScale; my = j1.y - 10/viewScale; }
                else if (c.type === 'tangent' && c.joints.length === 4) { const j3 = joints.get(c.joints[2]); mx = (j1.x + j3.x)/2; my = (j1.y + j3.y)/2 - 15/viewScale; }
                cHtml += `<g class="constraint-glyph ${c === selectedConstraint ? 'selected' : ''}" data-index="${idx}" transform="translate(${mx}, ${my}) scale(${1/viewScale})">
                    <rect x="-8" y="-18" width="16" height="15" rx="3" /><text font-size="9" text-anchor="middle" y="-7.5" font-weight="900" fill="${c.type === 'tangent' ? '#9333ea' : '#64748B'}">${content}</text>
                </g>`;
            });
            constraintsLayer.innerHTML = cHtml;

            if (activeShape) {
                const j1 = joints.get(activeShape.startId), t = activeShape.temp;
                let pHtml = '';
                const w = 2 / viewScale;
                if (currentTool === 'line') pHtml = `<line x1="${j1.x}" y1="${j1.y}" x2="${t.x}" y2="${t.y}" stroke="var(--primary)" stroke-width="${w}" stroke-dasharray="${4/viewScale}" />`;
                else if (currentTool === 'circle') pHtml = `<circle cx="${j1.x}" cy="${j1.y}" r="${Math.hypot(t.x-j1.x, t.y-j1.y)}" fill="none" stroke="var(--primary)" stroke-width="${w}" stroke-dasharray="${4/viewScale}" />`;
                else if (currentTool === 'rect') pHtml = `<rect x="${Math.min(j1.x, t.x)}" y="${Math.min(j1.y, t.y)}" width="${Math.abs(j1.x-t.x)}" height="${Math.abs(j1.y-t.y)}" fill="none" stroke="var(--primary)" stroke-width="${w}" stroke-dasharray="${4/viewScale}" />`;
                previewLayer.innerHTML = pHtml;
            } else previewLayer.innerHTML = '';
            if (snapTarget) {
                const p = snapTarget.point || joints.get(snapTarget.id);
                snapLayer.innerHTML = `<rect x="${p.x - 6/viewScale}" y="${p.y - 6/viewScale}" width="${12/viewScale}" height="${12/viewScale}" fill="none" stroke="var(--accent)" stroke-width="${2/viewScale}" />`;
            } else snapLayer.innerHTML = '';
        }

        function findHit(coords, threshold = 15, exId = null) {
            for (const [id, j] of joints.entries()) {
                if (id === exId) continue;
                if (Math.hypot(coords.x - j.x, coords.y - j.y) < threshold / viewScale) return { type: 'joint', id };
            }
            for (const s of shapes) {
                const j1 = joints.get(s.joints[0]), j2 = joints.get(s.joints[1]);
                if (s.type === 'line') {
                    const dx = j2.x-j1.x, dy = j2.y-j1.y, l2 = dx*dx + dy*dy;
                    const t = Math.max(0, Math.min(1, ((coords.x - j1.x) * dx + (coords.y - j1.y) * dy) / l2));
                    const px = j1.x + t*dx, py = j1.y + t*dy;
                    if (Math.hypot(coords.x - px, coords.y - py) < threshold / viewScale) return { type: 'line-snap', shape: s, point: { x: px, y: py } };
                } else if (s.type === 'circle') {
                    const r = Math.hypot(j2.x-j1.x, j2.y-j1.y), d = Math.hypot(coords.x-j1.x, coords.y-j1.y);
                    if (Math.abs(d - r) < threshold / viewScale) {
                        const scl = r / d; return { type: 'curve', shape: s, point: { x: j1.x + (coords.x-j1.x)*scl, y: j1.y + (coords.y-j1.y)*scl } };
                    }
                }
            }
            return null;
        }

        function setTool(t) {
            currentTool = t; selectionBuffer = []; dimensionPhase = 0; activeDimTarget = null; activeShape = null;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-' + t)?.classList.add('active');
            svg.classList.toggle('cursor-select', t === 'select');
            lucide.createIcons();
        }

        function getCoords(e) {
            const pt = svg.createSVGPoint(); pt.x = e.clientX; pt.y = e.clientY;
            const inv = pt.matrixTransform(worldGroup.getScreenCTM().inverse());
            return { x: Math.round(inv.x), y: Math.round(inv.y) };
        }

        function genJointId() { return 'j_' + (++jointIdCounter); }

        function handleWheel(e) {
            e.preventDefault();
            const factor = 1.1; const delta = e.deltaY > 0 ? 1 / factor : factor;
            const rect = svg.getBoundingClientRect();
            const mx = e.clientX - rect.left, my = e.clientY - rect.top;
            const pt = svg.createSVGPoint(); pt.x = e.clientX; pt.y = e.clientY;
            const wPt = pt.matrixTransform(worldGroup.getScreenCTM().inverse());
            viewScale = Math.max(0.1, Math.min(20, viewScale * delta));
            viewPan.x = mx - wPt.x * viewScale; viewPan.y = my - wPt.y * viewScale;
            updateViewport();
        }

        function handleKeyDown(e) {
            if (document.activeElement === dimInput) return;
            if (e.key === 'Escape') {
                if (selectionBuffer.length > 0) { selectionBuffer = []; return; }
                setTool('select');
                return;
            }
            const k = e.key.toLowerCase();
            if (k === 'l') setTool('line'); if (k === 'r') setTool('rect'); if (k === 'c') setTool('circle'); if (k === 'd') setTool('dimension');
            if (e.key === 'Delete' || e.key === 'Backspace') if (selectedConstraint) constraints = constraints.filter(c => c !== selectedConstraint);
        }

        function handleDimInputKey(e) { if (e.key === 'Enter') { const v = parseFloat(dimInput.value); if (!isNaN(v) && selectedConstraint) selectedConstraint.value = v; dimInput.classList.add('hidden'); svg.focus(); } }
        function centerOrigin() { const rect = svg.getBoundingClientRect(); viewPan.x = rect.width / 2; viewPan.y = rect.height / 2; updateViewport(); }
        function updateViewport() { worldGroup.setAttribute('transform', `translate(${viewPan.x}, ${viewPan.y}) scale(${viewScale})`); document.getElementById('grid-heavy').setAttribute('patternTransform', `translate(${viewPan.x}, ${viewPan.y}) scale(${viewScale})`); }
        function showDimInputAt(x, y, v) { dimInput.style.left = (x - 30) + 'px'; dimInput.style.top = (y - 15) + 'px'; dimInput.value = v; dimInput.classList.remove('hidden'); setTimeout(() => dimInput.focus(), 50); }
        function undo() { if (shapes.length > 0) shapes.pop(); }
        function clearCanvas() { joints.clear(); joints.set('origin', { x: 0, y: 0, fixed: true }); shapes = []; constraints = []; activeShape = null; jointIdCounter = 0; centerOrigin(); }

        init();
    </script>
</body>
</html>

