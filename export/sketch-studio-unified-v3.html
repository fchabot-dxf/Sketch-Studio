<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sketch Studio Unified</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --fusion-dark: #2C2C2C;
            --fusion-orange: #EA580C;
            --fusion-blue: #3B82F6;
        }
        body { font-family: 'Inter', sans-serif; touch-action: none; overflow: hidden; -webkit-user-select: none; user-select: none; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        .cursor-select { cursor: default; }
        .cursor-draw { cursor: crosshair; }
        .cursor-pan { cursor: grab; }
        .cursor-pan:active { cursor: grabbing; }

        .tool-btn {
            transition: all 0.15s;
            border: 1px solid transparent;
            min-width: 48px;
            min-height: 48px;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        .tool-btn:active {
            background-color: #e0e0e0;
            transform: scale(0.95);
        }
        @media (max-width: 640px) {
            .tool-btn {
                min-width: 44px;
                min-height: 44px;
                width: 44px;
                height: 44px !important;
            }
            .tool-btn span {
                font-size: 7px !important;
            }
            .tool-btn:active {
                transform: scale(0.92);
            }
        }
        .tool-btn:hover {
            background-color: #f0f0f0;
        }
        @media (hover: none) {
            .tool-btn:hover {
                background-color: transparent;
            }
        }
        .tool-btn.active {
            background-color: #3B82F6;
            color: white;
            border: 1px solid #1E40AF;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        .tool-btn.active:active {
            background-color: #2563eb;
        }
        .tool-btn.active span, .tool-btn.active i { color: white; }

        #svgCanvas { width: 100%; height: 100%; touch-action: none; background-color: #ffffff; transition: background-color 0.15s ease; }
        #svgCanvas.snapping { background-color: #fff7ed; }
        
        /* Prevent pinch-zoom but allow panning */
        @supports (touch-action: pan-x pan-y) {
            #svgCanvas {
                touch-action: pan-x pan-y;
            }
        }
        
        /* Tool dropdown */
        .tool-dropdown {
            position: relative;
        }
        .tool-dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            border: 1px solid #cbd5e1;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 9999;
            min-width: 100px;
        }
        .tool-dropdown-menu.show {
            display: block;
        }
        .tool-dropdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 600;
            white-space: nowrap;
            min-height: 40px;
        }
        @media (max-width: 640px) {
            .tool-dropdown-item {
                padding: 10px 14px;
                font-size: 11px;
            }
        }
        .tool-dropdown-item:hover,
        .tool-dropdown-item.hover {
            background: #e0e7ff;
        }
        .tool-dropdown-item.active {
            background: #3B82F6;
            color: white;
        }
        .tool-btn .dropdown-indicator {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 4px solid #94a3b8;
        }
        .tool-btn.active .dropdown-indicator {
            border-top-color: white;
        }
        
        .dim-input { 
            position: absolute; background: white; border: 2px solid var(--fusion-orange);
            border-radius: 4px; padding: 2px 4px; font-weight: bold; font-size: 11px;
            outline: none; text-align: center; z-index: 100; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        @media (max-width: 640px) {
            .dim-input {
                padding: 4px 6px;
                font-size: 14px;
                min-width: 70px;
                min-height: 36px;
                -webkit-appearance: none;
                appearance: none;
            }
            .dim-input::-webkit-outer-spin-button,
            .dim-input::-webkit-inner-spin-button {
                -webkit-appearance: none;
                margin: 0;
            }
            .dim-input[type=number] {
                -moz-appearance: textfield;
            }
        }
        .dim-input.hidden { display: none; }
    </style>
</head>
<body class="flex flex-col h-screen bg-[#F0F0F0] select-none text-xs">

    <!-- HEADER -->
    <header class="bg-[#2C2C2C] text-white px-4 py-2 flex justify-between items-center z-50 shadow-lg shrink-0 relative">
        <div class="flex items-center gap-4">
            <div class="bg-orange-600 p-1 rounded shadow-inner"><i data-lucide="maximize" class="w-4 h-4"></i></div>
            <span class="text-[11px] font-bold uppercase tracking-widest text-slate-200">Sketch Studio Unified</span>
        </div>
        <div class="flex items-center gap-4 text-[10px] font-bold text-slate-400">
            <span id="solver-status" class="text-green-500 uppercase">Solver Active</span>
        </div>
    </header>

    <!-- TOOLS RIBBON -->
    <div class="bg-white border-b border-slate-300 p-1 flex gap-1 z-40 overflow-x-auto no-scrollbar shadow-sm shrink-0 relative">
        <!-- EDIT -->
        <div class="flex flex-col items-center px-1 md:px-2 border-r border-slate-200 shrink-0">
            <div class="flex gap-0.5 flex-wrap md:flex-nowrap justify-center">
                <button id="btn-undo" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded" disabled>
                    <i data-lucide="undo-2" class="w-5 h-5 mb-0.5"></i>
                    <span class="text-[8px] font-medium uppercase">Undo</span>
                </button>
            </div>
            <span class="text-[7px] text-slate-400 uppercase mt-0.5">Edit</span>
        </div>

... (content continues) ...        :root {
            --fusion-dark: #2C2C2C;
            --fusion-orange: #EA580C;
            --fusion-blue: #3B82F6;
        }
        body { font-family: 'Inter', sans-serif; touch-action: none; overflow: hidden; -webkit-user-select: none; user-select: none; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        .cursor-select { cursor: default; }
        .cursor-draw { cursor: crosshair; }
        .cursor-pan { cursor: grab; }
        .cursor-pan:active { cursor: grabbing; }

        .tool-btn {
            transition: all 0.15s;
            border: 1px solid transparent;
            min-width: 48px;
            min-height: 48px;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        .tool-btn:active {
            background-color: #e0e0e0;
            transform: scale(0.95);
        }
        @media (max-width: 640px) {
            .tool-btn {
                min-width: 44px;
                min-height: 44px;
                width: 44px;
                height: 44px !important;
            }
            .tool-btn span {
                font-size: 7px !important;
            }
            .tool-btn:active {
                transform: scale(0.92);
            }
        }
        .tool-btn:hover {
            background-color: #f0f0f0;
        }
        @media (hover: none) {
            .tool-btn:hover {
                background-color: transparent;
            }
        }
        .tool-btn.active {
            background-color: #3B82F6;
            color: white;
            border: 1px solid #1E40AF;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        .tool-btn.active:active {
            background-color: #2563eb;
        }
        .tool-btn.active span, .tool-btn.active i { color: white; }

        #svgCanvas { width: 100%; height: 100%; touch-action: none; background-color: #ffffff; transition: background-color 0.15s ease; }
        #svgCanvas.snapping { background-color: #fff7ed; }
        
        /* Prevent pinch-zoom but allow panning */
        @supports (touch-action: pan-x pan-y) {
            #svgCanvas {
                touch-action: pan-x pan-y;
            }
        }
        
        /* Tool dropdown */
        .tool-dropdown {
            position: relative;
        }
        .tool-dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            border: 1px solid #cbd5e1;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 9999;
            min-width: 100px;
        }
        .tool-dropdown-menu.show {
            display: block;
        }
        .tool-dropdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 600;
            white-space: nowrap;
            min-height: 40px;
        }
        @media (max-width: 640px) {
            .tool-dropdown-item {
                padding: 10px 14px;
                font-size: 11px;
            }
        }
        .tool-dropdown-item:hover,
        .tool-dropdown-item.hover {
            background: #e0e7ff;
        }
        .tool-dropdown-item.active {
            background: #3B82F6;
            color: white;
        }
        .tool-btn .dropdown-indicator {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 4px solid #94a3b8;
        }
        .tool-btn.active .dropdown-indicator {
            border-top-color: white;
        }
        
        .dim-input { 
            position: absolute; background: white; border: 2px solid var(--fusion-orange);
            border-radius: 4px; padding: 2px 4px; font-weight: bold; font-size: 11px;
            outline: none; text-align: center; z-index: 100; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        @media (max-width: 640px) {
            .dim-input {
                padding: 4px 6px;
                font-size: 14px;
                min-width: 70px;
                min-height: 36px;
                -webkit-appearance: none;
                appearance: none;
            }
            .dim-input::-webkit-outer-spin-button,
            .dim-input::-webkit-inner-spin-button {
                -webkit-appearance: none;
                margin: 0;
            }
            .dim-input[type=number] {
                -moz-appearance: textfield;
            }
        }
        .dim-input.hidden { display: none; }
    </style>
</head>
<body class="flex flex-col h-screen bg-[#F0F0F0] select-none text-xs">

    <!-- HEADER -->
    <header class="bg-[#2C2C2C] text-white px-4 py-2 flex justify-between items-center z-50 shadow-lg shrink-0 relative">
        <div class="flex items-center gap-4">
            <div class="bg-orange-600 p-1 rounded shadow-inner"><i data-lucide="maximize" class="w-4 h-4"></i></div>
            <span class="text-[11px] font-bold uppercase tracking-widest text-slate-200">Sketch Studio Unified</span>
        </div>
        <div class="flex items-center gap-4 text-[10px] font-bold text-slate-400">
            <span id="solver-status" class="text-green-500 uppercase">Solver Active</span>
        </div>
    </header>

    <!-- TOOLS RIBBON -->
    <div class="bg-white border-b border-slate-300 p-1 flex gap-1 z-40 overflow-x-auto no-scrollbar shadow-sm shrink-0 relative">
        <!-- EDIT -->
        <div class="flex flex-col items-center px-1 md:px-2 border-r border-slate-200 shrink-0">
            <div class="flex gap-0.5 flex-wrap md:flex-nowrap justify-center">
                <button id="btn-undo" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded" disabled>
                    <i data-lucide="undo-2" class="w-5 h-5 mb-0.5"></i>
                    <span class="text-[8px] font-medium uppercase">Undo</span>
                </button>
            </div>
            <span class="text-[7px] text-slate-400 uppercase mt-0.5">Edit</span>
        </div>
        <!-- CREATE -->
        <div class="flex flex-col items-center px-1 md:px-2 border-r border-slate-200 shrink-0">
            <div class="flex gap-0.5 flex-wrap md:flex-nowrap justify-center">
                <button id="tool-select" class="tool-btn active flex flex-col items-center justify-center w-12 h-14 md:w-12 md:h-14 rounded">
                    <i data-lucide="mouse-pointer-2" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Select</span>
                </button>
                <button id="tool-line" class="tool-btn flex flex-col items-center justify-center w-12 h-14 md:w-12 md:h-14 rounded">
                    <i data-lucide="minus" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Line</span>
                </button>
                <div class="tool-dropdown">
                    <button id="tool-rect" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded relative">
                        <svg id="rect-icon" class="w-[18px] h-[18px]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <!-- 2-point mode icon (default) -->
                            <rect x="4" y="4" width="16" height="16"/>
                            <circle cx="4" cy="4" r="2" fill="currentColor" class="rect-icon-dot rect-icon-2pt"/>
                            <circle cx="20" cy="20" r="2" fill="currentColor" class="rect-icon-dot rect-icon-2pt"/>
                            <!-- center mode dots -->
                            <circle cx="12" cy="12" r="2" fill="currentColor" class="rect-icon-dot rect-icon-center" style="display:none"/>
                            <circle cx="20" cy="20" r="2" fill="currentColor" class="rect-icon-dot rect-icon-center" style="display:none"/>
                            <!-- 3-point mode dots -->
                            <circle cx="4" cy="4" r="2" fill="currentColor" class="rect-icon-dot rect-icon-3pt" style="display:none"/>
                            <circle cx="20" cy="4" r="2" fill="currentColor" class="rect-icon-dot rect-icon-3pt" style="display:none"/>
                            <circle cx="20" cy="20" r="2" fill="currentColor" class="rect-icon-dot rect-icon-3pt" style="display:none"/>
                        </svg>
                        <span id="rect-label" class="text-[8px] font-black uppercase mt-1">Rect</span>
                        <span class="dropdown-indicator"></span>
                    </button>
                    <div id="rect-dropdown" class="tool-dropdown-menu">
                        <div class="tool-dropdown-item active" data-mode="rect-2pt">
                            <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="16" height="16"/><circle cx="4" cy="4" r="2" fill="currentColor"/><circle cx="20" cy="20" r="2" fill="currentColor"/></svg>
                            2-Point (Corner)
                        </div>
                        <div class="tool-dropdown-item" data-mode="rect-center">
                            <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="16" height="16"/><circle cx="12" cy="12" r="2" fill="currentColor"/><circle cx="20" cy="20" r="2" fill="currentColor"/></svg>
                            Center Point
                        </div>
                        <div class="tool-dropdown-item" data-mode="rect-3pt">
                            <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="16" height="16"/><circle cx="4" cy="4" r="2" fill="currentColor"/><circle cx="20" cy="4" r="2" fill="currentColor"/><circle cx="20" cy="20" r="2" fill="currentColor"/></svg>
                            3-Point
                        </div>
                    </div>
                </div>
                <button id="tool-circle" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded">
                    <i data-lucide="circle" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Circle</span>
                </button>
            </div>
            <span class="text-[8px] font-black uppercase text-slate-300 mt-1">Create</span>
        </div>

        <!-- CONSTRAIN -->
        <div class="flex flex-col items-center px-2 border-r border-slate-200">
            <div class="flex gap-0.5">
                <button id="tool-coincident" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded">
                    <svg class="w-[18px] h-[18px]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                        <line x1="6" y1="6" x2="18" y2="18"/><line x1="18" y1="6" x2="6" y2="18"/>
                    </svg>
                    <span class="text-[8px] font-black uppercase mt-1">Coinc</span>
                </button>
                <button id="tool-hv" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded">
                    <svg class="w-[18px] h-[18px]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                        <line x1="4" y1="12" x2="20" y2="12"/><line x1="12" y1="4" x2="12" y2="20"/>
                    </svg>
                    <span class="text-[8px] font-black uppercase mt-1">H/V</span>
                </button>
                <button id="tool-parallel" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded">
                    <svg class="w-[18px] h-[18px]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                        <line x1="4" y1="20" x2="20" y2="4"/><line x1="8" y1="20" x2="24" y2="4"/>
                    </svg>
                    <span class="text-[8px] font-black uppercase mt-1">Para</span>
                </button>
                <button id="tool-perp" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded">
                    <svg class="w-[18px] h-[18px]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                        <line x1="4" y1="20" x2="20" y2="20"/><line x1="12" y1="20" x2="12" y2="4"/>
                    </svg>
                    <span class="text-[8px] font-black uppercase mt-1">Perp</span>
                </button>
                <button id="tool-collinear" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded">
                    <svg class="w-[18px] h-[18px]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                        <line x1="2" y1="12" x2="22" y2="12"/>
                        <circle cx="6" cy="12" r="2" fill="currentColor"/>
                        <circle cx="12" cy="12" r="2" fill="currentColor"/>
                        <circle cx="18" cy="12" r="2" fill="currentColor"/>
                    </svg>
                    <span class="text-[8px] font-black uppercase mt-1">Coll</span>
                </button>
                <button id="tool-tangent" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded">
                    <svg class="w-[18px] h-[18px]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                        <circle cx="12" cy="12" r="8"/>
                        <line x1="2" y1="12" x2="12" y2="12"/>
                    </svg>
                    <span class="text-[8px] font-black uppercase mt-1">Tang</span>
                </button>
            </div>
            <span class="text-[8px] font-black uppercase text-slate-300 mt-1">Constrain</span>
        </div>

        <!-- INSPECT -->
        <div class="flex flex-col items-center px-2 border-r border-slate-200">
            <div class="flex gap-0.5">
                <button id="tool-dim" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded">
                    <i data-lucide="hash" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Dim</span>
                </button>
            </div>
            <span class="text-[8px] font-black uppercase text-slate-300 mt-1">Inspect</span>
        </div>

        <!-- ACTIONS -->
        <div class="ml-auto flex items-center gap-2 pr-4 shrink-0">
            <button id="btn-undo" class="p-2 hover:bg-slate-100 rounded text-slate-400" title="Undo"><i data-lucide="undo-2" class="w-4"></i></button>
            <button id="btn-clear" class="p-2 hover:bg-red-50 rounded text-slate-400 hover:text-red-500" title="Clear All"><i data-lucide="trash-2" class="w-4"></i></button>
        </div>
    </div>

    <!-- MAIN VIEWPORT -->
    <main class="flex-1 relative bg-[#DBDBDB] flex flex-col overflow-hidden p-2 md:p-4">
        <div class="flex-1 bg-white rounded shadow-inner border border-slate-300 relative overflow-hidden">
            <svg id="svgCanvas" preserveAspectRatio="xMidYMid slice">
                <defs>
                    <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                        <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#F1F5F9" stroke-width="0.5"/>
                    </pattern>
                    <pattern id="grid-heavy" width="100" height="100" patternUnits="userSpaceOnUse">
                        <rect width="100" height="100" fill="url(#grid)" />
                        <path d="M 100 0 L 0 0 0 100" fill="none" stroke="#E2E8F0" stroke-width="1"/>
                    </pattern>
                </defs>
                <rect id="infinite-grid" width="100%" height="100%" fill="url(#grid-heavy)" />
                <g id="world-group">
                    <g id="origin-datum">
                        <circle r="4" fill="none" stroke="#64748B" stroke-width="1.5" />
                        <line x1="-8" y1="0" x2="8" y2="0" stroke="#64748B" stroke-width="1" />
                        <line x1="0" y1="-8" x2="0" y2="8" stroke="#64748B" stroke-width="1" />
                    </g>
                </g>
            </svg>
            <input type="number" id="dimInput" class="dim-input hidden" step="0.1" inputmode="decimal" autocomplete="off" />
            <div id="constraintTooltip" class="constraint-tooltip hidden">Press Delete to remove constraint</div>
        </div>
    </main>

    <!-- FOOTER -->
    <footer class="bg-slate-100 border-t border-slate-300 px-4 py-1.5 flex justify-between items-center text-[10px] font-bold text-slate-400 uppercase tracking-tighter shrink-0">
        <div class="flex gap-4"><span id="modeText">MODE: SELECT</span></div>
        <div><span id="coords-text">X: 0 Y: 0</span></div>
    </footer>

    <div id="debugOverlay" class="debug-overlay" style="position:fixed;right:12px;bottom:12px;background:rgba(0,0,0,0.8);color:#fff;padding:8px 10px;border-radius:6px;font-size:11px;line-height:1.2;white-space:pre;z-index:99999;max-width:320px;max-height:200px;overflow:auto"></div>
    <script>lucide.createIcons();</script>
    <script>
        // Prevent iOS default gesture behaviors that might interfere
        document.addEventListener('gesturestart', (e) => {
            e.preventDefault();
        }, { passive: false });
        
        // Prevent unwanted page zoom on double-tap (iOS)
        document.addEventListener('dblclick', (e) => {
            if(e.target.id === 'svgCanvas') {
                e.preventDefault();
            }
        }, { passive: false });
    </script>

    <!-- INLINED SCRIPTS -->
    <script>
// ---- 1-utils.js (inlined) ----

// NOTE: exports removed and imports resolved for standalone use
function getConstrainedGeometry(constraint, shapes) {
  const constraintJoints = new Set();
  const constraintShapes = new Set();
  if (!constraint) return { joints: constraintJoints, shapes: constraintShapes };
  if (constraint.type === 'coincident' && constraint.joints) {
    for (const jid of constraint.joints) constraintJoints.add(jid);
    for (const s of shapes) {
      if (s.joints && s.joints.some(jid => constraintJoints.has(jid))) {
        constraintShapes.add(s.id);
      }
    }
  } else if ((constraint.type === 'horizontal' || constraint.type === 'vertical') && constraint.joints) {
    for (const jid of constraint.joints) constraintJoints.add(jid);
    for (const s of shapes) {
      if (s.joints && s.joints.some(jid => constraintJoints.has(jid))) {
        constraintShapes.add(s.id);
      }
    }
  } else if ((constraint.type === 'parallel' || constraint.type === 'perpendicular') && constraint.shapes) {
    for (const sid of constraint.shapes) constraintShapes.add(sid);
  } else if (constraint.type === 'collinear' && constraint.joints) {
    for (const jid of constraint.joints) constraintJoints.add(jid);
    for (const s of shapes) {
      if (s.joints && s.joints.some(jid => constraintJoints.has(jid))) {
        constraintShapes.add(s.id);
      }
    }
  } else if (constraint.type === 'tangent') {
    if (constraint.line) constraintShapes.add(constraint.line);
    if (constraint.circle) constraintShapes.add(constraint.circle);
  } else if (constraint.type === 'pointOnLine') {
    if (constraint.joint) constraintJoints.add(constraint.joint);
    if (constraint.shape) constraintShapes.add(constraint.shape);
  } else if (constraint.type === 'distance' && constraint.joints) {
    for (const jid of constraint.joints) constraintJoints.add(jid);
    for (const s of shapes) {
      if (s.joints && s.joints.some(jid => constraintJoints.has(jid))) {
        constraintShapes.add(s.id);
      }
    }
  }
  return { joints: constraintJoints, shapes: constraintShapes };
}

// Constants
const SNAP_PX = 50; // Joint snap tolerance for general selection (pixels) - increased for touch
const INFERENCE_SNAP_PX = 15; // Joint snap tolerance for inference hints (pixels) - more restrictive
const LINE_SNAP_PX = 20; // Line snap tolerance (pixels)
const DEFAULT_VIEW = { x:0, y:0, w:1200, h:800 };

// CONSTRAINT COLORS
const CONSTRAINT_COLORS = {
  coincident:    { fill: '#ef4444', stroke: '#dc2626' },
  horizontal:    { fill: '#22c55e', stroke: '#15803d' },
  vertical:      { fill: '#22c55e', stroke: '#0369a1' },
  parallel:      { fill: '#3b82f6', stroke: '#ca8a04' },
  perpendicular: { fill: '#a855f7', stroke: '#7c3aed' },
  collinear:     { fill: '#14b8a6', stroke: '#0d9488' },
  tangent:       { fill: '#fbbf24', stroke: '#ca8a04' },
  pointOnLine:   { fill: '#fb923c', stroke: '#ea580c' },
  distance:      { fill: '#9ca3af', stroke: '#2563eb' },
};

function createConstraint(type, params) {
  switch(type) {
    case 'coincident':
      if (!params.joints || params.joints.length < 2) return null;
      if (params.joints[0] === params.joints[1]) return null;
      return { type: 'coincident', joints: params.joints };
    case 'pointOnLine':
      if (!params.joint || !params.shape) return null;
      return { type: 'pointOnLine', joint: params.joint, shape: params.shape };
    case 'horizontal':
    case 'vertical':
      if (!params.joints || params.joints.length < 2) return null;
      return { type, joints: params.joints.slice() };
    case 'parallel':
    case 'perpendicular':
      if (!params.shapes || params.shapes.length < 2) return null;
      return { type, shapes: params.shapes };
    case 'collinear':
      if (!params.joints || params.joints.length < 3) return null;
      return { type: 'collinear', joints: params.joints.slice() };
    case 'tangent':
      if (!params.line || !params.circle) return null;
      return { type: 'tangent', line: params.line, circle: params.circle };
    case 'distance':
      if (!params.joints || params.joints.length < 2) return null;
      return { 
        type: 'distance', 
        joints: params.joints, 
        value: params.value,
        offset: params.offset || 30,
        isRadius: params.isRadius || false
      };
    default:
      console.warn('Unknown constraint type:', type);
      return null;
  }
}

function hasConstraint(constraints, type, params) {
  for (const c of constraints) {
    if (c.type !== type) continue;
    switch(type) {
      case 'coincident':
        if (c.joints && params.joints) {
          const [a, b] = c.joints;
          const [x, y] = params.joints;
          if ((a === x && b === y) || (a === y && b === x)) return true;
        }
        break;
      case 'pointOnLine':
        if (c.joint === params.joint && c.shape === params.shape) return true;
        break;
      case 'horizontal':
      case 'vertical':
        if (c.joints && params.joints) {
          const cSet = new Set(c.joints);
          if (params.joints.every(j => cSet.has(j)) && params.joints.length === c.joints.length) return true;
        }
        break;
      case 'parallel':
      case 'perpendicular':
        if (c.shapes && params.shapes) {
          const [a, b] = c.shapes;
          const [x, y] = params.shapes;
          if ((a === x && b === y) || (a === y && b === x)) return true;
        }
        break;
      case 'tangent':
        if (c.line === params.line && c.circle === params.circle) return true;
        break;
    }
  }
  return false;
}

function addConstraint(state, type, params) {
  if (params && params.__isPreview) {
    console.log('[addConstraint] Ignoring preview constraint:', type, params);
    return false;
  }
  if (hasConstraint(state.constraints, type, params)) {
    console.log('[addConstraint] Duplicate constraint rejected:', type, params);
    return false;
  }
  const constraint = createConstraint(type, params);
  if (!constraint) {
    console.warn('[addConstraint] Invalid constraint:', type, params);
    return false;
  }
  console.log('[addConstraint] Adding constraint:', constraint);
  state.constraints.push(constraint);
  return true;
}

function getDist(p1,p2){ return Math.hypot((p1.x-p2.x),(p1.y-p2.y)); }
function projectPointOnSegment(pt,a,b){ const dx=b.x-a.x, dy=b.y-a.y; const L2=dx*dx+dy*dy; if(L2===0) return {x:a.x,y:a.y}; let t=((pt.x-a.x)*dx + (pt.y-a.y)*dy)/L2; t=Math.max(0,Math.min(1,t)); return {x:a.x + t*dx, y: a.y + t*dy}; }
function projectPointOnLine(pt,a,b){ const dx=b.x-a.x, dy=b.y-a.y; const L2=dx*dx+dy*dy; if(L2===0) return {x:a.x,y:a.y}; const t=((pt.x-a.x)*dx + (pt.y-a.y)*dy)/L2; return {x:a.x + t*dx, y: a.y + t*dy}; }

function screenToWorld(svg, screenX, screenY){ 
  const rect = svg.getBoundingClientRect();
  const vb = svg.viewBox.baseVal; 
  const scaleX = vb.width / rect.width;
  const scaleY = vb.height / rect.height;
  const localX = screenX - rect.left;
  const localY = screenY - rect.top;
  return { x: vb.x + localX * scaleX, y: vb.y + localY * scaleY }; 
}
function worldToScreen(svg, pt){ 
  const rect = svg.getBoundingClientRect();
  const vb = svg.viewBox.baseVal; 
  const scaleX = rect.width / vb.width;
  const scaleY = rect.height / vb.height;
  const localX = (pt.x - vb.x) * scaleX;
  const localY = (pt.y - vb.y) * scaleY;
  return { x: rect.left + localX, y: rect.top + localY }; 
}

function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

// Rectangle helpers
function makeRectFromTwoJoints(joints, j1Id, j3Id, genJ){
	const j1 = joints.get(j1Id), j3 = joints.get(j3Id); if(!j1||!j3) return { shapes: [], constraints: [] };
	const j2Id = genJ(), j4Id = genJ();
	joints.set(j2Id, { x: j3.x, y: j1.y, fixed:false });
	joints.set(j4Id, { x: j1.x, y: j3.y, fixed:false });
	const gid = 'rect_' + Date.now();
	const shapes = [
		{ id: 's'+Date.now()+'_1', type:'line', joints:[j1Id,j2Id], groupId:gid },
		{ id: 's'+Date.now()+'_2', type:'line', joints:[j2Id,j3Id], groupId:gid },
		{ id: 's'+Date.now()+'_3', type:'line', joints:[j3Id,j4Id], groupId:gid },
		{ id: 's'+Date.now()+'_4', type:'line', joints:[j4Id,j1Id], groupId:gid }
	];
	const constraints = [
		{ type: 'horizontal', joints: [j1Id, j2Id] },
		{ type: 'vertical', joints: [j2Id, j3Id] },
		{ type: 'horizontal', joints: [j3Id, j4Id] },
		{ type: 'vertical', joints: [j4Id, j1Id] }
	];
	return { shapes, constraints };
}
function makeRectFromCenter(joints, centerId, cornerId, genJ){
	const center = joints.get(centerId), corner = joints.get(cornerId); if(!center||!corner) return [];
	const dx = corner.x - center.x, dy = corner.y - center.y;
	const j1Id = genJ(), j2Id = genJ(), j3Id = genJ(), j4Id = genJ();
	joints.set(j1Id, { x: center.x - dx, y: center.y - dy, fixed:false });
	joints.set(j2Id, { x: center.x + dx, y: center.y - dy, fixed:false });
	joints.set(j3Id, { x: center.x + dx, y: center.y + dy, fixed:false });
	joints.set(j4Id, { x: center.x - dx, y: center.y + dy, fixed:false });
	joints.delete(cornerId);
	const gid = 'rect_' + Date.now();
	return [ { id: 's'+Date.now()+'_1', type:'line', joints:[j1Id,j2Id], groupId:gid }, { id: 's'+Date.now()+'_2', type:'line', joints:[j2Id,j3Id], groupId:gid }, { id: 's'+Date.now()+'_3', type:'line', joints:[j3Id,j4Id], groupId:gid }, { id: 's'+Date.now()+'_4', type:'line', joints:[j4Id,j1Id], groupId:gid } ];
}
function makeRectFrom3Points(joints, j1Id, j2Id, j3Id, genJ){
	const j1 = joints.get(j1Id), j2 = joints.get(j2Id), j3 = joints.get(j3Id); if(!j1||!j2||!j3) return [];
	const dx = j2.x - j1.x, dy = j2.y - j1.y;
	const len = Math.hypot(dx, dy); if(len < 0.001) return [];
	const px = -dy/len, py = dx/len;
	const h = (j3.x - j1.x) * px + (j3.y - j1.y) * py;
	const j4Id = genJ();
	joints.set(j4Id, { x: j1.x + px * h, y: j1.y + py * h, fixed:false });
	j3.x = j2.x + px * h;
	j3.y = j2.y + py * h;
	const gid = 'rect_' + Date.now();
	return [ { id: 's'+Date.now()+'_1', type:'line', joints:[j1Id,j2Id], groupId:gid }, { id: 's'+Date.now()+'_2', type:'line', joints:[j2Id,j3Id], groupId:gid }, { id: 's'+Date.now()+'_3', type:'line', joints:[j3Id,j4Id], groupId:gid }, { id: 's'+Date.now()+'_4', type:'line', joints:[j4Id,j1Id], groupId:gid } ];
}


// ---- 2-solver.js (inlined) ----
function solveConstraints(joints, shapes, constraints, iter=20){
  for(let k=0;k<iter;k++){
    for(const c of constraints){
      if(c.type==='coincident'){
        const a=joints.get(c.joints[0]), b=joints.get(c.joints[1]); if(!a||!b) continue;
        const mx=(a.x+b.x)/2, my=(a.y+b.y)/2; if(!a.fixed){ a.x=mx; a.y=my; } if(!b.fixed){ b.x=mx; b.y=my; }
      }
      else if(c.type==='horizontal'){
        const a=joints.get(c.joints[0]), b=joints.get(c.joints[1]); if(!a||!b) continue; const my=(a.y+b.y)/2; if(!a.fixed) a.y=my; if(!b.fixed) b.y=my;
      }
      else if(c.type==='vertical'){
        const a=joints.get(c.joints[0]), b=joints.get(c.joints[1]); if(!a||!b) continue; const mx=(a.x+b.x)/2; if(!a.fixed) a.x=mx; if(!b.fixed) b.x=mx;
      }
      else if(c.type==='distance'){
        const a=joints.get(c.joints[0]), b=joints.get(c.joints[1]); if(!a||!b) continue; const dx=b.x-a.x, dy=b.y-a.y; let d=Math.hypot(dx,dy); if(d<1e-6) continue; const target=c.value; const err=(d-target)/d*0.5; if(!a.fixed){ a.x+=dx*err; a.y+=dy*err; } if(!b.fixed){ b.x-=dx*err; b.y-=dy*err; }
      }
      else if(c.type==='parallel' || c.type==='perpendicular'){
        let a, b, p, q;
        if(c.shapes && c.shapes.length >= 2){
          const s1 = shapes.find(s => s.id === c.shapes[0]);
          const s2 = shapes.find(s => s.id === c.shapes[1]);
          if(!s1 || !s2 || !s1.joints || !s2.joints || s1.joints.length < 2 || s2.joints.length < 2) continue;
          a = joints.get(s1.joints[0]);
          b = joints.get(s1.joints[1]);
          p = joints.get(s2.joints[0]);
          q = joints.get(s2.joints[1]);
        } else if(c.joints && c.joints.length >= 4){
          a = joints.get(c.joints[0]);
          b = joints.get(c.joints[1]);
          p = joints.get(c.joints[2]);
          q = joints.get(c.joints[3]);
        } else {
          continue;
        }
        if(!a||!b||!p||!q) continue;
        const refAng=Math.atan2(b.y-a.y,b.x-a.x);
        let targetAng;
        if(c.type==='parallel'){
          targetAng = refAng;
        } else {
          const currentAng = Math.atan2(q.y-p.y, q.x-p.x);
          const option1 = refAng + Math.PI/2;
          const option2 = refAng - Math.PI/2;
          const diff1 = Math.atan2(Math.sin(option1 - currentAng), Math.cos(option1 - currentAng));
          const diff2 = Math.atan2(Math.sin(option2 - currentAng), Math.cos(option2 - currentAng));
          targetAng = Math.abs(diff1) < Math.abs(diff2) ? option1 : option2;
        }
        const len=Math.hypot(q.x-p.x,q.y-p.y)||1; const cx=(p.x+q.x)/2, cy=(p.y+q.y)/2; if(!p.fixed){ p.x = cx - Math.cos(targetAng)*len*0.5; p.y = cy - Math.sin(targetAng)*len*0.5; } if(!q.fixed){ q.x = cx + Math.cos(targetAng)*len*0.5; q.y = cy + Math.sin(targetAng)*len*0.5; }
      }
      else if(c.type==='pointOnLine'){
        const shape = shapes.find(s => s.id === c.shape);
        if(!shape || !shape.joints || shape.joints.length < 2) continue;
        const pt = joints.get(c.joint);
        const a = joints.get(shape.joints[0]), b = joints.get(shape.joints[1]);
        if(!pt || !a || !b) continue;
        if(pt.fixed) continue;
        const proj = projectPointOnSegment(pt, a, b);
        pt.x = pt.x + (proj.x - pt.x) * 0.5;
        pt.y = pt.y + (proj.y - pt.y) * 0.5;
      }
      else if(c.type==='collinear'){
        if(!c.joints || c.joints.length < 3) continue;
        const pts = c.joints.map(id => joints.get(id)).filter(j => j);
        if(pts.length < 3) continue;
        const p0 = pts[0], p1 = pts[1];
        const dx = p1.x - p0.x, dy = p1.y - p0.y;
        const len = Math.hypot(dx, dy);
        if(len < 1e-6) continue;
        for(let i = 2; i < pts.length; i++){
          const pt = pts[i];
          if(pt.fixed) continue;
          const proj = projectPointOnLine(pt, p0, p1);
          pt.x = pt.x + (proj.x - pt.x) * 0.5;
          pt.y = pt.y + (proj.y - pt.y) * 0.5;
        }
      }
      else if(c.type==='tangent'){
        if(!c.line || !c.circle) continue;
        const lineShape = shapes.find(s => s.id === c.line);
        const circleShape = shapes.find(s => s.id === c.circle);
        if(!lineShape || !circleShape || lineShape.type !== 'line' || circleShape.type !== 'circle') continue;
        const a = joints.get(lineShape.joints[0]);
        const b = joints.get(lineShape.joints[1]);
        const center = joints.get(circleShape.joints[0]);
        const radiusPt = joints.get(circleShape.joints[1]);
        if(!a || !b || !center || !radiusPt) continue;
        const radius = getDist(center, radiusPt);
        const proj = projectPointOnSegment(center, a, b);
        const dist = getDist(center, proj);
        const error = dist - radius;
        if(Math.abs(error) > 1e-3){
          const dx = b.x - a.x, dy = b.y - a.y;
          const lineLen = Math.hypot(dx, dy);
          if(lineLen < 1e-6) continue;
          const nx = -dy / lineLen, ny = dx / lineLen;
          const adjust = error * 0.5;
          if(!a.fixed){ a.x += nx * adjust; a.y += ny * adjust; }
          if(!b.fixed){ b.x += nx * adjust; b.y += ny * adjust; }
        }
      }
    }
  }
}

// ---- 3-snap.js (inlined) ----
function hitJointAtScreen(joints, svg, screenX, screenY, threshold=14){
  let best=null, bestD=threshold;
  for(const [id,j] of joints.entries()){ const s = worldToScreen(svg, j); const d = Math.hypot(s.x - screenX, s.y - screenY); if(d < bestD){ bestD = d; best = { id, j }; } }
  return best;
}
function hitLineAtScreen(joints, shapes, svg, screenX, screenY, threshold=8){
  const w = screenToWorld(svg, screenX, screenY);
  let best = null, bestD = threshold;
  for(const s of shapes){
    if(s.type === 'line'){
      const a = joints.get(s.joints[0]), b = joints.get(s.joints[1]);
      if(!a || !b) continue;
      const proj = projectPointOnSegment(w, a, b);
      const sc = worldToScreen(svg, proj);
      const d = Math.hypot(sc.x - screenX, sc.y - screenY);
      if(d < bestD){ bestD = d; best = { shape: s, pt: proj }; }
    }
  }
  return best;
}
function hitCircleAtScreen(joints, shapes, svg, screenX, screenY, threshold=10){
  const w = screenToWorld(svg, screenX, screenY);
  let best = null, bestD = threshold;
  for(const s of shapes){
    if(s.type === 'circle'){
      const center = joints.get(s.joints[0]);
      const edge = joints.get(s.joints[1]);
      if(!center || !edge) continue;
      const radius = Math.hypot(edge.x - center.x, edge.y - center.y);
      if(radius <= 1e-6) continue;
      const vx = w.x - center.x, vy = w.y - center.y;
      const vlen = Math.hypot(vx, vy);
      const onCirc = vlen > 0 ? { x: center.x + vx * (radius / vlen), y: center.y + vy * (radius / vlen) } : { x: center.x + radius, y: center.y };
      const sc = worldToScreen(svg, onCirc);
      const d = Math.hypot(sc.x - screenX, sc.y - screenY);
      if(d < bestD){ bestD = d; best = { shape: s, pt: onCirc }; }
    }
  }
  return best;
}
function findCoincidentCluster(jointId, constraints){
  const cluster = new Set([jointId]);
  let changed = true;
  while(changed){
    changed = false;
    for(const c of constraints){
      if(c.type === 'coincident'){
        const [j1, j2] = c.joints;
        if(cluster.has(j1) && !cluster.has(j2)){ cluster.add(j2); changed = true; }
        if(cluster.has(j2) && !cluster.has(j1)){ cluster.add(j1); changed = true; }
      }
    }
  }
  return cluster;
}
function findSnap(joints, shapes, svg, lastMouse, excludeIds=[], excludeLineSnap=false, useInferenceTolerance=false){
  if(!lastMouse) return null;
  const pointThreshold = useInferenceTolerance ? INFERENCE_SNAP_PX : SNAP_PX;
  const excluded = Array.isArray(excludeIds) ? excludeIds : (excludeIds ? [excludeIds] : []);
  let best=null; let bestDist=pointThreshold;
  for(const [id,j] of joints.entries()){
    if(excluded.includes(id)) continue;
    const s=worldToScreen(svg,j);
    const d=Math.hypot(s.x-lastMouse.x,s.y-lastMouse.y);
    if(d<bestDist){ bestDist=d; best={type:'joint',id,pt:{x:j.x,y:j.y}}; }
  }
  if(best && best.type === 'joint'){
    return best;
  }
  if(!excludeLineSnap){
    const lineThreshold = LINE_SNAP_PX;
    for(const s of shapes){
      if(s.type==='line'){
        if(s.joints.some(jid => excluded.includes(jid))) continue;
        const a=joints.get(s.joints[0]), b=joints.get(s.joints[1]);
        if(!a||!b) continue;
        const vp = projectPointOnSegment(screenToWorld(svg,lastMouse.x,lastMouse.y), a, b);
        const sc = worldToScreen(svg, vp);
        const d=Math.hypot(sc.x-lastMouse.x, sc.y-lastMouse.y);
        if(d<lineThreshold){ bestDist=d; best={type:'line',shape:s,pt:vp}; }
      }
    }
  }
  return best;
}
function findInference(startPt, endPt, shapes, joints, snapTarget){
  if(!startPt || !endPt) return null;
  const ANGLE_THRESHOLD = 5;
  const dx = endPt.x - startPt.x;
  const dy = endPt.y - startPt.y;
  const len = Math.hypot(dx, dy);
  if(len < 0.1) return null;
  const angle = Math.atan2(dy, dx) * 180 / Math.PI;
  const horizontalDiff = Math.min(Math.abs(angle), Math.abs(Math.abs(angle) - 180));
  if(horizontalDiff < ANGLE_THRESHOLD){
    return { type: 'horizontal', pt: { x: endPt.x, y: startPt.y } };
  }
  const verticalDiff = Math.abs(Math.abs(angle) - 90);
  if(verticalDiff < ANGLE_THRESHOLD){
    return { type: 'vertical', pt: { x: startPt.x, y: endPt.y } };
  }
  let refLine = null;
  if(snapTarget && snapTarget.type === 'line'){
    refLine = snapTarget.shape;
  }
  if(!refLine){
    for(let i = shapes.length - 1; i >= 0; i--){
      const s = shapes[i];
      if(s.type === 'line'){
        const j1 = s.joints[0];
        const j2 = s.joints[1];
        const a = joints.get(j1);
        const b = joints.get(j2);
        if(!a || !b) continue;
        const distToA = Math.hypot(startPt.x - a.x, startPt.y - a.y);
        const distToB = Math.hypot(startPt.x - b.x, startPt.y - b.y);
        if(distToA < 0.1 || distToB < 0.1){
          refLine = s;
          break;
        }
      }
    }
  }
  if(refLine && refLine.type === 'line'){
    const ra = joints.get(refLine.joints[0]);
    const rb = joints.get(refLine.joints[1]);
    if(ra && rb){
      const rdx = rb.x - ra.x;
      const rdy = rb.y - ra.y;
      const rlen = Math.hypot(rdx, rdy);
      if(rlen > 0.1){
        const refAngle = Math.atan2(rdy, rdx) * 180 / Math.PI;
        const perpAngle1 = refAngle + 90;
        const perpAngle2 = refAngle - 90;
        const normAngle = ((angle % 360) + 540) % 360 - 180;
        const normPerp1 = ((perpAngle1 % 360) + 540) % 360 - 180;
        const normPerp2 = ((perpAngle2 % 360) + 540) % 360 - 180;
        const perpDiff1 = Math.abs(normAngle - normPerp1);
        const perpDiff2 = Math.abs(normAngle - normPerp2);
        const minPerpDiff = Math.min(perpDiff1, perpDiff2);
        if(minPerpDiff < ANGLE_THRESHOLD){
          const perpAngleRad = (perpDiff1 < perpDiff2 ? perpAngle1 : perpAngle2) * Math.PI / 180;
          const perpPt = {
            x: startPt.x + len * Math.cos(perpAngleRad),
            y: startPt.y + len * Math.sin(perpAngleRad)
          };
          return { type: 'perpendicular', pt: perpPt, refLine };
        }
      }
    }
  }
  return null;
}

// ---- 4-render.js (inlined) ----
function draw(joints, shapes, svg, active, snapTarget, constraints=[], selectedJoints=new Set(), selectedConstraint=null, currentTool=null, inference=null, selectedShape=null, hoveredShape=null, hoveredJoint=null, hoveredConstraint=null){ 
  if(snapTarget) svg.classList.add('snapping'); else svg.classList.remove('snapping');
  svg.innerHTML=''; 
  const vb = svg.viewBox.baseVal;
  const rect = svg.getBoundingClientRect();
  const zoomX = vb.width / rect.width;
  const zoomY = vb.height / rect.height;
  const zoom = Math.max(zoomX, zoomY);
  const BASE_LINE_STROKE = 6;
  const BASE_LINE_STROKE_SELECTED = 12;
  const BASE_LINE_STROKE_HOVERED = 18;
  const BASE_JOINT_RADIUS = 18;
  const BASE_JOINT_STROKE = 4;
  const BASE_JOINT_STROKE_SELECTED = 8;
  const BASE_JOINT_STROKE_HOVERED = 12;
  const scale = (screenSize) => screenSize * zoom;
  const glyphSize = scale(12);
  const hitZoneRadius = scale(20);
  const gridSize = 50;
  const startX = Math.floor(vb.x / gridSize) * gridSize;
  const startY = Math.floor(vb.y / gridSize) * gridSize;
  for(let x = startX; x < vb.x + vb.width; x += gridSize){
    svg.insertAdjacentHTML('beforeend', `<line x1="${x}" y1="${vb.y}" x2="${x}" y2="${vb.y+vb.height}" stroke="#d0d0d0" stroke-width="1" stroke-opacity="0.5"/>`);
  }
  for(let y = startY; y < vb.y + vb.height; y += gridSize){
    svg.insertAdjacentHTML('beforeend', `<line x1="${vb.x}" y1="${y}" x2="${vb.x+vb.width}" y2="${y}" stroke="#d0d0d0" stroke-width="1" stroke-opacity="0.5"/>`);
  }
  const originStroke = scale(1.5);
  svg.insertAdjacentHTML('beforeend', `<line x1="${vb.x}" y1="0" x2="${vb.x+vb.width}" y2="0" stroke="#ef4444" stroke-width="${originStroke}" stroke-opacity="0.6"/>`);
  svg.insertAdjacentHTML('beforeend', `<line x1="0" y1="${vb.y}" x2="0" y2="${vb.y+vb.height}" stroke="#22c55e" stroke-width="${originStroke}" stroke-opacity="0.6"/>`);
  if(!selectedConstraint){
    selectedConstraint = constraints.find(c => c && c.__selected) || null;
  } else if(selectedConstraint && !selectedConstraint.__selected){
    selectedConstraint.__selected = true;
  }
  let constraintJoints = new Set();
  let constraintShapes = new Set();
  if(selectedConstraint){
    if(selectedConstraint.type === 'coincident' && selectedConstraint.joints){
      for(const jid of selectedConstraint.joints){
        constraintJoints.add(jid);
      }
      for(const s of shapes){
        if(s.joints && s.joints.some(jid => constraintJoints.has(jid))){
          constraintShapes.add(s.id);
        }
      }
    } else if((selectedConstraint.type === 'horizontal' || selectedConstraint.type === 'vertical') && selectedConstraint.joints){
      for(const jid of selectedConstraint.joints){
        constraintJoints.add(jid);
      }
      for(const s of shapes){
        if(s.joints && s.joints.some(jid => constraintJoints.has(jid))){
          constraintShapes.add(s.id);
        }
      }
    } else if((selectedConstraint.type === 'parallel' || selectedConstraint.type === 'perpendicular') && selectedConstraint.shapes){
      for(const sid of selectedConstraint.shapes){
        constraintShapes.add(sid);
      }
    } else if(selectedConstraint.type === 'collinear' && selectedConstraint.joints){
      for(const jid of selectedConstraint.joints){
        constraintJoints.add(jid);
      }
      for(const s of shapes){
        if(s.joints && s.joints.some(jid => constraintJoints.has(jid))){
          constraintShapes.add(s.id);
        }
      }
    } else if(selectedConstraint.type === 'tangent'){
      if(selectedConstraint.line) constraintShapes.add(selectedConstraint.line);
      if(selectedConstraint.circle) constraintShapes.add(selectedConstraint.circle);
    } else if(selectedConstraint.type === 'pointOnLine'){
      if(selectedConstraint.joint) constraintJoints.add(selectedConstraint.joint);
      if(selectedConstraint.shape) constraintShapes.add(selectedConstraint.shape);
    } else if(selectedConstraint.type === 'distance' && selectedConstraint.joints){
      for(const jid of selectedConstraint.joints){
        constraintJoints.add(jid);
      }
      for(const s of shapes){
        if(s.joints && s.joints.some(jid => constraintJoints.has(jid))){
          constraintShapes.add(s.id);
        }
      }
    }
  }
  for(const s of shapes){ 
    const isSelected = selectedShape && selectedShape.id === s.id;
    const isHovered = hoveredShape && hoveredShape.id === s.id;
    const isConstraintPart = constraintShapes.has(s.id);
    let strokeWidth = scale(BASE_LINE_STROKE);
    let strokeColor = '#2563eb';
    if(isConstraintPart){
      strokeWidth = scale(BASE_LINE_STROKE_SELECTED);
      strokeColor = '#ef4444';
    } else if(isHovered){
      strokeWidth = scale(BASE_LINE_STROKE_HOVERED);
      strokeColor = '#1e40af';
    } else if(isSelected){
      strokeWidth = scale(BASE_LINE_STROKE_SELECTED);
      strokeColor = '#1e40af';
    }
    if(s.type==='line'){ 
      const a=joints.get(s.joints[0]), b=joints.get(s.joints[1]); 
      if(a && b) svg.insertAdjacentHTML('beforeend', `<line class="shape-elem" data-shape-id="${s.id}" x1="${a.x}" y1="${a.y}" x2="${b.x}" y2="${b.y}" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-linecap="round" style="cursor:pointer"/>`); 
    } else if(s.type==='circle'){ 
      const c=joints.get(s.joints[0]), p=joints.get(s.joints[1]); 
      if(c && p){ const r=Math.hypot(p.x-c.x,p.y-c.y); svg.insertAdjacentHTML('beforeend', `<circle class="shape-elem" data-shape-id="${s.id}" cx="${c.x}" cy="${c.y}" r="${r}" fill="none" stroke="${strokeColor}" stroke-width="${strokeWidth}" style="cursor:pointer"/>`); }
    } 
  }
  if(active && active.mode){
    const constraintModes = ['coincident', 'parallel', 'perp', 'hv', 'collinear', 'tangent'];
    if(constraintModes.includes(active.mode)){
      if(active.mode === 'coincident' && active.j1){
        const j1 = joints.get(active.j1);
        if(j1){
          const offset = scale(10);
          const x = j1.x + offset, y = j1.y - offset;
          const previewC = { type: 'coincident', joints: [active.j1, active.j1], __isPreview: true, __pos: { x, y } };
          drawConstraintGlyph(svg, previewC);
        }
      } else if(active.mode === 'parallel' && active.shape1){
        const shape = shapes.find(s => s.id === active.shape1);
        if(shape && shape.joints){
          const a = joints.get(shape.joints[0]), b = joints.get(shape.joints[1]);
          if(a && b){
            const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
            const dx = b.x - a.x, dy = b.y - a.y;
            const len = Math.hypot(dx, dy);
            const nx = len > 0 ? -dy / len : 0;
            const ny = len > 0 ? dx / len : 1;
            const offset = scale(10);
            const gx = mx + nx * offset, gy = my + ny * offset;
            const previewC = { type: 'parallel', shapes: [active.shape1, active.shape1], __isPreview: true, __pos: { x: gx, y: gy } };
            drawConstraintGlyph(svg, previewC);
          }
        }
      } else if(active.mode === 'perp' && active.shape1){
        const shape = shapes.find(s => s.id === active.shape1);
        if(shape && shape.joints){
          const a = joints.get(shape.joints[0]), b = joints.get(shape.joints[1]);
          if(a && b){
            const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
            const dx = b.x - a.x, dy = b.y - a.y;
            const len = Math.hypot(dx, dy);
            const nx = len > 0 ? -dy / len : 0;
            const ny = len > 0 ? dx / len : 1;
            const offset = scale(10);
            const gx = mx + nx * offset, gy = my + ny * offset;
            const previewC = { type: 'perpendicular', shapes: [active.shape1, active.shape1], __isPreview: true, __pos: { x: gx, y: gy } };
            drawConstraintGlyph(svg, previewC);
          }
        }
      } else if(active.mode === 'hv'){
      } else if(active.mode === 'collinear' && active.joints && active.joints.length > 0){
        const lastJoint = joints.get(active.joints[active.joints.length - 1]);
        if(lastJoint){
          const offset = scale(10);
          const x = lastJoint.x + offset, y = lastJoint.y - offset;
          const previewC = { type: 'collinear', joints: active.joints.slice(), __isPreview: true, __pos: { x, y } };
          drawConstraintGlyph(svg, previewC);
        }
      } else if(active.mode === 'tangent' && (active.line || active.circle)){
        if(active.line){
          const shape = shapes.find(s => s.id === active.line);
          if(shape && shape.joints){
            const a = joints.get(shape.joints[0]), b = joints.get(shape.joints[1]);
            if(a && b){
              const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
              const dx = b.x - a.x, dy = b.y - a.y;
              const len = Math.hypot(dx, dy);
              const nx = len > 0 ? -dy / len : 0;
              const ny = len > 0 ? dx / len : 1;
              const offset = scale(10);
              const gx = mx + nx * offset, gy = my + ny * offset;
              const symbolSize = glyphSize * 0.6;
              const bgRadius = glyphSize + scale(5);
              const previewC = { type: 'tangent', line: active.line, circle: active.circle, __isPreview: true, __pos: { x: gx, y: gy } };
              drawConstraintGlyph(svg, previewC);
            }
          }
        }
      }
    }
  }
  const origin = joints.get('j_origin');
  if(origin){
    svg.insertAdjacentHTML('beforeend', `<circle cx="${origin.x}" cy="${origin.y}" r="${scale(6)}" fill="#ef4444" style="cursor:pointer"/>`); 
  }
  const pointsCoincidentToOrigin = new Set();
  for(const c of constraints){
    if(c.type === 'coincident' && c.joints){
      const [j1, j2] = c.joints;
      if(j1 === 'j_origin') pointsCoincidentToOrigin.add(j2);
      if(j2 === 'j_origin') pointsCoincidentToOrigin.add(j1);
    }
  }
  const pointsAtOrigin = [];
  for(const [id,j] of joints.entries()){ 
    if(id === 'j_origin') continue; 
    const isSelected = selectedJoints.has(id);
    const isHovered = hoveredJoint && hoveredJoint.id === id;
    const isConstraintPart = constraintJoints.has(id);
    const r = scale(BASE_JOINT_RADIUS);
    const fill = 'white';
    let stroke = '#2563eb';
    let strokeW = scale(BASE_JOINT_STROKE);
    if(isConstraintPart){
      stroke = '#ef4444';
      strokeW = scale(BASE_JOINT_STROKE_SELECTED);
    } else if(isHovered){
      stroke = '#1e40af';
      strokeW = scale(BASE_JOINT_STROKE_HOVERED);
    } else if(isSelected){
      stroke = '#1e40af';
      strokeW = scale(BASE_JOINT_STROKE_SELECTED);
    }
    svg.insertAdjacentHTML('beforeend', `<circle cx="${j.x}" cy="${j.y}" r="${r}" fill="${fill}" stroke="${stroke}" stroke-width="${strokeW}" style="cursor:pointer"/>`);
    if(isHovered){
      svg.insertAdjacentHTML('beforeend', `<circle cx="${j.x}" cy="${j.y}" r="${scale(32)}" fill="#2563eb" fill-opacity="0.15" stroke="none"/>`);
      svg.insertAdjacentHTML('beforeend', `<circle cx="${j.x}" cy="${j.y}" r="${scale(24)}" fill="none" stroke="#2563eb" stroke-width="${scale(3)}"/>`);
    }
    if(pointsCoincidentToOrigin.has(id)){
      pointsAtOrigin.push(j);
    }
  }
  for(const j of pointsAtOrigin){
    svg.insertAdjacentHTML('beforeend', `<circle cx="${j.x}" cy="${j.y}" r="${scale(8)}" fill="#ef4444" style="cursor:pointer; pointer-events:none;"/>`); 
  }
  if(active && active.preview){ 
    const a=joints.get(active.start);
    if(a){
      const p=active.preview.pt;
      if(active.preview.type==='line'){ 
        svg.insertAdjacentHTML('beforeend', `<line x1="${a.x}" y1="${a.y}" x2="${p.x}" y2="${p.y}" stroke="#10b981" stroke-width="2" stroke-dasharray="6"/>`); 
      } else if(active.preview.type==='circle'){
        const r = Math.hypot(p.x-a.x, p.y-a.y);
        svg.insertAdjacentHTML('beforeend', `<circle cx="${a.x}" cy="${a.y}" r="${r}" fill="none" stroke="#10b981" stroke-width="2" stroke-dasharray="6"/>`);
      } else if(active.preview.type==='rect'){
        svg.insertAdjacentHTML('beforeend', `<rect x="${Math.min(a.x,p.x)}" y="${Math.min(a.y,p.y)}" width="${Math.abs(p.x-a.x)}" height="${Math.abs(p.y-a.y)}" fill="none" stroke="#10b981" stroke-width="2" stroke-dasharray="6"/>`);
      } else if(active.preview.type==='rect-center'){
        const dx = p.x - a.x, dy = p.y - a.y;
        svg.insertAdjacentHTML('beforeend', `<rect x="${a.x-dx}" y="${a.y-dy}" width="${Math.abs(dx)*2}" height="${Math.abs(dy)*2}" fill="none" stroke="#10b981" stroke-width="2" stroke-dasharray="6"/>`);
        svg.insertAdjacentHTML('beforeend', `<circle cx="${a.x}" cy="${a.y}" r="4" fill="#10b981" fill-opacity="0.5"/>`);
      } else if(active.preview.type==='rect-3pt'){
        const b = active.secondPt ? joints.get(active.secondPt) : null;
        if(b){
          const dx = b.x - a.x, dy = b.y - a.y;
          const len = Math.hypot(dx, dy); if(len > 0.001){
            const px = -dy/len, py = dx/len;
            const h = (p.x - a.x) * px + (p.y - a.y) * py;
            const c3 = { x: b.x + px * h, y: b.y + py * h };
            const c4 = { x: a.x + px * h, y: a.y + py * h };
            svg.insertAdjacentHTML('beforeend', `<polygon points="${a.x},${a.y} ${b.x},${b.y} ${c3.x},${c3.y} ${c4.x},${c4.y}" fill="none" stroke="#10b981" stroke-width="2" stroke-dasharray="6"/>`);
          }
        } else {
          svg.insertAdjacentHTML('beforeend', `<line x1="${a.x}" y1="${a.y}" x2="${p.x}" y2="${p.y}" stroke="#10b981" stroke-width="2" stroke-dasharray="6"/>`);
        }
      }
    }
  }
  if(active && (active.mode === 'dim-line' || (active.mode === 'dim-p2p' && active.j2))){
    const j1 = joints.get(active.joints[0]), j2 = joints.get(active.joints[1]);
    if(j1 && j2){
      const mx = (j1.x + j2.x)/2, my = (j1.y + j2.y)/2;
      const dx = j2.x - j1.x, dy = j2.y - j1.y;
      const len = Math.hypot(dx, dy);
      const offset = active.offset || 30;
      const dist = active.value ? active.value.toFixed(1) : len.toFixed(1);
      let nx = 0, ny = -1;
      if(len > 0.01){ nx = -dy / len; ny = dx / len; }
      const annotX = mx + nx * offset;
      const annotY = my + ny * offset;
      const ext1End = { x: j1.x + nx * offset, y: j1.y + ny * offset };
      const ext2End = { x: j2.x + nx * offset, y: j2.y + ny * offset };
      const ext1Start = { x: j1.x + nx * 5, y: j1.y + ny * 5 };
      const ext2Start = { x: j2.x + nx * 5, y: j2.y + ny * 5 };
      svg.insertAdjacentHTML('beforeend', `<line x1="${ext1Start.x}" y1="${ext1Start.y}" x2="${ext1End.x}" y2="${ext1End.y}" stroke="#10b981" stroke-width="1" stroke-dasharray="4"/>`);
      svg.insertAdjacentHTML('beforeend', `<line x1="${ext2Start.x}" y1="${ext2Start.y}" x2="${ext2End.x}" y2="${ext2End.y}" stroke="#10b981" stroke-width="1" stroke-dasharray="4"/>`);
      svg.insertAdjacentHTML('beforeend', `<line x1="${ext1End.x}" y1="${ext1End.y}" x2="${ext2End.x}" y2="${ext2End.y}" stroke="#10b981" stroke-width="2" stroke-dasharray="4"/>`);
      svg.insertAdjacentHTML('beforeend', `<rect x="${annotX - 18}" y="${annotY - 8}" width="36" height="14" fill="#10b981" fill-opacity="0.2" rx="2"/>`);
      svg.insertAdjacentHTML('beforeend', `<text x="${annotX}" y="${annotY + 3}" text-anchor="middle" font-size="11" fill="#10b981" font-weight="bold">${dist}</text>`);
    }
  }
  if(snapTarget && active){ 
    const p=snapTarget.pt;
    const isConstraintTool = ['coincident', 'hv', 'parallel', 'perp', 'collinear', 'tangent'].includes(currentTool);
    if(snapTarget.type === 'joint'){
      const canUseJoint = !isConstraintTool || currentTool === 'coincident';
      if(canUseJoint){
        svg.insertAdjacentHTML('beforeend', `<circle cx="${p.x}" cy="${p.y}" r="${scale(32)}" fill="#2563eb" fill-opacity="0.15" stroke="none"/>`);
        svg.insertAdjacentHTML('beforeend', `<circle cx="${p.x}" cy="${p.y}" r="${scale(24)}" fill="none" stroke="#2563eb" stroke-width="${scale(3)}"/>`);
        svg.insertAdjacentHTML('beforeend', `<circle cx="${p.x}" cy="${p.y}" r="${scale(3)}" fill="#2563eb"/>`);;
      }
    } else if(snapTarget.type === 'line'){
      const shape = snapTarget.shape;
      if(shape && shape.joints){
        const a = joints.get(shape.joints[0]), b = joints.get(shape.joints[1]);
        if(a && b){
          svg.insertAdjacentHTML('beforeend', `<line x1="${a.x}" y1="${a.y}" x2="${b.x}" y2="${b.y}" stroke="#2563eb" stroke-width="${scale(4)}" stroke-opacity="0.5"/>`);
        }
      }
      if(!isConstraintTool){
        const diamondSize = 6;
        const diamondStroke = scale(2);
        svg.insertAdjacentHTML('beforeend', `<rect x="${p.x-scale(diamondSize)}" y="${p.y-scale(diamondSize)}" width="${scale(diamondSize*2)}" height="${scale(diamondSize*2)}" fill="#2563eb" fill-opacity="0.3" stroke="#2563eb" stroke-width="${diamondStroke}" transform="rotate(45 ${p.x} ${p.y})"/>`);
        const xSize = 4;
        const xStroke = scale(2);
        svg.insertAdjacentHTML('beforeend', `<line x1="${p.x-scale(xSize)}" y1="${p.y-scale(xSize)}" x2="${p.x+scale(xSize)}" y2="${p.y+scale(xSize)}" stroke="#2563eb" stroke-width="${xStroke}"/>`);
        svg.insertAdjacentHTML('beforeend', `<line x1="${p.x+scale(xSize)}" y1="${p.y-scale(xSize)}" x2="${p.x-scale(xSize)}" y2="${p.y+scale(xSize)}" stroke="#2563eb" stroke-width="${xStroke}"/>`);
      }
    } else {
      if(!isConstraintTool){
        const diamondSize = 6;
        const diamondStroke = scale(2);
        svg.insertAdjacentHTML('beforeend', `<rect x="${p.x-scale(diamondSize)}" y="${p.y-scale(diamondSize)}" width="${scale(diamondSize*2)}" height="${scale(diamondSize*2)}" fill="none" stroke="#2563eb" stroke-width="${diamondStroke}" transform="rotate(45 ${p.x} ${p.y})"/>`);
      }
    }
  }
}

// Helper to draw constraint glyphs (used by render) - simple implementation
function drawConstraintGlyph(svg, c){
  if(!c || !c.type) return;
  const type = c.type;
  const pos = c.__pos || { x: 0, y: 0 };
  const g = `<g class="constraint-glyph" data-ctype="${type}"></g>`;
  svg.insertAdjacentHTML('beforeend', g);
}

// ---- 5-engine.js (inlined) ----
const _joints = new Map();
const _shapes = [];
const _constraints = [];
let _jid = 0;
function _genJ(){ return 'j'+(++_jid)+'_'+Date.now(); }
function _initStore(){ _joints.clear(); _shapes.length = 0; _constraints.length = 0; _jid = 0; _joints.set('j_origin',{x:0,y:0,fixed:true}); }
function createEngine(svg){
  function init(){ _initStore(); }
  function genJ(){ return _genJ(); }
  function getJoints(){ return _joints; }
  function getShapes(){ return _shapes; }
  function getConstraints(){ return _constraints; }
  function addJoint(id,x,y,fixed=false){ _joints.set(id,{x,y,fixed}); }
  function addShape(shape){ _shapes.push(shape); }
  function addConstraint(c){ _constraints.push(c); }
  function mergeJoints(fromId,toId){ if(!_joints.has(fromId)||!_joints.has(toId)||fromId===toId) return; for(const s of _shapes){ for(let i=0;i<s.joints.length;i++) if(s.joints[i]===fromId) s.joints[i]=toId; } _joints.delete(fromId); }
  function solve(iter=20){ solveConstraints(_joints, _shapes, _constraints, iter); }
  function findSnap(lastMouse){ return findSnap(_joints, _shapes, svg, lastMouse); }
  function hitJointAtScreen(screenX,screenY,threshold=10){ return hitJointAtScreen(_joints, svg, screenX, screenY, threshold); }
  return { init, genJ, getJoints, getShapes, getConstraints, addJoint, addShape, addConstraint, mergeJoints, solve, findSnap, hitJointAtScreen };
}

// ---- 6-input.js (inlined) ----
function showDimInput(svg, state, constraint){
  const dimInput = document.getElementById('dimInput');
  if(!dimInput || !constraint.joints || constraint.joints.length < 2) return;
  const j1 = state.joints.get(constraint.joints[0]);
  const j2 = state.joints.get(constraint.joints[1]);
  if(!j1 || !j2) return;
  const mx = (j1.x + j2.x) / 2, my = (j1.y + j2.y) / 2;
  const dx = j2.x - j1.x, dy = j2.y - j1.y;
  const len = Math.hypot(dx, dy);
  const offset = constraint.offset || 30;
  let annotX = mx, annotY = my - 20;
  if(len > 0.01){ const nx = -dy / len, ny = dx / len; annotX = mx + nx * offset; annotY = my + ny * offset; }
  const screenPos = worldToScreen(document.getElementById('svgCanvas'), { x: annotX, y: annotY });
  dimInput.style.left = (screenPos.x - 40) + 'px';
  dimInput.style.top = (screenPos.y - 15) + 'px';
  dimInput.value = constraint.value.toFixed(1);
  dimInput.classList.remove('hidden');
  dimInput.focus();
  dimInput.select();
  const onKeydown = (e) => {
    if(e.key === 'Enter'){
      const newVal = parseFloat(dimInput.value);
      if(!isNaN(newVal) && newVal > 0){ constraint.value = newVal; }
      dimInput.classList.add('hidden'); dimInput.removeEventListener('keydown', onKeydown); dimInput.removeEventListener('blur', onBlur);
    } else if(e.key === 'Escape'){ dimInput.classList.add('hidden'); dimInput.removeEventListener('keydown', onKeydown); dimInput.removeEventListener('blur', onBlur); }
  };
  const onBlur = () => { const newVal = parseFloat(dimInput.value); if(!isNaN(newVal) && newVal > 0){ constraint.value = newVal; } dimInput.classList.add('hidden'); dimInput.removeEventListener('keydown', onKeydown); dimInput.removeEventListener('blur', onBlur); };
  dimInput.addEventListener('keydown', onKeydown);
  dimInput.addEventListener('blur', onBlur);
}

function setupInput(svg, state){
  let continueFrom = null;
  let polylineOrigin = null; 
  let isDragging = false;
  let dragStartScreen = null; 
  const DRAG_THRESHOLD = 2; 
  let justCreatedActive = false;
  function findNearbyJoint(jointsMap, pt, excludeId, eps = 0.01){
    if(!pt) return null;
    for(const [id, j] of jointsMap.entries()){
      if(id === excludeId) continue;
      const dx = j.x - pt.x, dy = j.y - pt.y;
      if(Math.hypot(dx, dy) < eps) return id;
    }
    return null;
  }
  let lastDimClick = { constraint: null, time: 0 };
  const DOUBLE_CLICK_THRESHOLD = 300;
  svg.addEventListener('pointermove',(e)=>{
    state.lastMouse = { x: e.clientX, y: e.clientY };
    const w = screenToWorld(svg, e.clientX, e.clientY);
    const excludeIds = state.drag ? state.drag.jointIds : (state.active ? [state.active.start] : (continueFrom ? [continueFrom] : []));
    const isDraggingPoint = state.drag && (state.drag.type === 'joint' || state.drag.type === 'cluster');
    const useInferenceTolerance = state.active && (state.active.mode === 'line');
    const lineOnlyTools = ['hv', 'parallel', 'perp', 'tangent'];
    const skipJointSnap = lineOnlyTools.includes(state.currentTool);
    if(skipJointSnap){
      state.snapTarget = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
      if(state.snapTarget){ state.snapTarget.type = 'line'; }
    } else {
      state.snapTarget = findSnap(state.joints, state.shapes, svg, state.lastMouse, excludeIds, isDraggingPoint, useInferenceTolerance);
    }
    if(!state.drag && state.currentTool === 'select'){
      const targetElem = e.target;
      const isOverCanvas = targetElem && (targetElem === svg || svg.contains(targetElem));
      if(isOverCanvas){
        const glyphElem = document.elementFromPoint(e.clientX, e.clientY);
        const glyphGroup = glyphElem?.closest('.constraint-glyph');
        if(glyphGroup){
          const ctype = glyphGroup.dataset.ctype;
          if(ctype === 'coincident'){
            const cj0 = glyphGroup.dataset.cj0, cj1 = glyphGroup.dataset.cj1;
            state.hoveredConstraint = state.constraints.find(c => c.type === 'coincident' && c.joints && ((c.joints[0] === cj0 && c.joints[1] === cj1) || (c.joints[0] === cj1 && c.joints[1] === cj0)) );
          } else if(ctype === 'horizontal'){
            const cj0 = glyphGroup.dataset.cj0, cj1 = glyphGroup.dataset.cj1;
            state.hoveredConstraint = state.constraints.find(c => c.type === 'horizontal' && c.joints && c.joints[0] === cj0 && c.joints[1] === cj1);
          } else if(ctype === 'vertical'){
            const cj0 = glyphGroup.dataset.cj0, cj1 = glyphGroup.dataset.cj1;
            state.hoveredConstraint = state.constraints.find(c => c.type === 'vertical' && c.joints && c.joints[0] === cj0 && c.joints[1] === cj1);
          } else if(ctype === 'parallel'){
            const cs0 = glyphGroup.dataset.cs0, cs1 = glyphGroup.dataset.cs1;
            state.hoveredConstraint = state.constraints.find(c => c.type === 'parallel' && c.shapes && c.shapes[0] === cs0 && c.shapes[1] === cs1);
          } else if(ctype === 'perpendicular'){
            const cs0 = glyphGroup.dataset.cs0, cs1 = glyphGroup.dataset.cs1;
            state.hoveredConstraint = state.constraints.find(c => c.type === 'perpendicular' && c.shapes && c.shapes[0] === cs0 && c.shapes[1] === cs1);
          } else if(ctype === 'pointOnLine'){
            const cjoint = glyphGroup.dataset.cjoint, cshape = glyphGroup.dataset.cshape;
            state.hoveredConstraint = state.constraints.find(c => c.type === 'pointOnLine' && c.joint === cjoint && c.shape === cshape);
          } else if(ctype === 'collinear'){
            const cjoints = glyphGroup.dataset.cjoints?.split(',') || [];
            state.hoveredConstraint = state.constraints.find(c => c.type === 'collinear' && c.joints && c.joints.length === cjoints.length && c.joints.every((j, i) => j === cjoints[i]));
          } else if(ctype === 'tangent'){
            const cline = glyphGroup.dataset.cline, ccircle = glyphGroup.dataset.ccircle;
            state.hoveredConstraint = state.constraints.find(c => c.type === 'tangent' && c.line === cline && c.circle === ccircle);
          }
          state.hoveredJoint = null; state.hoveredShape = null;
        } else {
          state.hoveredConstraint = null;
          const hoveredJoint = hitJointAtScreen(state.joints, svg, e.clientX, e.clientY, 20);
          state.hoveredJoint = hoveredJoint || null;
          const hoveredLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
          state.hoveredShape = hoveredLine ? hoveredLine.shape : null;
        }
      } else {
        state.hoveredConstraint = null; state.hoveredJoint = null; state.hoveredShape = null;
      }
    } else {
      state.hoveredJoint = null; state.hoveredShape = null; state.hoveredConstraint = null;
    }
    if(dragStartScreen && state.active){
      const dist = Math.hypot(e.clientX - dragStartScreen.x, e.clientY - dragStartScreen.y);
      if(dist > DRAG_THRESHOLD) isDragging = true;
    }
    if(state.drag){
      isDragging = true;
      if(state.drag.type==='joint' || state.drag.type==='cluster'){
        const wpt = screenToWorld(svg, e.clientX, e.clientY);
        const targetPt = state.snapTarget ? state.snapTarget.pt : wpt;
        const dx = targetPt.x - state.drag.startWorld.x;
        const dy = targetPt.y - state.drag.startWorld.y;
        for(const id of state.drag.jointIds){
          const init = state.drag.initial.get(id);
          const j = state.joints.get(id);
          if(j && init && !j.fixed){ j.x = init.x + dx; j.y = init.y + dy; }
        }
      } else if(state.drag.type==='line'){
        const wpt = screenToWorld(svg, e.clientX, e.clientY);
        const dx = wpt.x - state.drag.startWorld.x;
        const dy = wpt.y - state.drag.startWorld.y;
        for(const id of state.drag.jointIds){
          const init = state.drag.initial.get(id);
          const j = state.joints.get(id);
          if(j && init && !j.fixed){ j.x = init.x + dx; j.y = init.y + dy; }
        }
      } else if(state.drag.type==='pan'){
        const rect = svg.getBoundingClientRect();
        const dx = e.clientX - state.drag.start.x;
        const dy = e.clientY - state.drag.start.y;
        const scaleX = state.view.w / rect.width;
        const scaleY = state.view.h / rect.height;
        state.view.x = state.drag.initialPan.x - dx * scaleX;
        state.view.y = state.drag.initialPan.y - dy * scaleY;
        svg.setAttribute('viewBox', `${state.view.x-state.view.w/2} ${state.view.y-state.view.h/2} ${state.view.w} ${state.view.h}`);
      } else if(state.drag.type==='dim'){
        const constraint = state.drag.constraint;
        if(constraint && constraint.joints && constraint.joints.length >= 2){
          const j1 = state.joints.get(constraint.joints[0]);
          const j2 = state.joints.get(constraint.joints[1]);
          if(j1 && j2){
            const w = screenToWorld(svg, e.clientX, e.clientY);
            const mx = (j1.x + j2.x) / 2, my = (j1.y + j2.y) / 2;
            const dx = j2.x - j1.x, dy = j2.y - j1.y;
            const len = Math.hypot(dx, dy);
            if(len > 0.01){
              const nx = -dy / len, ny = dx / len;
              const toMouse = { x: w.x - mx, y: w.y - my };
              constraint.offset = toMouse.x * nx + toMouse.y * ny;
            }
          }
        }
      }
    }
    if(state.active && (state.active.mode==='line' || state.active.mode==='rect' || state.active.mode==='circle')){
      let previewType = state.active.mode;
      if(state.active.mode === 'rect'){
        const rectMode = state.rectMode || 'rect-2pt';
        if(rectMode === 'rect-center') previewType = 'rect-center';
        else if(rectMode === 'rect-3pt') previewType = 'rect-3pt';
      }
      let previewPt = state.snapTarget ? state.snapTarget.pt : w;
      state.inference = null;
      if(state.active.mode === 'line' && state.active.start){
        const startJoint = state.joints.get(state.active.start);
        if(startJoint){
          const inference = findInference(startJoint, previewPt, state.shapes, state.joints, state.snapTarget);
          if(inference){ state.inference = inference; previewPt = inference.pt; }
        }
      }
      state.active.preview = { type: previewType, pt: previewPt };
    }
    if(continueFrom && (state.currentTool === 'line' || state.currentTool === 'rect' || state.currentTool === 'circle') && !state.active){
      const previewPt = state.snapTarget ? state.snapTarget.pt : w;
      let finalPt = previewPt;
      state.inference = null;
      if(state.currentTool === 'line'){
        const startJoint = state.joints.get(continueFrom);
        if(startJoint){
          const inference = findInference(startJoint, previewPt, state.shapes, state.joints, state.snapTarget);
          if(inference){ state.inference = inference; finalPt = inference.pt; }
        }
      }
      state.active = { mode: state.currentTool, start: continueFrom, preview: { type: state.currentTool, pt: finalPt } };
    }
    if(state.active && (state.active.mode === 'dim-line' || (state.active.mode === 'dim-circle' || (state.active.mode === 'dim-p2p' && state.active.j2)))){
      if(state.active.mode === 'dim-circle'){
        const center = state.joints.get(state.active.joints[0]);
        if(center){
          const distFromCenter = Math.hypot(w.x - center.x, w.y - center.y);
          state.active.offset = distFromCenter;
        }
      } else {
        const j1 = state.joints.get(state.active.joints[0]);
        const j2 = state.joints.get(state.active.joints[1]);
        if(j1 && j2){
          const mx = (j1.x + j2.x) / 2, my = (j1.y + j2.y) / 2;
          const dx = j2.x - j1.x, dy = j2.y - j1.y;
          const len = Math.hypot(dx, dy);
          if(len > 0.01){
            const nx = -dy / len, ny = dx / len;
            const toMouse = { x: w.x - mx, y: w.y - my };
            state.active.offset = toMouse.x * nx + toMouse.y * ny;
          }
        }
      }
    }
  });
  svg.addEventListener('pointerdown',(e)=>{
    console.log('[svg:pointerdown]', 'button', e.button, 'target', e.target && e.target.tagName, 'tool', state.currentTool, 'coords', e.clientX, e.clientY);
    if(e.button === 1){
      svg.setPointerCapture(e.pointerId);
      state.drag = { type: 'pan', start: { x: e.clientX, y: e.clientY }, initialPan: { x: state.view.x, y: state.view.y }, pointerId: e.pointerId };
      return;
    }
    if(state.currentTool === 'select' || state.currentTool === 'dim'){
      let dimLabel = null;
      let target = e.target;
      for(let i = 0; i < 10 && target; i++){
        if(target.classList && target.classList.contains('dim-label')){ dimLabel = target; break; }
        target = target.parentElement;
      }
      if(dimLabel){
        const cIdx = parseInt(dimLabel.getAttribute('data-constraint-idx'));
        const constraint = state.constraints[cIdx];
        if(constraint && constraint.type === 'distance'){
          e.stopPropagation(); e.preventDefault();
          const now = Date.now();
          const isDoubleClick = lastDimClick.constraint === constraint && (now - lastDimClick.time) < DOUBLE_CLICK_THRESHOLD;
          if(isDoubleClick){ showDimInput(svg, state, constraint); lastDimClick = { constraint: null, time: 0 };
          } else {
            state.selectedConstraint = constraint; lastDimClick = { constraint, time: now };
            svg.setPointerCapture(e.pointerId);
            state.drag = { type: 'dim', constraint: constraint, pointerId: e.pointerId, dragStartScreen: { x: e.clientX, y: e.clientY } };
          }
        }
      }
      const w = screenToWorld(svg, e.clientX, e.clientY);
      state.lastMouse = { x: e.clientX, y: e.clientY };
      isDragging = false;
      dragStartScreen = { x: e.clientX, y: e.clientY };
      const excludeIds = continueFrom ? [continueFrom] : [];
      const hitSnap = findSnap(state.joints, state.shapes, svg, state.lastMouse, excludeIds);
      const hitJoint = hitJointAtScreen(state.joints, svg, e.clientX, e.clientY, 30);
      const targetElem = e.target.closest('.constraint-glyph');
      if(targetElem && state.currentTool === 'select'){
        const ctype = targetElem.dataset.ctype;
        let constraint = null;
      }
    }
    
    if(state.currentTool==='line' || state.currentTool==='rect' || state.currentTool==='circle'){
      // If already active (in continuation mode), complete the shape
      if(state.active && state.active.start){
        // Already have a start point from previous click, so this click completes the segment
        // Process the completion in pointerup instead - do nothing here
        return;
      }
      // If continuing from previous shape, use that endpoint as start
      if(continueFrom){
        state.active = { mode: state.currentTool, start: continueFrom, startPt: state.joints.get(continueFrom), preview: null, polylineOrigin: polylineOrigin };
        continueFrom = null; // Clear it so we don't keep reusing
        justCreatedActive = true; // Mark that we just created active in this click
      } else {
        // Snap to existing joint or create new one
        const startPt = hitSnap ? hitSnap.pt : w;
        const startId = hitSnap && hitSnap.type==='joint' ? hitSnap.id : state.genJ(); 
        if(!state.joints.has(startId)) state.joints.set(startId, {x: startPt.x, y: startPt.y, fixed:false}); 
        state.active = { mode: state.currentTool, start: startId, startPt: startPt, preview: null, polylineOrigin: startId };
        polylineOrigin = startId; // Remember the origin of this polyline
        justCreatedActive = true; // Mark that we just created active
      }
    } else if(state.currentTool==='select'){
      continueFrom = null;
      // Clear previous selections when clicking elsewhere
      state.clearSelection();
      
      if(hitJoint){ 
        svg.setPointerCapture(e.pointerId);
        // Find all joints in coincident cluster first
        const cluster = findCoincidentCluster(hitJoint.id, state.constraints);
        const jointIds = Array.from(cluster);
        // Select this joint cluster (add to selection with Shift, replace otherwise)
        if(!e.shiftKey) state.clearSelection();
        state.selectItem('joints', jointIds);
        const initial = new Map();
        for(const id of jointIds){
          const j = state.joints.get(id);
          if(j) initial.set(id, { x: j.x, y: j.y });
        }
        // Only allow dragging if it's a single joint with no coincident constraints
        // Or if it's part of a cluster, drag the entire cluster together
        state.drag = { 
          type: cluster.size > 1 ? 'cluster' : 'joint', 
          id: hitJoint.id, 
          jointIds,
          initial, 
          startWorld: { x: w.x, y: w.y },
          pointerId: e.pointerId 
        };
        state.active = null;
        // If user selected a joint, auto-select any coincident constraint involving it
        // This ensures the glyph appears immediately when clicking the joint
        const coincidentConstraint = state.constraints.find(c => c.type === 'coincident' && c.joints && c.joints.includes(hitJoint.id));
        if(coincidentConstraint){
          console.log('[select] auto-select coincident constraint for joint', hitJoint.id, coincidentConstraint);
          state.selectedConstraint = coincidentConstraint;
          try{ render(); }catch(_){ /* render may be provided by outer scope; ignore if not */ }
        } 
      } else {
        // Check if clicking on a line/shape
        const hitLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
        if(hitLine){
          // Select and prepare to drag the line
          state.selectItem('shape', hitLine.shape);
          state.active = null;
          svg.setPointerCapture(e.pointerId);
          // Start dragging the line by tracking both its joints
          const initial = new Map();
          const jointIds = hitLine.shape.joints;
          for(const id of jointIds){
            const j = state.joints.get(id);
            if(j) initial.set(id, { x: j.x, y: j.y });
          }
          state.drag = {
            type: 'line',
            id: hitLine.shape.id,
            jointIds: jointIds,
            initial: initial,
            startWorld: { x: w.x, y: w.y },
            pointerId: e.pointerId
          };
        } else {
          svg.setPointerCapture(e.pointerId); 
          state.drag = { type:'pan', start: { x: e.clientX, y: e.clientY }, initialPan: { x: state.view.x, y: state.view.y }, pointerId: e.pointerId }; 
        }
      }
    } else if(state.pendingConstraint){
      // Handle pending constraint - second element selection
      continueFrom = null;
      const constraintType = state.pendingConstraint.type;
      const firstElement = state.pendingConstraint.firstElement;
      
      // Determine what type of element we need for the second click
      const lineOnlyTools = ['hv', 'parallel', 'perp', 'tangent'];
      const jointOnlyTools = ['coincident', 'collinear'];
      
      state.saveState(); // Save state BEFORE making changes
      
      if(constraintType === 'parallel' || constraintType === 'perp'){
        // These tools work on lines
        const hitLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
        if(hitLine && hitLine.shape.type === 'line' && hitLine.shape.id !== firstElement.id){
          addConstraint(state, constraintType === 'parallel' ? 'parallel' : 'perpendicular', {
            shapes: [firstElement.id, hitLine.shape.id]
          });
          state.pendingConstraint = null;
          // Reset to select mode
          document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
          document.getElementById('tool-select').classList.add('active');
          const mt = document.getElementById('modeText');
          if(mt) mt.innerText = 'MODE: SELECT';
        }
      } else if(constraintType === 'coincident'){
        // Coincident works on joints OR joint+line (pointOnLine)
        const hitLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
        
        if(firstElement.type === 'joint'){
          // First element was joint
          if(hitSnap && hitSnap.type === 'joint' && hitSnap.id !== firstElement.id){
            // Joint to joint = coincident
            console.log('[UI] Attempting to add coincident constraint between joints', firstElement.id, hitSnap.id);
            addConstraint(state, 'coincident', { joints: [firstElement.id, hitSnap.id] });
            state.pendingConstraint = null;
            state.currentTool = 'select';
            document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
            document.getElementById('tool-select').classList.add('active');
            const mt = document.getElementById('modeText');
            if(mt) mt.innerText = 'MODE: SELECT';
            render();
          } else if(hitLine && hitLine.shape.type === 'line'){
            // Joint to line = pointOnLine (check joint not part of line)
            if(!hitLine.shape.joints.includes(firstElement.id)){
              addConstraint(state, 'pointOnLine', { joint: firstElement.id, shape: hitLine.shape.id });
              state.pendingConstraint = null;
              state.currentTool = 'select';
              document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
              document.getElementById('tool-select').classList.add('active');
              const mt = document.getElementById('modeText');
              if(mt) mt.innerText = 'MODE: SELECT';
              render();
            }
          }
        } else if(firstElement.type === 'shape'){
          // First element was line - second must be joint
          if(hitSnap && hitSnap.type === 'joint'){
            const lineShape = state.shapes.find(s => s.id === firstElement.id);
            if(lineShape && !lineShape.joints.includes(hitSnap.id)){
              addConstraint(state, 'pointOnLine', { joint: hitSnap.id, shape: firstElement.id });
              state.pendingConstraint = null;
              state.currentTool = 'select';
              document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
              document.getElementById('tool-select').classList.add('active');
              const mt = document.getElementById('modeText');
              if(mt) mt.innerText = 'MODE: SELECT';
              render();
            }
          }
        }
      } else if(constraintType === 'hv'){
        // H/V works on lines/joints
        const hitLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
        if(hitLine && hitLine.shape.type === 'line'){
          const j1 = state.joints.get(hitLine.shape.joints[0]);
          const j2 = state.joints.get(hitLine.shape.joints[1]);
          if(j1 && j2){
            const dx = j2.x - j1.x;
            const dy = j2.y - j1.y;
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            const absAngle = Math.abs(angle);
            const isCloserToHorizontal = (absAngle < 45) || (absAngle > 135);
            
            addConstraint(state, isCloserToHorizontal ? 'horizontal' : 'vertical', {
              joints: hitLine.shape.joints.slice()
            });
            state.pendingConstraint = null;
            // Reset to select mode
            document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
            document.getElementById('tool-select').classList.add('active');
            const mt = document.getElementById('modeText');
            if(mt) mt.innerText = 'MODE: SELECT';
          }
        }
      } else if(constraintType === 'collinear'){
        // Collinear works on joints or lines
        if(hitSnap && hitSnap.type === 'joint'){
          // Initialize joints array if needed
          if(!state.pendingConstraint.joints){
            state.pendingConstraint.joints = [firstElement.id];
          }
          
          // Add new joint if not already present
          if(!state.pendingConstraint.joints.includes(hitSnap.id)){
            state.pendingConstraint.joints.push(hitSnap.id);
          }
          
          if(state.pendingConstraint.joints.length >= 3){
            // Can apply collinear now
            addConstraint(state, 'collinear', {
              joints: state.pendingConstraint.joints.slice()
            });
            state.pendingConstraint = null;
            // Reset to select mode
            document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
            document.getElementById('tool-select').classList.add('active');
            const mt = document.getElementById('modeText');
            if(mt) mt.innerText = 'MODE: SELECT';
          } else {
            // Still collecting joints - show how many we have
            const mt = document.getElementById('modeText');
            if(mt) mt.innerText = 'MODE: COLLINEAR - ' + state.pendingConstraint.joints.length + '/3 Points';
          }
        }
      } else if(constraintType === 'tangent'){
        // Tangent works on line + circle pairs
        const hitLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
        const hitCircle = hitLine && hitLine.shape.type === 'circle' ? hitLine.shape : null;
        const hitLineShape = hitLine && hitLine.shape.type === 'line' ? hitLine.shape : null;
        
        const firstIsLine = firstElement.type === 'shape' && state.shapes.find(s => s.id === firstElement.id)?.type === 'line';
        const firstIsCircle = firstElement.type === 'shape' && state.shapes.find(s => s.id === firstElement.id)?.type === 'circle';
        
        if((firstIsLine && hitCircle) || (firstIsCircle && hitLineShape)){
          const lineId = firstIsLine ? firstElement.id : hitLineShape.id;
          const circleId = firstIsCircle ? firstElement.id : hitCircle.id;
          
          addConstraint(state, 'tangent', {
            line: lineId,
            circle: circleId
          });
          state.pendingConstraint = null;
          // Reset to select mode
          document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
          document.getElementById('tool-select').classList.add('active');
          const mt = document.getElementById('modeText');
          if(mt) mt.innerText = 'MODE: SELECT';
        }
      }
    } else if(state.currentTool==='coincident'){
      continueFrom = null;
      // Get fresh snap and line detection for coincident tool
      const coincidentSnap = findSnap(state.joints, state.shapes, svg, state.lastMouse, []);
      const coincidentLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
      
      if(!state.active){ 
        // First click - select joint or line (joint has priority)
        if(coincidentSnap && coincidentSnap.type==='joint'){ 
          state.active = { mode:'coincident', j1: coincidentSnap.id, firstType: 'joint' }; 
          const mt = document.getElementById('modeText');
          if(mt) mt.innerText = 'MODE: COINCIDENT - Click Joint or Line';
        } else if(coincidentLine && coincidentLine.shape.type === 'line'){
          state.active = { mode:'coincident', line1: coincidentLine.shape.id, firstType: 'line' };
          const mt = document.getElementById('modeText');
          if(mt) mt.innerText = 'MODE: COINCIDENT - Click Joint';
        }
      } else { 
        // Second click
        if(state.active.firstType === 'joint'){
          // First was joint - second can be joint (coincident) or line (pointOnLine)
          if(coincidentSnap && coincidentSnap.type==='joint' && coincidentSnap.id !== state.active.j1){ 
            state.saveState();
            addConstraint(state, 'coincident', { joints: [state.active.j1, coincidentSnap.id] }); 
            state.active = null;
            const mt = document.getElementById('modeText');
            if(mt) mt.innerText = 'MODE: COINCIDENT';
            render();
          } else if(coincidentLine && coincidentLine.shape.type === 'line'){
            // Check joint is not part of the line
            if(!coincidentLine.shape.joints.includes(state.active.j1)){
              state.saveState();
              addConstraint(state, 'pointOnLine', { joint: state.active.j1, shape: coincidentLine.shape.id }); 
              state.active = null;
              const mt = document.getElementById('modeText');
              if(mt) mt.innerText = 'MODE: COINCIDENT';
              render();
            }
          }
        } else if(state.active.firstType === 'line'){
          // First was line - second must be joint (pointOnLine)
          if(coincidentSnap && coincidentSnap.type==='joint'){
            const lineShape = state.shapes.find(s => s.id === state.active.line1);
            // Check joint is not part of the line
            if(lineShape && !lineShape.joints.includes(coincidentSnap.id)){
              state.saveState();
              addConstraint(state, 'pointOnLine', { joint: coincidentSnap.id, shape: state.active.line1 }); 
              state.active = null;
              const mt = document.getElementById('modeText');
              if(mt) mt.innerText = 'MODE: COINCIDENT';
              render();
            }
          }
        }
      }
    }
  });

  console.log('[svg:pointerup]', 'button', e.button, 'tool', state.currentTool, 'active', state.active, 'shapesCount', state.shapes.length);
    if(state.active && state.active.mode === 'line'){ // finalize line segment
      const w = screenToWorld(svg, e.clientX, e.clientY);
      const hitSnap = findSnap(state.joints, state.shapes, svg, state.lastMouse || { x: e.clientX, y: e.clientY }, []);
      const endId = (hitSnap && hitSnap.type === 'joint') ? hitSnap.id : state.genJ();
      if(!state.joints.has(endId)) state.joints.set(endId, { x: hitSnap ? hitSnap.pt.x : w.x, y: hitSnap ? hitSnap.pt.y : w.y, fixed:false });
      // create line shape
      const newShape = { id: 's'+Date.now()+'_1', type: 'line', joints: [state.active.start, endId] };
      state.shapes.push(newShape);
      // clear active and set continue point for polylines
      state.selectedShape = null; state.selectedConstraint = null;
      state.active = null;
      // allow continuing from end
      continueFrom = endId;
      polylineOrigin = null;
      render();
      justCreatedActive = false;
      return;
    }

    if(state.active && state.active.mode === 'rect'){
      // Complete rectangle creation on pointerup (2pt, center, 3pt handled elsewhere)
      const w = screenToWorld(svg, e.clientX, e.clientY);
      const hitSnap = findSnap(state.joints, state.shapes, svg, state.lastMouse || { x: e.clientX, y: e.clientY }, []);
      const endId = (hitSnap && hitSnap.type === 'joint') ? hitSnap.id : state.genJ();
      if(!state.joints.has(endId)) state.joints.set(endId, { x: hitSnap ? hitSnap.pt.x : w.x, y: hitSnap ? hitSnap.pt.y : w.y, fixed:false });
      const rectResult = makeRectFromTwoJoints(state.joints, state.active.start, endId, state.genJ);
      rectResult.shapes.forEach(s => state.shapes.push(s)); rectResult.constraints.forEach(c => state.constraints.push(c));
      state.active = null; continueFrom = null; polylineOrigin = null; justCreatedActive = false; render(); return;
    }

    if(state.active && state.active.mode === 'circle'){
      const w = screenToWorld(svg, e.clientX, e.clientY);
      const hitSnap = findSnap(state.joints, state.shapes, svg, state.lastMouse || { x: e.clientX, y: e.clientY }, []);
      const endId = (hitSnap && hitSnap.type === 'joint') ? hitSnap.id : state.genJ();
      if(!state.joints.has(endId)) state.joints.set(endId, { x: hitSnap ? hitSnap.pt.x : w.x, y: hitSnap ? hitSnap.pt.y : w.y, fixed:false });
      // circle is defined by center (start) and radius point (end)
      const circleId = 's'+Date.now()+'_circle';
      state.shapes.push({ id: circleId, type: 'circle', joints: [state.active.start, endId] });
      state.active = null; continueFrom = null; polylineOrigin = null; justCreatedActive = false; render(); return;
    }

    // If dragging a joint/line/dim, finish drag
    if(state.drag){
      if(state.drag && (state.drag.type==='joint' || state.drag.type==='cluster')){
        const other = hitJointAtScreen(state.joints, svg, e.clientX, e.clientY, 14);
        if(other && !state.drag.jointIds.includes(other.id)){ state.mergeJoints(state.drag.id, other.id); }
      }
      if(state.drag && state.drag.pointerId) try{ svg.releasePointerCapture(state.drag.pointerId); }catch(_){ }
      state.drag=null;
    }

    // If we finished a dim creation
    if(state.active && (state.active.mode === 'dim-line' || (state.active.mode === 'dim-p2p' && state.active.j2))){
      const newConstraint = { type: 'distance', joints: state.active.joints.slice(), value: state.active.value, offset: state.active.offset || 30 };
      state.constraints.push(newConstraint);
      state.selectedConstraint = newConstraint;
      showDimInput(svg, state, newConstraint);
      try{ svg.releasePointerCapture(e.pointerId); }catch(_){ }
      state.active = null;
    }

  });

  svg.addEventListener('contextmenu',(e)=>{ e.preventDefault(); continueFrom = null; polylineOrigin = null; state.active = null; });
  svg.addEventListener('wheel',(e)=>{ e.preventDefault(); const factor = e.deltaY > 0 ? 1.1 : 0.9; const rect = svg.getBoundingClientRect(); const aspectRatio = rect.width / rect.height; state.view.w *= factor; state.view.h = state.view.w / aspectRatio; svg.setAttribute('viewBox', `${state.view.x-state.view.w/2} ${state.view.y-state.view.h/2} ${state.view.w} ${state.view.h}`); }, {passive:false});
  state.resetPolyline = () => { continueFrom = null; polylineOrigin = null; };
}

// ---- 7-ui.js (inlined) ----
function setupUI(state){
  document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
  state.rectMode = 'rect-2pt';
  function setTool(t){
    console.log('Setting tool to:', t);
    state.currentTool = t; state.active = null; if(state.resetPolyline) state.resetPolyline(); document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active')); const el = document.getElementById('tool-'+t); if(el) { el.classList.add('active'); console.log('Added active class to:', el.id); } else { console.warn('Button not found for tool:', t); } const mt = document.getElementById('modeText'); let modeText = t.toUpperCase(); if(t === 'rect') { const modeNames = { 'rect-2pt': '2PT', 'rect-center': 'CENTER', 'rect-3pt': '3PT' }; modeText = 'RECT ' + (modeNames[state.rectMode] || ''); } if(mt) mt.innerText = 'MODE: ' + modeText; }
  ['line','rect','circle','coincident','hv','parallel','perp','collinear','tangent','dim','select'].forEach(t=>{ const el=document.getElementById('tool-'+t); if(el){ el.addEventListener('click', (e) => { const constraintTools = ['coincident','hv','parallel','perp','collinear','tangent']; if(constraintTools.includes(t)){ state.selectedJoints.clear(); state.selectedShape = null; state.pendingConstraint = { type: t, firstElement: null }; state.active = null; setTool(t); const mt = document.getElementById('modeText'); let modeText = t === 'collinear' ? (t.toUpperCase() + ' - 1/3 Points') : (t.toUpperCase() + ' - Select 1st Element'); if(mt) mt.innerText = 'MODE: ' + modeText; document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active')); el.classList.add('active'); return; } setTool(t); }); } else { console.warn('Tool button not found:', 'tool-'+t); } });
  const undoBtn = document.getElementById('btn-undo'); if(undoBtn){ undoBtn.disabled = true; undoBtn.addEventListener('click', () => { state.undo(); }); }
  const rectBtn = document.getElementById('tool-rect'); const rectDropdown = document.getElementById('rect-dropdown'); let longPressTimer = null; let dropdownOpenedByLongPress = false; let hoveredDropdownItem = null;
  if(rectBtn && rectDropdown){
    rectBtn.addEventListener('pointerdown', (e) => { dropdownOpenedByLongPress = false; longPressTimer = setTimeout(() => { rectDropdown.classList.add('show'); dropdownOpenedByLongPress = true; longPressTimer = null; }, 400); });
    rectDropdown.querySelectorAll('.tool-dropdown-item').forEach(item => { item.addEventListener('pointerenter', () => { hoveredDropdownItem = item; rectDropdown.querySelectorAll('.tool-dropdown-item').forEach(i => i.classList.remove('hover')); item.classList.add('hover'); }); item.addEventListener('pointerleave', () => { if(hoveredDropdownItem === item) hoveredDropdownItem = null; item.classList.remove('hover'); }); });
    document.addEventListener('pointerup', (e) => { if(longPressTimer){ clearTimeout(longPressTimer); longPressTimer = null; } if(dropdownOpenedByLongPress && rectDropdown.classList.contains('show')){ if(hoveredDropdownItem){ const mode = hoveredDropdownItem.dataset.mode; state.rectMode = mode; rectDropdown.querySelectorAll('.tool-dropdown-item').forEach(i => i.classList.remove('active')); hoveredDropdownItem.classList.add('active'); updateRectIcon(mode); setTool('rect'); } rectDropdown.classList.remove('show'); rectDropdown.querySelectorAll('.tool-dropdown-item').forEach(i => i.classList.remove('hover')); dropdownOpenedByLongPress = false; hoveredDropdownItem = null; } });
    rectBtn.addEventListener('pointerleave', () => { if(longPressTimer){ clearTimeout(longPressTimer); longPressTimer = null; } });
    function updateRectIcon(mode) { const icon2pt = document.querySelectorAll('.rect-icon-2pt'); const iconCenter = document.querySelectorAll('.rect-icon-center'); const icon3pt = document.querySelectorAll('.rect-icon-3pt'); const rectLabel = document.getElementById('rect-label'); icon2pt.forEach(el => el.style.display = 'none'); iconCenter.forEach(el => el.style.display = 'none'); icon3pt.forEach(el => el.style.display = 'none'); if(mode === 'rect-2pt'){ icon2pt.forEach(el => el.style.display = ''); if(rectLabel) rectLabel.textContent = 'Rect'; } else if(mode === 'rect-center'){ iconCenter.forEach(el => el.style.display = ''); if(rectLabel) rectLabel.textContent = 'Ctr'; } else if(mode === 'rect-3pt'){ icon3pt.forEach(el => el.style.display = ''); if(rectLabel) rectLabel.textContent = '3Pt'; } }
    rectDropdown.querySelectorAll('.tool-dropdown-item').forEach(item => { item.addEventListener('click', (e) => { e.stopPropagation(); const mode = item.dataset.mode; state.rectMode = mode; rectDropdown.querySelectorAll('.tool-dropdown-item').forEach(i => i.classList.remove('active')); item.classList.add('active'); updateRectIcon(mode); rectDropdown.classList.remove('show'); setTool('rect'); }); });
    document.addEventListener('click', (e) => { if(!rectBtn.contains(e.target) && !rectDropdown.contains(e.target)) { rectDropdown.classList.remove('show'); } });
  }
  const shortcuts = { 'l': 'line', 'r': 'rect', 'c': 'circle', 's': 'select', 'v': 'select', 'o': 'coincident', 'h': 'hv', 'p': 'parallel', 't': 'perp', 'd': 'dim' };
  window.addEventListener('keydown', (e) => { if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return; const key = e.key.toLowerCase(); if(e.key === 'Escape'){ state.active = null; state.pendingConstraint = null; if(state.resetPolyline) state.resetPolyline(); const mt = document.getElementById('modeText'); if(mt) mt.innerText = 'MODE: SELECT'; document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active')); document.getElementById('tool-select').classList.add('active'); return; } if(shortcuts[key]){ e.preventDefault(); setTool(shortcuts[key]); return; } if((e.key === 'z' || e.key === 'Z') && (e.ctrlKey || e.metaKey)){ e.preventDefault(); if(state.shapes.length) state.shapes.pop(); return; } if(e.key === 'Delete' || e.key === 'Backspace'){ const sel = state.getSelected ? state.getSelected() : state.selection; if(sel && sel.type === 'constraint'){ const c = sel.payload; const idx = state.constraints.indexOf(c); if(idx >= 0){ state.saveState(); if(c.__selected) c.__selected = false; state.constraints.splice(idx, 1); } state.clearSelection(); return; } if(sel && sel.type === 'shape'){ const s = sel.payload; const shapeIdx = state.shapes.indexOf(s); if(shapeIdx !== -1){ state.saveState(); const deletedShapeId = s.id; state.shapes.splice(shapeIdx, 1); state.constraints = state.constraints.filter(c => { if(c.shapes && c.shapes.includes(deletedShapeId)) return false; if(c.shape === deletedShapeId) return false; if(c.line === deletedShapeId) return false; if(c.circle === deletedShapeId) return false; return true; }); } state.clearSelection(); return; } return; } }, true);
  document.getElementById('btn-undo')?.addEventListener('click', ()=>{ if(state.shapes.length) state.shapes.pop(); });
  document.getElementById('btn-clear')?.addEventListener('click', ()=>{ state.initStore(); });
  setTool(state.currentTool || 'select');
}

// ---- 8-main.js (inlined) ----
const svg = document.getElementById('svgCanvas');
let view = { ...DEFAULT_VIEW };
function updateView(){ 
  const rect = svg.getBoundingClientRect();
  const aspectRatio = rect.width / rect.height;
  view.h = view.w / aspectRatio;
  svg.setAttribute('viewBox', `${view.x-view.w/2} ${view.y-view.h/2} ${view.w} ${view.h}`); 
}
window.addEventListener('resize', updateView); setTimeout(updateView, 0);
const engine = createEngine(svg);
const state = {
  engine,
  joints: engine.getJoints(),
  shapes: engine.getShapes(),
  constraints: engine.getConstraints(),
  genJ: () => engine.genJ(),
  initStore: () => engine.init(),
  mergeJoints: (a,b) => engine.mergeJoints(a,b),
  currentTool: 'select',
  active: null,
  drag: null,
  snapTarget: null,
  inference: null,
  lastMouse: null,
  pendingConstraint: null,
  view,
  selection: { type: null, payload: null },
  selectedJoints: new Set(),
  selectedConstraint: null,
  selectedShape: null,
  hoveredShape: null,
  hoveredJoint: null,
  hoveredConstraint: null,
  history: [],
  maxHistory: 5,
  selectItem: function(type, payload, opts = {}){ this.clearSelection(); this.selection = { type, payload }; if(type === 'constraint'){ if(this.constraints) for(const c of this.constraints) if(c && c.__selected) c.__selected = false; this.selectedConstraint = payload || null; if(this.selectedConstraint) this.selectedConstraint.__selected = true; this.selectedShape = null; this.selectedJoints.clear(); } else if(type === 'shape'){ this.selectedShape = payload || null; this.selectedConstraint = null; this.selectedJoints.clear(); } else if(type === 'joint'){ this.selectedJoints.clear(); if(payload) this.selectedJoints.add(payload); this.selectedConstraint = null; this.selectedShape = null; } else if(type === 'joints'){ this.selectedJoints.clear(); if(Array.isArray(payload)) payload.forEach(j => this.selectedJoints.add(j)); this.selectedConstraint = null; this.selectedShape = null; } else { this.selectedConstraint = null; this.selectedShape = null; this.selectedJoints.clear(); } },
  clearSelection: function(){ if(this.selectedConstraint && this.selectedConstraint.__selected) this.selectedConstraint.__selected = false; this.selection = { type: null, payload: null }; this.selectedConstraint = null; this.selectedShape = null; this.selectedJoints.clear(); },
  getSelected: function(){ return this.selection; },
  saveState: function(){ const snapshot = { joints: new Map(Array.from(this.joints.entries()).map(([k,v]) => [k, {...v}])), shapes: this.shapes.map(s => ({...s, joints: s.joints ? [...s.joints] : []})), constraints: this.constraints.map(c => ({...c, joints: c.joints ? [...c.joints] : undefined, shapes: c.shapes ? [...c.shapes] : undefined})) }; this.history.push(snapshot); if(this.history.length > this.maxHistory) this.history.shift(); const undoBtn = document.getElementById('btn-undo'); if(undoBtn) undoBtn.disabled = false; },
  undo: function(){ if(this.history.length === 0) return; const snapshot = this.history.pop(); this.joints.clear(); for(const [k,v] of snapshot.joints) this.joints.set(k, {...v}); this.shapes.length = 0; this.shapes.push(...snapshot.shapes.map(s => ({...s, joints: s.joints ? [...s.joints] : []}))); this.constraints.length = 0; this.constraints.push(...snapshot.constraints.map(c => ({...c, joints: c.joints ? [...c.joints] : undefined, shapes: c.shapes ? [...c.shapes] : undefined}))); this.clearSelection(); this.active = null; const undoBtn = document.getElementById('btn-undo'); if(undoBtn && this.history.length === 0) undoBtn.disabled = true; }
};
engine.init(); setupUI(state); setupInput(svg, state);
window.__dimEditHandler = (cIdx) => { const constraint = state.constraints[cIdx]; if(constraint && constraint.type === 'distance'){ showDimInput(svg, state, constraint); } };
// Expose a global render function for parts of the UI that call `render()` directly
function updateDebugOverlay(){ const el = document.getElementById('debugOverlay'); if(!el) return; try{ el.innerText = 'TOOL: ' + (state.currentTool || 'n/a') + '\nACTIVE: ' + (state.active ? JSON.stringify(state.active, ['mode','start','startPt'], 2) : 'null') + '\nSNAP: ' + (state.snapTarget ? (state.snapTarget.type + (state.snapTarget.id ? ' ' + state.snapTarget.id : '')) : 'none') + '\nMOUSE: ' + JSON.stringify(state.lastMouse || {}) ; }catch(_){ el.innerText = 'debug error'; }}
window.render = () => { draw(state.joints, state.shapes, svg, state.active, state.snapTarget, state.constraints, state.selectedJoints, state.selectedConstraint, state.currentTool, state.inference, state.selectedShape, state.hoveredShape, state.hoveredJoint, state.hoveredConstraint); updateDebugOverlay(); };
function loop(){ engine.solve(8); window.render(); requestAnimationFrame(loop); }
loop();
    </script>
</body>
</html>