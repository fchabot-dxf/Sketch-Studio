<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sketch Studio Ultimate - V24.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono&display=swap');
        :root { --accent: #EA580C; --primary: #3B82F6; --slate: #64748B; }
        body { font-family: 'Inter', sans-serif; touch-action: none; overflow: hidden; background: #F1F5F9; }
        
        .tool-btn { transition: all 0.1s; border: 1px solid transparent; color: var(--slate); cursor: pointer; }
        .tool-btn:hover { background-color: #F1F5F9; color: var(--primary); }
        .tool-btn.active { background-color: var(--primary); color: white !important; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); }
        .tool-btn.active i, .tool-btn.active span { color: white !important; }

        #canvas-svg { width: 100%; height: 100%; touch-action: none; cursor: crosshair; background: white; transition: background-color 0.15s ease-out; }
        
        /* Strict Snap Background - Only when actually snapping */
        .canvas-snap-active { 
            background-color: rgba(234, 88, 12, 0.15) !important; 
        }

        .cursor-grab { cursor: grab !important; }
        .cursor-grabbing { cursor: grabbing !important; }

        .dim-input { 
            position: absolute; background: white; border: 2px solid var(--accent);
            border-radius: 6px; padding: 4px 8px; font-weight: 800; font-size: 12px;
            outline: none; text-align: center; z-index: 100; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1);
            font-family: 'JetBrains Mono', monospace;
        }
        .hidden { display: none; }
        
        .snap-line-active { 
            stroke: var(--accent) !important; 
            stroke-width: 6px !important; 
            stroke-opacity: 0.8 !important;
        }

        #preview-layer, #snap-layer { pointer-events: none; }
        .constraint-glyph { cursor: pointer; pointer-events: auto; }
        .constraint-glyph rect { fill: white; stroke: #CBD5E1; stroke-width: 1px; rx: 3px; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
    </style>
</head>
<body class="flex flex-col h-screen select-none text-xs">

    <header class="bg-[#1E293B] text-white px-4 py-2 flex justify-between items-center z-50 shadow-md shrink-0">
        <div class="flex items-center gap-3">
            <div class="bg-orange-600 p-1.5 rounded-lg shadow-lg rotate-3"><i data-lucide="target" class="w-4 h-4 text-white"></i></div>
            <div>
                <h1 class="text-[11px] font-extrabold uppercase tracking-widest leading-none">Sketch Studio</h1>
                <span class="text-[9px] text-slate-400 font-bold uppercase tracking-tighter">V24.0 Precision Snap</span>
            </div>
        </div>
        <div id="coords-display" class="font-mono text-[10px] text-slate-400 bg-slate-800 px-2 py-1 rounded">X: 0 Y: 0</div>
    </header>

    <div class="bg-white border-b border-slate-200 p-1 flex gap-1 z-40 overflow-x-auto no-scrollbar shadow-sm shrink-0">
        <div class="flex gap-1 pr-2 border-r border-slate-200">
            <button onclick="setTool('select')" id="btn-select" class="tool-btn active flex flex-col items-center justify-center min-w-[55px] h-14 rounded-lg">
                <i data-lucide="mouse-pointer-2" class="w-5 mb-1"></i><span class="text-[8px] font-bold uppercase">Select</span>
            </button>
        </div>
        <div class="flex gap-1 px-2 border-r border-slate-200">
            <button onclick="setTool('line')" id="btn-line" class="tool-btn flex flex-col items-center justify-center min-w-[55px] h-14 rounded-lg"><i data-lucide="minus" class="w-5 mb-1"></i><span class="text-[8px] font-bold uppercase">Line</span></button>
            <button onclick="setTool('rect')" id="btn-rect" class="tool-btn flex flex-col items-center justify-center min-w-[55px] h-14 rounded-lg"><i data-lucide="square" class="w-5 mb-1"></i><span class="text-[8px] font-bold uppercase">Rect</span></button>
            <button onclick="setTool('circle')" id="btn-circle" class="tool-btn flex flex-col items-center justify-center min-w-[55px] h-14 rounded-lg"><i data-lucide="circle" class="w-5 mb-1"></i><span class="text-[8px] font-bold uppercase">Circle</span></button>
            <button onclick="setTool('arc')" id="btn-arc" class="tool-btn flex flex-col items-center justify-center min-w-[55px] h-14 rounded-lg"><i data-lucide="corner-right-up" class="w-5 mb-1 rotate-45"></i><span class="text-[8px] font-bold uppercase">Arc</span></button>
        </div>
        <div class="flex gap-1 px-2 border-r border-slate-200">
            <button onclick="setTool('coincident')" id="btn-coincident" class="tool-btn flex flex-col items-center justify-center min-w-[50px] h-14 rounded-lg"><i data-lucide="link" class="w-5 mb-1 text-blue-500"></i><span class="text-[8px] font-bold uppercase">Coinc</span></button>
            <button onclick="setTool('hv')" id="btn-hv" class="tool-btn flex flex-col items-center justify-center min-w-[50px] h-14 rounded-lg"><i data-lucide="split" class="w-5 mb-1"></i><span class="text-[8px] font-bold uppercase">H / V</span></button>
            <button onclick="setTool('parallel')" id="btn-parallel" class="tool-btn flex flex-col items-center justify-center min-w-[50px] h-14 rounded-lg"><i data-lucide="columns-2" class="w-5 mb-1 rotate-45"></i><span class="text-[8px] font-bold uppercase">Para</span></button>
            <button onclick="setTool('tangent')" id="btn-tangent" class="tool-btn flex flex-col items-center justify-center min-w-[50px] h-14 rounded-lg"><i data-lucide="circle-dot" class="w-5 mb-1 text-purple-600"></i><span class="text-[8px] font-bold uppercase">Tangent</span></button>
        </div>
        <div class="flex gap-1 px-2">
            <button onclick="setTool('dimension')" id="btn-dimension" class="tool-btn flex flex-col items-center justify-center min-w-[50px] h-14 rounded-lg"><i data-lucide="hash" class="w-5 mb-1 text-orange-600"></i><span class="text-[8px] font-bold uppercase">Dim</span></button>
        </div>
        <div class="ml-auto flex items-center gap-2 pr-4">
            <button onclick="undo()" class="p-2 hover:bg-slate-100 rounded-lg text-slate-400"><i data-lucide="undo-2" class="w-4"></i></button>
            <button onclick="clearCanvas()" class="p-2 hover:bg-red-50 rounded-lg text-slate-400 hover:text-red-500"><i data-lucide="trash-2" class="w-4"></i></button>
        </div>
    </div>

    <main class="flex-1 relative bg-slate-200 p-2 overflow-hidden" id="main-container">
        <div class="w-full h-full bg-white rounded-xl shadow-inner border border-slate-300 relative overflow-hidden" id="canvas-wrapper">
            <svg id="canvas-svg">
                <defs>
                    <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse"><path d="M 20 0 L 0 0 0 20" fill="none" stroke="#F1F5F9" stroke-width="0.5"/></pattern>
                    <pattern id="grid-heavy" width="100" height="100" patternUnits="userSpaceOnUse"><rect width="100" height="100" fill="url(#grid)" /><path d="M 100 0 L 0 0 0 100" fill="none" stroke="#E2E8F0" stroke-width="1"/></pattern>
                </defs>
                <rect width="100%" height="100%" fill="url(#grid-heavy)" />
                <g id="world-group">
                    <g id="origin-datum"><circle r="5" fill="none" stroke="#64748B" stroke-width="1.5" /><line x1="-10" y1="0" x2="10" y2="0" stroke="#64748B" stroke-width="1" /><line x1="0" y1="-10" x2="0" y2="10" stroke="#64748B" stroke-width="1" /></g>
                    <g id="shapes-layer"></g><g id="constraints-layer"></g><g id="preview-layer"></g><g id="snap-layer"></g>
                </g>
            </svg>
            <div id="floating-status" class="absolute top-4 right-4 bg-white/80 backdrop-blur border border-slate-200 px-3 py-1.5 rounded-lg shadow-sm pointer-events-none flex items-center gap-3">
                <span id="active-tool-badge" class="px-2 py-0.5 bg-slate-800 text-white rounded text-[9px] font-black uppercase">SELECT</span>
                <span id="selection-count" class="text-[9px] font-black text-slate-400 uppercase">Ready</span>
            </div>
            <input type="number" id="dim-input" class="dim-input hidden" />
        </div>
    </main>

    <footer class="bg-white border-t border-slate-200 px-4 py-1.5 flex justify-between items-center text-[10px] font-bold text-slate-400 shrink-0 uppercase tracking-widest">
        <div>Space/Middle: Pan | Wheel: Zoom | ESC: Reset</div>
        <div id="stats-text">0 Objects | 0 Constraints</div>
    </footer>

    <script>
        let joints = new Map(), shapes = [], constraints = [], currentTool = 'select';
        let viewPan = { x: 0, y: 0 }, viewScale = 1;
        let dragTarget = null, activeShape = null, selectionBuffer = [], selectedConstraint = null, snapTarget = null;
        let jointIdCounter = 0, lastTouchDist = 0;
        
        // Click tolerance settings
        const CLICK_THRESHOLD = 5; // pixels of movement before considering it a drag instead of a click
        let pointerDownCoords = null; // Track pointer down position to detect accidental drags

        const svg = document.getElementById('canvas-svg'), worldGroup = document.getElementById('world-group'),
              shapesLayer = document.getElementById('shapes-layer'), constraintsLayer = document.getElementById('constraints-layer'),
              previewLayer = document.getElementById('preview-layer'), snapLayer = document.getElementById('snap-layer'), 
              dimInput = document.getElementById('dim-input'), canvasWrapper = document.getElementById('canvas-svg'); // Target the SVG itself

        joints.set('origin', { x: 0, y: 0, fixed: true });

        function init() {
            lucide.createIcons(); centerOrigin();
            window.onresize = centerOrigin; window.onkeydown = handleKeyDown;
            dimInput.onkeydown = handleDimInputKey; svg.onwheel = handleWheel;
            svg.onpointerdown = handlePointerDown; svg.onpointermove = handlePointerMove; svg.onpointerup = handlePointerUp;
            svg.ontouchstart = (e) => { if(e.touches.length === 2) lastTouchDist = Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY); };
            svg.ontouchmove = handleTouchMove;
            requestAnimationFrame(loop);
        }

        // --- MATH ---
        function getArcData(p1, p2, p3) {
            const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y;
            const D = 2 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));
            if (Math.abs(D) < 0.1) return null;
            const cx = ((x1**2 + y1**2) * (y2 - y3) + (x2**2 + y2**2) * (y3 - y1) + (x3**2 + y3**2) * (y1 - y2)) / D;
            const cy = ((x1**2 + y1**2) * (x3 - x2) + (x2**2 + y2**2) * (x1 - x3) + (x3**2 + y3**2) * (x2 - x1)) / D;
            return { cx, cy, r: Math.hypot(x1 - cx, y1 - cy) };
        }

        // --- SOLVER ---
        function solve() {
            for (let i = 0; i < 80; i++) {
                for (const c of constraints) {
                    const j = c.joints.map(id => joints.get(id)); if (j.some(n => !n)) continue;
                    switch (c.type) {
                        case 'horizontal': { const my = (j[0].y + j[1].y)/2; if(!j[0].fixed) j[0].y = my; if(!j[1].fixed) j[1].y = my; break; }
                        case 'vertical': { const mx = (j[0].x + j[1].x)/2; if(!j[0].fixed) j[0].x = mx; if(!j[1].fixed) j[1].x = mx; break; }
                        case 'distance': {
                            const dx = j[1].x-j[0].x, dy = j[1].y-j[0].y, d = Math.hypot(dx,dy);
                            if (d < 0.1) continue;
                            const f = (d - c.value)/d * 0.5;
                            if(!j[0].fixed) { j[0].x += dx*f; j[0].y += dy*f; }
                            if(!j[1].fixed) { j[1].x -= dx*f; j[1].y -= dy*f; }
                            break;
                        }
                        case 'parallel': {
                            const dxR = j[1].x-j[0].x, dyR = j[1].y-j[0].y, angR = Math.atan2(dyR, dxR);
                            const dxC = j[3].x-j[2].x, dyC = j[3].y-j[2].y, len = Math.hypot(dxC,dyC);
                            let target = (dxR*dxC + dyR*dyC < 0) ? angR + Math.PI : angR;
                            const cx = (j[2].x+j[3].x)/2, cy = (j[2].y+j[3].y)/2;
                            if(!j[2].fixed) { j[2].x = cx - Math.cos(target)*len*0.5; j[2].y = cy - Math.sin(target)*len*0.5; }
                            if(!j[3].fixed) { j[3].x = cx + Math.cos(target)*len*0.5; j[3].y = cy + Math.sin(target)*len*0.5; }
                            break;
                        }
                        case 'tangent': {
                            const r = Math.hypot(j[1].x-j[0].x, j[1].y-j[0].y);
                            const dx = j[3].x-j[2].x, dy = j[3].y-j[2].y, lsq = dx*dx + dy*dy;
                            if (lsq < 0.1) continue;
                            const t = ((j[0].x-j[2].x)*dx + (j[0].y-j[2].y)*dy)/lsq;
                            const px = j[2].x + t*dx, py = j[2].y + t*dy, dist = Math.hypot(j[0].x-px, j[0].y-py);
                            if (dist < 0.1) continue;
                            const f = (dist - r) / dist;
                            const ox = (j[0].x - px) * f, oy = (j[0].y - py) * f;
                            if(!j[0].fixed) { j[0].x -= ox; j[0].y -= oy; }
                            if(!j[1].fixed) { j[1].x -= ox; j[1].y -= oy; }
                            break;
                        }
                        case 'point-on-line': {
                            const dx = j[2].x-j[1].x, dy = j[2].y-j[1].y, lsq = dx*dx + dy*dy;
                            if (lsq < 0.1) continue;
                            const t = ((j[0].x-j[1].x)*dx + (j[0].y-j[1].y)*dy)/lsq;
                            const px = j[1].x + t*dx, py = j[1].y + t*dy;
                            if(!j[0].fixed) { j[0].x = px; j[0].y = py; }
                            break;
                        }
                        case 'point-on-curve': {
                            const r = Math.hypot(j[2].x-j[1].x, j[2].y-j[1].y);
                            const dx = j[0].x-j[1].x, dy = j[0].y-j[1].y, d = Math.hypot(dx,dy);
                            if (d < 0.1) continue;
                            const f = r/d;
                            if(!j[0].fixed) { j[0].x = j[1].x + dx*f; j[0].y = j[1].y + dy*f; }
                            break;
                        }
                    }
                }
            }
        }

        function loop() { solve(); draw(); requestAnimationFrame(loop); }

        function draw() {
            document.getElementById('active-tool-badge').innerText = currentTool;
            document.getElementById('selection-count').innerText = selectionBuffer.length > 0 ? `Selected: ${selectionBuffer.length}/2` : 'Ready';
            document.getElementById('stats-text').innerText = `${shapes.length} Objects | ${constraints.length} Constraints`;

            // STRICT SNAP CHECK: Only change background if actively snapping to a valid target while dragging
            const isDraggingJoint = dragTarget && dragTarget.type === 'joint';
            const isValidSnapTarget = snapTarget && (snapTarget.type === 'joint' || snapTarget.type === 'line-snap' || snapTarget.type === 'curve');
            const isDrawing = activeShape && activeShape.startId;
            
            if ((isDraggingJoint || isDrawing) && isValidSnapTarget) {
                canvasWrapper.classList.add('canvas-snap-active');
            } else {
                canvasWrapper.classList.remove('canvas-snap-active');
            }

            let sHtml = '';
            for (const s of shapes) {
                const jN = s.joints.map(id => joints.get(id)).filter(n => !!n);
                if (jN.length < 2) continue;
                const isS = selectionBuffer.some(h => h.shape === s);
                // Line snap highlight logic
                const isLineSnap = isActive && isSnapTarget && snapTarget.shape === s;
                
                const col = isS ? 'var(--accent)' : 'var(--primary)';
                const w = (isS || isLineSnap ? 4.5 : 2.5) / viewScale;
                const cls = isLineSnap ? 'snap-line-active' : '';

                if (s.type === 'line') sHtml += `<line x1="${jN[0].x}" y1="${jN[0].y}" x2="${jN[1].x}" y2="${jN[1].y}" stroke="${col}" stroke-width="${w}" stroke-linecap="round" class="${cls}" />`;
                else if (s.type === 'circle') sHtml += `<circle cx="${jN[0].x}" cy="${jN[0].y}" r="${Math.hypot(jN[1].x-jN[0].x, jN[1].y-jN[0].y)}" fill="none" stroke="${col}" stroke-width="${w}" class="${cls}" />`;
                else if (s.type === 'arc' && jN.length === 3) {
                    const arc = getArcData(jN[0], jN[1], jN[2]);
                    if (arc) {
                        const sA = Math.atan2(jN[0].y-arc.cy, jN[0].x-arc.cx), eA = Math.atan2(jN[2].y-arc.cy, jN[2].x-arc.cx), mA = Math.atan2(jN[1].y-arc.cy, jN[1].x-arc.cx);
                        let sweep = eA - sA; while(sweep < 0) sweep += Math.PI*2;
                        let mid = mA - sA; while(mid < 0) mid += Math.PI*2;
                        sHtml += `<path d="M ${jN[0].x} ${jN[0].y} A ${arc.r} ${arc.r} 0 ${sweep>Math.PI?1:0} ${mid<sweep?1:0} ${jN[2].x} ${jN[2].y}" fill="none" stroke="${col}" stroke-width="${w}" stroke-linecap="round" class="${cls}" />`;
                    }
                }
            }
            // Joints
            for (const [id, j] of joints.entries()) {
                const isO = id==='origin', isS = selectionBuffer.some(h => h.id === id);
                // Highlight joint if snapping to it while dragging/drawing
                const isSn = isActive && isSnapTarget && snapTarget.type === 'joint' && snapTarget.id === id;
                const r = (isO ? 5 : (isS || isSn ? 7 : 3.5)) / viewScale;
                sHtml += `<circle cx="${j.x}" cy="${j.y}" r="${r}" fill="${isO?'var(--slate)':'white'}" stroke="${isS||isSn?'var(--accent)':'var(--primary)'}" stroke-width="1.5" />`;
            }
            shapesLayer.innerHTML = sHtml;

            let cHtml = '';
            constraints.forEach((c, idx) => {
                const j = c.joints.map(id => joints.get(id)).filter(n=>!!n); if (j.length < 2) return;
                const icon = { horizontal: '-', vertical: '|', parallel: '//', tangent: 'â—‹', 'point-on-line': 'X', 'point-on-curve': 'X', distance: '#' }[c.type] || 'X';
                let mx, my;
                if (c.type === 'point-on-line' || c.type === 'point-on-curve') { mx = j[0].x + 10/viewScale; my = j[0].y - 10/viewScale; }
                else { mx = (j[0].x+j[1].x)/2; my = (j[0].y+j[1].y)/2 - 15/viewScale; }
                cHtml += `<g class="constraint-glyph" data-index="${idx}" transform="translate(${mx}, ${my}) scale(${1/viewScale})"><rect x="-7" y="-7" width="14" height="14" rx="2" /><text y="3" text-anchor="middle" font-size="9" font-weight="900" fill="#64748B">${icon}</text></g>`;
            });
            constraintsLayer.innerHTML = cHtml;

            if (activeShape) {
                const j = joints.get(activeShape.startId), t = activeShape.temp, w = 2/viewScale;
                if (currentTool === 'line') previewLayer.innerHTML = `<line x1="${j.x}" y1="${j.y}" x2="${t.x}" y2="${t.y}" stroke="var(--primary)" stroke-width="${w}" stroke-dasharray="4" />`;
                else if (currentTool === 'circle') previewLayer.innerHTML = `<circle cx="${j.x}" cy="${j.y}" r="${Math.hypot(t.x-j.x, t.y-j.y)}" fill="none" stroke="var(--primary)" stroke-width="${w}" stroke-dasharray="4" />`;
                else if (currentTool === 'rect') previewLayer.innerHTML = `<rect x="${Math.min(j.x,t.x)}" y="${Math.min(j.y,t.y)}" width="${Math.abs(j.x-t.x)}" height="${Math.abs(j.y-t.y)}" fill="none" stroke="var(--primary)" stroke-width="${w}" stroke-dasharray="4" />`;
                else if (currentTool === 'arc') {
                    if(activeShape.phase === 1) previewLayer.innerHTML = `<line x1="${j.x}" y1="${j.y}" x2="${t.x}" y2="${t.y}" stroke="var(--primary)" stroke-width="${w}" stroke-dasharray="4" />`;
                    else {
                        const arc = getArcData(j, t, joints.get(activeShape.endId));
                        if(arc) previewLayer.innerHTML = `<path d="M ${j.x} ${j.y} A ${arc.r} ${arc.r} 0 ${0} 0 ${joints.get(activeShape.endId).x} ${joints.get(activeShape.endId).y}" fill="none" stroke="var(--primary)" stroke-width="${w}" stroke-dasharray="4" />`;
                    }
                }
            } else previewLayer.innerHTML = '';
            
            snapLayer.innerHTML = '';
        }

        // --- INTERACTION ---
        function handlePointerDown(e) {
            const coords = getCoords(e);
            pointerDownCoords = { ...coords }; // Track initial click position
            
            const ct = e.target.closest('.constraint-glyph');
            if (ct) { selectedConstraint = constraints[parseInt(ct.getAttribute('data-index'))]; return; }
            selectedConstraint = null; dimInput.classList.add('hidden');
            const hit = findHit(coords, (e.pointerType === 'touch' ? 30 : 15), activeShape?.startId);

            if (currentTool === 'select' || e.button === 1) {
                if (e.button === 1) dragTarget = { type: 'pan', start: { x: e.clientX, y: e.clientY }, initPan: { ...viewPan } };
                else if (hit?.type === 'joint') dragTarget = { type: 'joint', id: hit.id };
                else if (hit?.shape) {
                    const iJs = new Map(); hit.shape.joints.forEach(id => iJs.set(id, { ...joints.get(id) }));
                    dragTarget = { type: 'shape', shape: hit.shape, initJoints: iJs, startCoords: { ...coords } };
                } else if (!hit) { 
                    selectionBuffer = []; 
                    dragTarget = { type: 'pan', start: { x: e.clientX, y: e.clientY }, initPan: { ...viewPan } }; 
                }
                svg.setPointerCapture(e.pointerId);
            }
            else if (['line', 'circle', 'rect', 'arc'].includes(currentTool)) {
                if (!activeShape) {
                    const sId = hit?.type === 'joint' ? hit.id : genJointId();
                    if (!joints.has(sId)) joints.set(sId, { ...coords, fixed: false });
                    activeShape = { startId: sId, phase: 1, temp: { ...coords } };
                } else {
                    const eId = hit?.type === 'joint' ? hit.id : genJointId();
                    if (!joints.has(eId)) joints.set(eId, { ...coords, fixed: false });

                    // Auto-snap on creation
                    if (hit?.type === 'joint' && hit.id !== activeShape.startId) { /* Joint ID used above */ }
                    else if (hit && ['line-snap', 'curve'].includes(hit.type)) {
                        constraints.push({ type: (hit.type==='line-snap'?'point-on-line':'point-on-curve'), joints: [eId, ...hit.shape.joints] });
                    }

                    if (currentTool === 'line') {
                        shapes.push({ type: 'line', joints: [activeShape.startId, eId] });
                        activeShape = hit ? null : { startId: eId, phase: 1, temp: coords };
                    } else if (currentTool === 'circle') {
                        shapes.push({ type: 'circle', joints: [activeShape.startId, eId] }); activeShape = null;
                    } else if (currentTool === 'rect') {
                        const j1 = activeShape.startId, j3 = eId, j2 = genJointId(), j4 = genJointId();
                        const p1 = joints.get(j1), p3 = joints.get(j3);
                        joints.set(j2, { x: p3.x, y: p1.y }); joints.set(j4, { x: p1.x, y: p3.y });
                        shapes.push({ type: 'line', joints: [j1, j2] }, { type: 'line', joints: [j2, j3] }, { type: 'line', joints: [j3, j4] }, { type: 'line', joints: [j4, j1] });
                        constraints.push({ type: 'horizontal', joints: [j1, j2] }, { type: 'vertical', joints: [j2, j3] }, { type: 'horizontal', joints: [j3, j4] }, { type: 'vertical', joints: [j4, j1] });
                        activeShape = null;
                    } else if (currentTool === 'arc') {
                        if (activeShape.phase === 1) { activeShape.mid = coords; activeShape.endId = eId; activeShape.phase = 2; }
                        else {
                            const midId = genJointId(); joints.set(midId, { ...coords, fixed: false });
                            shapes.push({ type: 'arc', joints: [activeShape.startId, midId, activeShape.endId] });
                            activeShape = null;
                        }
                    }
                }
            }
            else if (['coincident', 'hv', 'parallel', 'tangent'].includes(currentTool) && hit) {
                if (!selectionBuffer.some(h => h.id === hit.id && h.shape === hit.shape)) {
                    if(selectionBuffer.length >= 2) selectionBuffer.shift(); 
                    selectionBuffer.push(hit);
                }
                if (selectionBuffer.length === 2) {
                    const [h1, h2] = selectionBuffer;
                    if (currentTool === 'coincident') {
                        if (h1.type === 'joint' && h2.type === 'joint') mergeJoints(h1.id, h2.id);
                        else if (h1.type === 'joint' && h2.shape) constraints.push({ type: h2.shape.type==='line'?'point-on-line':'point-on-curve', joints: [h1.id, ...h2.shape.joints] });
                        else if (h2.type === 'joint' && h1.shape) constraints.push({ type: h1.shape.type==='line'?'point-on-line':'point-on-curve', joints: [h2.id, ...h1.shape.joints] });
                    } else if (currentTool === 'parallel') constraints.push({ type: 'parallel', joints: [...h1.shape.joints, ...h2.shape.joints] });
                    else if (currentTool === 'tangent') constraints.push({ type: 'tangent', joints: [...h1.shape.joints, ...h2.shape.joints] });
                    selectionBuffer = [];
                }
            }
            else if (currentTool === 'dimension' && hit) {
                if (hit.shape?.type === 'line') constraints.push({ type: 'distance', joints: [...hit.shape.joints], value: Math.hypot(joints.get(hit.shape.joints[1]).x - joints.get(hit.shape.joints[0]).x, joints.get(hit.shape.joints[1]).y - joints.get(hit.shape.joints[0]).y), offset: coords });
                else if (hit.type === 'joint') { selectionBuffer.push(hit); if (selectionBuffer.length === 2) { constraints.push({ type: 'distance', joints: [selectionBuffer[0].id, selectionBuffer[1].id], value: Math.hypot(joints.get(selectionBuffer[0].id).x - joints.get(selectionBuffer[1].id).x, joints.get(selectionBuffer[0].id).y - joints.get(selectionBuffer[1].id).y), offset: coords }); selectionBuffer = []; } }
            }
        }

        function handlePointerMove(e) {
            const raw = getCoords(e); let coords = raw;
            document.getElementById('coords-display').innerText = `X: ${Math.round(coords.x)} Y: ${Math.round(coords.y)}`;
            
            // Detect if pointer has moved significantly (not a click)
            let hasMovedSignificantly = false;
            if (pointerDownCoords) {
                const moveDistance = Math.hypot(coords.x - pointerDownCoords.x, coords.y - pointerDownCoords.y);
                if (moveDistance > CLICK_THRESHOLD / viewScale) {
                    hasMovedSignificantly = true;
                }
            }
            
            // When actively drawing or dragging, find snap targets
            // Exclude current start point from snap candidates while drawing to prevent self-snap
            const exId = activeShape ? activeShape.startId : (dragTarget?.type === 'joint' ? dragTarget.id : null);
            snapTarget = findHit(coords, (e.pointerType === 'touch' ? 30 : 15), exId);

            if (dragTarget && hasMovedSignificantly) {
                if (snapTarget?.point) coords = snapTarget.point;
                if (dragTarget.type === 'joint') { const j = joints.get(dragTarget.id); if (j && !j.fixed) { j.x = coords.x; j.y = coords.y; } }
                else if (dragTarget.type === 'shape') {
                    const dx = coords.x-dragTarget.startCoords.x, dy = coords.y-dragTarget.startCoords.y;
                    dragTarget.shape.joints.forEach(id => { const j = joints.get(id), i = dragTarget.initJoints.get(id); if(j && !j.fixed) { j.x = i.x+dx; j.y = i.y+dy; } });
                } else if (dragTarget.type === 'pan') { viewPan.x = dragTarget.initPan.x + (e.clientX-dragTarget.start.x); viewPan.y = dragTarget.initPan.y + (e.clientY-dragTarget.start.y); updateViewport(); }
            } else if (activeShape && hasMovedSignificantly) { if (snapTarget?.point) coords = snapTarget.point; activeShape.temp = coords; }
            
            if (currentTool === 'select') {
                if (dragTarget && dragTarget.type === 'pan') svg.classList.add('cursor-grabbing');
                else if (snapTarget && !dragTarget) svg.classList.add('cursor-grab');
                else svg.classList.remove('cursor-grab', 'cursor-grabbing');
            } else svg.classList.remove('cursor-grab', 'cursor-grabbing');
        }

        function handleTouchMove(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                const factor = dist / lastTouchDist;
                const rect = svg.getBoundingClientRect();
                const midX = (e.touches[0].clientX + e.touches[1].clientX)/2 - rect.left;
                const midY = (e.touches[0].clientY + e.touches[1].clientY)/2 - rect.top;
                const wPt = svg.createSVGPoint(); wPt.x = midX + rect.left; wPt.y = midY + rect.top;
                const p = wPt.matrixTransform(worldGroup.getScreenCTM().inverse());
                viewScale = Math.max(0.1, Math.min(20, viewScale * factor));
                viewPan.x = midX - p.x * viewScale; viewPan.y = midY - p.y * viewScale;
                updateViewport(); lastTouchDist = dist;
            }
        }

        function handlePointerUp() { 
            // Apply constraints if dragging a joint onto a valid snap target
            if (dragTarget?.type === 'joint' && snapTarget) {
                if (snapTarget.type === 'joint' && snapTarget.id !== dragTarget.id) {
                    mergeJoints(snapTarget.id, dragTarget.id);
                }
                else if (snapTarget.type === 'line-snap') {
                    // Snap point to line - create point-on-line constraint
                    const constraint = { type: 'point-on-line', joints: [dragTarget.id, ...snapTarget.shape.joints] };
                    // Check if constraint already exists
                    if (!constraints.some(c => c.type === 'point-on-line' && c.joints[0] === dragTarget.id && 
                        c.joints.slice(1).every(id => snapTarget.shape.joints.includes(id)))) {
                        constraints.push(constraint);
                    }
                }
                else if (snapTarget.type === 'curve') {
                    // Snap point to curve - create point-on-curve constraint
                    const constraint = { type: 'point-on-curve', joints: [dragTarget.id, ...snapTarget.shape.joints] };
                    if (!constraints.some(c => c.type === 'point-on-curve' && c.joints[0] === dragTarget.id && 
                        c.joints.slice(1).every(id => snapTarget.shape.joints.includes(id)))) {
                        constraints.push(constraint);
                    }
                }
            }
            dragTarget = null;
            snapTarget = null; // Clear snap target after releasing
            pointerDownCoords = null; // Clear pointer tracking
            svg.classList.remove('cursor-grabbing');
        }

        function findHit(coords, threshold = 15, exId = null) {
            // Check Joints first
            for (const [id, j] of joints.entries()) if (id !== exId && Math.hypot(coords.x-j.x, coords.y-j.y) < threshold/viewScale) return { type: 'joint', id };
            
            // Check Shapes (Lines/Curves) - allow snapping to any part of the shape
            // The exId exclusion is just for joints, not for line/curve snapping
            for (const s of shapes) {
                const j = s.joints.map(id => joints.get(id));
                if (!j.every(n => n)) continue; // Skip if joints are missing

                if (s.type === 'line') {
                    const dx = j[1].x-j[0].x, dy = j[1].y-j[0].y, lsq = dx*dx+dy*dy;
                    if (lsq < 0.1) continue; // Degenerate line
                    const t = Math.max(0, Math.min(1, ((coords.x-j[0].x)*dx+(coords.y-j[0].y)*dy)/lsq));
                    const px = j[0].x+t*dx, py = j[0].y+t*dy;
                    const dist = Math.hypot(coords.x-px, coords.y-py);
                    if (dist < threshold/viewScale) return { type: 'line-snap', shape: s, point: {x:px, y:py} };
                } else if (s.type === 'circle') {
                    const r = Math.hypot(j[1].x-j[0].x, j[1].y-j[0].y), d = Math.hypot(coords.x-j[0].x, coords.y-j[0].y);
                    if (d < 0.1) continue; // Point is at center
                    const dist = Math.abs(d - r);
                    if (dist < threshold/viewScale) return { type: 'curve', shape: s, point: { x: j[0].x+(coords.x-j[0].x)*(r/d), y: j[0].y+(coords.y-j[0].y)*(r/d) } };
                } else if (s.type === 'arc' && j.length >= 3) {
                    const arcData = getArcData(j[0], j[1], j[2]);
                    if (arcData) {
                        const d = Math.hypot(coords.x-arcData.cx, coords.y-arcData.cy);
                        if (d < 0.1) continue;
                        const dist = Math.abs(d - arcData.r);
                        if (dist < threshold/viewScale) return { type: 'curve', shape: s, point: { x: arcData.cx+(coords.x-arcData.cx)*(arcData.r/d), y: arcData.cy+(coords.y-arcData.cy)*(arcData.r/d) } };
                    }
                }
            }
            return null;
        }

        function setTool(t) { currentTool = t; selectionBuffer = []; activeShape = null; document.querySelectorAll('.tool-btn').forEach(b => b.classList.toggle('active', b.id === 'btn-'+t)); }
        function getCoords(e) { const r = svg.getBoundingClientRect(); const pt = svg.createSVGPoint(); pt.x = e.clientX; pt.y = e.clientY; const inv = pt.matrixTransform(worldGroup.getScreenCTM().inverse()); return { x: inv.x, y: inv.y }; }
        function handleWheel(e) { e.preventDefault(); const f = e.deltaY > 0 ? 1/1.1 : 1.1; const r = svg.getBoundingClientRect(); const wPt = svg.createSVGPoint(); wPt.x = e.clientX; wPt.y = e.clientY; const p = wPt.matrixTransform(worldGroup.getScreenCTM().inverse()); viewScale = Math.max(0.1, Math.min(20, viewScale * f)); viewPan.x = (e.clientX-r.left) - p.x*viewScale; viewPan.y = (e.clientY-r.top) - p.y*viewScale; updateViewport(); }
        function updateViewport() { worldGroup.setAttribute('transform', `translate(${viewPan.x}, ${viewPan.y}) scale(${viewScale})`); }
        function centerOrigin() { const r = svg.getBoundingClientRect(); viewPan.x = r.width/2; viewPan.y = r.height/2; updateViewport(); }
        function genJointId() { return 'j_' + (++jointIdCounter) + '_' + Date.now(); }
        function handleKeyDown(e) { if (e.key === 'Escape') { selectionBuffer = []; activeShape = null; setTool('select'); } }
        function undo() { shapes.pop(); constraints = constraints.filter(c => c.joints.every(id => joints.has(id))); }
        function clearCanvas() { joints.clear(); joints.set('origin', { x: 0, y: 0, fixed: true }); shapes = []; constraints = []; centerOrigin(); }
        function mergeJoints(keep, remove) { if (keep === remove) return; shapes.forEach(s => s.joints = s.joints.map(id => id === remove ? keep : id)); constraints.forEach(c => c.joints = c.joints.map(id => id === remove ? keep : id)); joints.delete(remove); }
        function handleDimInputKey(e) { if (e.key === 'Enter') { const v = parseFloat(dimInput.value); if (!isNaN(v) && selectedConstraint) selectedConstraint.value = v; dimInput.classList.add('hidden'); svg.focus(); } }
        function showDimInputAt(x, y, v) { dimInput.style.left = (x-30)+'px'; dimInput.style.top = (y-15)+'px'; dimInput.value = v; dimInput.classList.remove('hidden'); setTimeout(()=>dimInput.focus(), 50); }

        init();
    </script>
</body>
</html>


