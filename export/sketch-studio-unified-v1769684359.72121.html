<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sketch Studio Unified</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --fusion-dark: #2C2C2C;
            --fusion-orange: #EA580C;
            --fusion-blue: #3B82F6;
        }
        body { font-family: 'Inter', sans-serif; touch-action: none; overflow: hidden; -webkit-user-select: none; user-select: none; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        .cursor-select { cursor: default; }
        .cursor-draw { cursor: crosshair; }
        .cursor-pan { cursor: grab; }
        .cursor-pan:active { cursor: grabbing; }

        .tool-btn {
            transition: all 0.15s;
            border: 1px solid transparent;
            min-width: 48px;
            min-height: 48px;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        .tool-btn:active {
            background-color: #e0e0e0;
            transform: scale(0.95);
        }
        @media (max-width: 640px) {
            .tool-btn {
                min-width: 44px;
                min-height: 44px;
                width: 44px;
                height: 44px !important;
            }
            .tool-btn span {
                font-size: 7px !important;
            }
            .tool-btn:active {
                transform: scale(0.92);
            }
        }
        .tool-btn:hover {
            background-color: #f0f0f0;
        }
        @media (hover: none) {
            .tool-btn:hover {
                background-color: transparent;
            }
        }
        .tool-btn.active {
            background-color: #3B82F6;
            color: white;
            border: 1px solid #1E40AF;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        .tool-btn.active:active {
            background-color: #2563eb;
        }
        .tool-btn.active span, .tool-btn.active i { color: white; }

        #svgCanvas { width: 100%; height: 100%; touch-action: none; background-color: #ffffff; transition: background-color 0.15s ease; }
        #svgCanvas.snapping { background-color: #fff7ed; }
        
        /* Prevent pinch-zoom but allow panning */
        @supports (touch-action: pan-x pan-y) {
            #svgCanvas {
                touch-action: pan-x pan-y;
            }
        }
        
        /* Tool dropdown */
        .tool-dropdown {
            position: relative;
        }
        .tool-dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            border: 1px solid #cbd5e1;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 9999;
            min-width: 100px;
        }
        .tool-dropdown-menu.show {
            display: block;
        }
        .tool-dropdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 600;
            white-space: nowrap;
            min-height: 40px;
        }
        @media (max-width: 640px) {
            .tool-dropdown-item {
                padding: 10px 14px;
                font-size: 11px;
            }
        }
        .tool-dropdown-item:hover,
        .tool-dropdown-item.hover {
            background: #e0e7ff;
        }
        .tool-dropdown-item.active {
            background: #3B82F6;
            color: white;
        }
        .tool-btn .dropdown-indicator {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 4px solid #94a3b8;
        }
        .tool-btn.active .dropdown-indicator {
            border-top-color: white;
        }
        
        .dim-input { 
            position: absolute; background: white; border: 2px solid var(--fusion-orange);
            border-radius: 4px; padding: 2px 4px; font-weight: bold; font-size: 11px;
            outline: none; text-align: center; z-index: 100; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        @media (max-width: 640px) {
            .dim-input {
                padding: 4px 6px;
                font-size: 14px;
                min-width: 70px;
                min-height: 36px;
                -webkit-appearance: none;
                appearance: none;
            }
            .dim-input::-webkit-outer-spin-button,
            .dim-input::-webkit-inner-spin-button {
                -webkit-appearance: none;
                margin: 0;
            }
            .dim-input[type=number] {
                -moz-appearance: textfield;
            }
        }
        .dim-input.hidden { display: none; }
    </style>
</head>
<body class="flex flex-col h-screen bg-[#F0F0F0] select-none text-xs">

    <!-- HEADER -->
    <header class="bg-[#2C2C2C] text-white px-4 py-2 flex justify-between items-center z-50 shadow-lg shrink-0 relative">
        <div class="flex items-center gap-4">
            <div class="bg-orange-600 p-1 rounded shadow-inner"><i data-lucide="maximize" class="w-4 h-4"></i></div>
            <span class="text-[11px] font-bold uppercase tracking-widest text-slate-200">Sketch Studio Unified</span>
        </div>
        <div class="flex items-center gap-4 text-[10px] font-bold text-slate-400">
            <span id="solver-status" class="text-green-500 uppercase">Solver Active</span>
        </div>
    </header>

    <!-- TOOLS RIBBON -->
    <div class="bg-white border-b border-slate-300 p-1 flex gap-1 z-40 overflow-x-auto no-scrollbar shadow-sm shrink-0 relative">
        <!-- EDIT -->
        <div class="flex flex-col items-center px-1 md:px-2 border-r border-slate-200 shrink-0">
            <div class="flex gap-0.5 flex-wrap md:flex-nowrap justify-center">
                <button id="btn-undo" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded" disabled>
                    <i data-lucide="undo-2" class="w-5 h-5 mb-0.5"></i>
                    <span class="text-[8px] font-medium uppercase">Undo</span>
                </button>
            </div>
            <span class="text-[7px] text-slate-400 uppercase mt-0.5">Edit</span>
        </div>
        <!-- CREATE -->
        <div class="flex flex-col items-center px-1 md:px-2 border-r border-slate-200 shrink-0">
            <div class="flex gap-0.5 flex-wrap md:flex-nowrap justify-center">
                <button id="tool-select" class="tool-btn active flex flex-col items-center justify-center w-12 h-14 md:w-12 md:h-14 rounded">
                    <i data-lucide="mouse-pointer-2" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Select</span>
                </button>
                <button id="tool-line" class="tool-btn flex flex-col items-center justify-center w-12 h-14 md:w-12 md:h-14 rounded">
                    <i data-lucide="minus" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Line</span>
                </button>
                <div class="tool-dropdown">
                    <button id="tool-rect" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded relative">
                        <svg id="rect-icon" class="w-[18px] h-[18px]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <!-- 2-point mode icon (default) -->
                            <rect x="4" y="4" width="16" height="16"/>
                            <circle cx="4" cy="4" r="2" fill="currentColor" class="rect-icon-dot rect-icon-2pt"/>
                            <circle cx="20" cy="20" r="2" fill="currentColor" class="rect-icon-dot rect-icon-2pt"/>
                            <!-- center mode dots -->
                            <circle cx="12" cy="12" r="2" fill="currentColor" class="rect-icon-dot rect-icon-center" style="display:none"/>
                            <circle cx="20" cy="20" r="2" fill="currentColor" class="rect-icon-dot rect-icon-center" style="display:none"/>
                            <!-- 3-point mode dots -->
                            <circle cx="4" cy="4" r="2" fill="currentColor" class="rect-icon-dot rect-icon-3pt" style="display:none"/>
                            <circle cx="20" cy="4" r="2" fill="currentColor" class="rect-icon-dot rect-icon-3pt" style="display:none"/>
                            <circle cx="20" cy="20" r="2" fill="currentColor" class="rect-icon-dot rect-icon-3pt" style="display:none"/>
                        </svg>
                        <span id="rect-label" class="text-[8px] font-black uppercase mt-1">Rect</span>
                        <span class="dropdown-indicator"></span>
                    </button>
                    <div id="rect-dropdown" class="tool-dropdown-menu">
                        <div class="tool-dropdown-item active" data-mode="rect-2pt">
                            <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="16" height="16"/><circle cx="4" cy="4" r="2" fill="currentColor"/><circle cx="20" cy="20" r="2" fill="currentColor"/></svg>
                            2-Point (Corner)
                        </div>
                        <div class="tool-dropdown-item" data-mode="rect-center">
                            <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="16" height="16"/><circle cx="12" cy="12" r="2" fill="currentColor"/><circle cx="20" cy="20" r="2" fill="currentColor"/></svg>
                            Center Point
                        </div>
                        <div class="tool-dropdown-item" data-mode="rect-3pt">
                            <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="16" height="16"/><circle cx="4" cy="4" r="2" fill="currentColor"/><circle cx="20" cy="4" r="2" fill="currentColor"/><circle cx="20" cy="20" r="2" fill="currentColor"/></svg>
                            3-Point
                        </div>
                    </div>
                </div>
                <button id="tool-circle" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded">
                    <i data-lucide="circle" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Circle</span>
                </button>
            </div>
            <span class="text-[8px] font-black uppercase text-slate-300 mt-1">Create</span>
        </div>

        <!-- CONSTRAIN -->
        <div class="flex flex-col items-center px-2 border-r border-slate-200">
            <div class="flex gap-0.5">
                <button id="tool-coincident" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded">
                    <svg class="w-[18px] h-[18px]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                        <line x1="6" y1="6" x2="18" y2="18"/><line x1="18" y1="6" x2="6" y2="18"/>
                    </svg>
                    <span class="text-[8px] font-black uppercase mt-1">Coinc</span>
                </button>
                <button id="tool-hv" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded">
                    <svg class="w-[18px] h-[18px]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                        <line x1="4" y1="12" x2="20" y2="12"/><line x1="12" y1="4" x2="12" y2="20"/>
                    </svg>
                    <span class="text-[8px] font-black uppercase mt-1">H/V</span>
                </button>
                <button id="tool-parallel" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded">
                    <svg class="w-[18px] h-[18px]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                        <line x1="4" y1="20" x2="20" y2="4"/><line x1="8" y1="20" x2="24" y2="4"/>
                    </svg>
                    <span class="text-[8px] font-black uppercase mt-1">Para</span>
                </button>
                <button id="tool-perp" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded">
                    <svg class="w-[18px] h-[18px]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                        <line x1="4" y1="20" x2="20" y2="20"/><line x1="12" y1="20" x2="12" y2="4"/>
                    </svg>
                    <span class="text-[8px] font-black uppercase mt-1">Perp</span>
                </button>
                <button id="tool-collinear" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded">
                    <svg class="w-[18px] h-[18px]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                        <line x1="2" y1="12" x2="22" y2="12"/>
                        <circle cx="6" cy="12" r="2" fill="currentColor"/>
                        <circle cx="12" cy="12" r="2" fill="currentColor"/>
                        <circle cx="18" cy="12" r="2" fill="currentColor"/>
                    </svg>
                    <span class="text-[8px] font-black uppercase mt-1">Coll</span>
                </button>
                <button id="tool-tangent" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded">
                    <svg class="w-[18px] h-[18px]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                        <circle cx="12" cy="12" r="8"/>
                        <line x1="2" y1="12" x2="12" y2="12"/>
                    </svg>
                    <span class="text-[8px] font-black uppercase mt-1">Tang</span>
                </button>
            </div>
            <span class="text-[8px] font-black uppercase text-slate-300 mt-1">Constrain</span>
        </div>

        <!-- INSPECT -->
        <div class="flex flex-col items-center px-2 border-r border-slate-200">
            <div class="flex gap-0.5">
                <button id="tool-dim" class="tool-btn flex flex-col items-center justify-center w-12 h-14 rounded">
                    <i data-lucide="hash" class="w-[18px]"></i>
                    <span class="text-[8px] font-black uppercase mt-1">Dim</span>
                </button>
            </div>
            <span class="text-[8px] font-black uppercase text-slate-300 mt-1">Inspect</span>
        </div>

        <!-- ACTIONS -->
        <div class="ml-auto flex items-center gap-2 pr-4 shrink-0">
            <button id="btn-undo" class="p-2 hover:bg-slate-100 rounded text-slate-400" title="Undo"><i data-lucide="undo-2" class="w-4"></i></button>
            <button id="btn-clear" class="p-2 hover:bg-red-50 rounded text-slate-400 hover:text-red-500" title="Clear All"><i data-lucide="trash-2" class="w-4"></i></button>
        </div>
    </div>

    <!-- MAIN VIEWPORT -->
    <main class="flex-1 relative bg-[#DBDBDB] flex flex-col overflow-hidden p-2 md:p-4">
        <div class="flex-1 bg-white rounded shadow-inner border border-slate-300 relative overflow-hidden">
            <svg id="svgCanvas" preserveAspectRatio="xMidYMid slice">
                <defs>
                    <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                        <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#F1F5F9" stroke-width="0.5"/>
                    </pattern>
                    <pattern id="grid-heavy" width="100" height="100" patternUnits="userSpaceOnUse">
                        <rect width="100" height="100" fill="url(#grid)" />
                        <path d="M 100 0 L 0 0 0 100" fill="none" stroke="#E2E8F0" stroke-width="1"/>
                    </pattern>
                </defs>
                <rect id="infinite-grid" width="100%" height="100%" fill="url(#grid-heavy)" />
                <g id="world-group">
                    <g id="origin-datum">
                        <circle r="4" fill="none" stroke="#64748B" stroke-width="1.5" />
                        <line x1="-8" y1="0" x2="8" y2="0" stroke="#64748B" stroke-width="1" />
                        <line x1="0" y1="-8" x2="0" y2="8" stroke="#64748B" stroke-width="1" />
                    </g>
                </g>
            </svg>
            <input type="number" id="dimInput" class="dim-input hidden" step="0.1" inputmode="decimal" autocomplete="off" />
            <div id="constraintTooltip" class="constraint-tooltip hidden">Press Delete to remove constraint</div>
        </div>
    </main>

    <!-- FOOTER -->
    <footer class="bg-slate-100 border-t border-slate-300 px-4 py-1.5 flex justify-between items-center text-[10px] font-bold text-slate-400 uppercase tracking-tighter shrink-0">
        <div class="flex gap-4"><span id="modeText">MODE: SELECT</span></div>
        <div><span id="coords-text">X: 0 Y: 0</span></div>
    </footer>

    <script>lucide.createIcons();</script>
    <script>
        // Prevent iOS default gesture behaviors that might interfere
        document.addEventListener('gesturestart', (e) => {
            e.preventDefault();
        }, { passive: false });
        
        // Prevent unwanted page zoom on double-tap (iOS)
        document.addEventListener('dblclick', (e) => {
            if(e.target.id === 'svgCanvas') {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
    <script>

// ---- 1-utils.js (inlined) ----
/**
 * Given a constraint and the list of shapes, returns the joints and shapes affected by the constraint.
 * @param {object} constraint - The constraint object
 * @param {Array} shapes - The array of shape objects
 * @returns {{joints: Set<string>, shapes: Set<string>}}
 */
function getConstrainedGeometry(constraint, shapes) {
  const constraintJoints = new Set();
  const constraintShapes = new Set();
  if (!constraint) return { joints: constraintJoints, shapes: constraintShapes };
  // Debug: log constraint type and ids
  if (typeof window !== 'undefined' && window.console) {
    console.log('[getConstrainedGeometry] type:', constraint.type, 'joints:', constraint.joints, 'shapes:', constraint.shapes, 'constraint:', constraint);
  }
  if (constraint.type === 'coincident' && constraint.joints) {
    for (const jid of constraint.joints) constraintJoints.add(jid);
    for (const s of shapes) {
      if (s.joints && s.joints.some(jid => constraintJoints.has(jid))) {
        constraintShapes.add(s.id);
      }
    }
  } else if ((constraint.type === 'horizontal' || constraint.type === 'vertical') && constraint.joints) {
    for (const jid of constraint.joints) constraintJoints.add(jid);
    for (const s of shapes) {
      if (s.joints && s.joints.some(jid => constraintJoints.has(jid))) {
        constraintShapes.add(s.id);
      }
    }
  } else if ((constraint.type === 'parallel' || constraint.type === 'perpendicular') && constraint.shapes) {
    for (const sid of constraint.shapes) constraintShapes.add(sid);
  } else if (constraint.type === 'collinear' && constraint.joints) {
    for (const jid of constraint.joints) constraintJoints.add(jid);
    for (const s of shapes) {
      if (s.joints && s.joints.some(jid => constraintJoints.has(jid))) {
        constraintShapes.add(s.id);
      }
    }
  } else if (constraint.type === 'tangent') {
    if (constraint.line) constraintShapes.add(constraint.line);
    if (constraint.circle) constraintShapes.add(constraint.circle);
  } else if (constraint.type === 'pointOnLine') {
    if (constraint.joint) constraintJoints.add(constraint.joint);
    if (constraint.shape) constraintShapes.add(constraint.shape);
  } else if (constraint.type === 'distance' && constraint.joints) {
    for (const jid of constraint.joints) constraintJoints.add(jid);
    for (const s of shapes) {
      if (s.joints && s.joints.some(jid => constraintJoints.has(jid))) {
        constraintShapes.add(s.id);
      }
    }
  }
  return { joints: constraintJoints, shapes: constraintShapes };
}
// Constants
const SNAP_PX = 50; // Joint snap tolerance for general selection (pixels) - increased for touch
const INFERENCE_SNAP_PX = 15; // Joint snap tolerance for inference hints (pixels) - more restrictive
const LINE_SNAP_PX = 20; // Line snap tolerance (pixels)
const DEFAULT_VIEW = { x:0, y:0, w:1200, h:800 };

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSTRAINT COLORS - Single source of truth for all constraint visualization
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const CONSTRAINT_COLORS = {
  coincident:    { fill: '#ef4444', stroke: '#dc2626' },  // Red
  horizontal:    { fill: '#22c55e', stroke: '#15803d' },  // Green
  vertical:      { fill: '#22c55e', stroke: '#0369a1' },  // Green (blue stroke for distinction)
  parallel:      { fill: '#3b82f6', stroke: '#ca8a04' },  // Blue
  perpendicular: { fill: '#a855f7', stroke: '#7c3aed' },  // Purple
  collinear:     { fill: '#14b8a6', stroke: '#0d9488' },  // Teal
  tangent:       { fill: '#fbbf24', stroke: '#ca8a04' },  // Yellow
  pointOnLine:   { fill: '#fb923c', stroke: '#ea580c' },  // Orange
  distance:      { fill: '#9ca3af', stroke: '#2563eb' },  // Gray/Blue
};


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSTRAINT FACTORY - Single place to create constraint objects
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Create a constraint object with validation
 * @param {string} type - Constraint type
 * @param {object} params - Constraint parameters
 * @returns {object|null} Constraint object or null if invalid
 */
function createConstraint(type, params) {
  switch(type) {
    case 'coincident':
      if (!params.joints || params.joints.length < 2) return null;
      if (params.joints[0] === params.joints[1]) return null; // Can't coincident to self
      return { type: 'coincident', joints: params.joints };
    
    case 'pointOnLine':
      if (!params.joint || !params.shape) return null;
      return { type: 'pointOnLine', joint: params.joint, shape: params.shape };
    
    case 'horizontal':
    case 'vertical':
      if (!params.joints || params.joints.length < 2) return null;
      return { type, joints: params.joints.slice() };
    
    case 'parallel':
    case 'perpendicular':
      if (!params.shapes || params.shapes.length < 2) return null;
      return { type, shapes: params.shapes };
    
    case 'collinear':
      if (!params.joints || params.joints.length < 3) return null;
      return { type: 'collinear', joints: params.joints.slice() };
    
    case 'tangent':
      if (!params.line || !params.circle) return null;
      return { type: 'tangent', line: params.line, circle: params.circle };
    
    case 'distance':
      if (!params.joints || params.joints.length < 2) return null;
      return { 
        type: 'distance', 
        joints: params.joints, 
        value: params.value,
        offset: params.offset || 30,
        isRadius: params.isRadius || false
      };
    
    default:
      console.warn('Unknown constraint type:', type);
      return null;
  }
}

/**
 * Check if a constraint already exists (duplicate detection)
 * @param {array} constraints - Existing constraints array
 * @param {string} type - Constraint type to check
 * @param {object} params - Constraint parameters
 * @returns {boolean} True if duplicate exists
 */
function hasConstraint(constraints, type, params) {
  for (const c of constraints) {
    if (c.type !== type) continue;
    
    switch(type) {
      case 'coincident':
        // Check both orderings
        if (c.joints && params.joints) {
          const [a, b] = c.joints;
          const [x, y] = params.joints;
          if ((a === x && b === y) || (a === y && b === x)) return true;
        }
        break;
      
      case 'pointOnLine':
        if (c.joint === params.joint && c.shape === params.shape) return true;
        break;
      
      case 'horizontal':
      case 'vertical':
        // Same joints in any order
        if (c.joints && params.joints) {
          const cSet = new Set(c.joints);
          if (params.joints.every(j => cSet.has(j)) && params.joints.length === c.joints.length) return true;
        }
        break;
      
      case 'parallel':
      case 'perpendicular':
        if (c.shapes && params.shapes) {
          const [a, b] = c.shapes;
          const [x, y] = params.shapes;
          if ((a === x && b === y) || (a === y && b === x)) return true;
        }
        break;
      
      case 'tangent':
        if (c.line === params.line && c.circle === params.circle) return true;
        break;
    }
  }
  return false;
}

/**
 * Add a constraint to the state if it doesn't already exist
 * @param {object} state - App state with constraints array
 * @param {string} type - Constraint type
 * @param {object} params - Constraint parameters
 * @returns {boolean} True if constraint was added
 */
function addConstraint(state, type, params) {
  // Ignore preview constraints (synthetic previews should never be persisted)
  if (params && params.__isPreview) {
    console.log('[addConstraint] Ignoring preview constraint:', type, params);
    return false;
  }
  // Check for duplicates
  if (hasConstraint(state.constraints, type, params)) {
    console.log('[addConstraint] Duplicate constraint rejected:', type, params);
    return false;
  }
  // Create validated constraint
  const constraint = createConstraint(type, params);
  if (!constraint) {
    console.warn('[addConstraint] Invalid constraint:', type, params);
    return false;
  }
  console.log('[addConstraint] Adding constraint:', constraint);
  state.constraints.push(constraint);
  return true;
}

function getDist(p1,p2){ return Math.hypot((p1.x-p2.x),(p1.y-p2.y)); }
function projectPointOnSegment(pt,a,b){ const dx=b.x-a.x, dy=b.y-a.y; const L2=dx*dx+dy*dy; if(L2===0) return {x:a.x,y:a.y}; let t=((pt.x-a.x)*dx + (pt.y-a.y)*dy)/L2; t=Math.max(0,Math.min(1,t)); return {x:a.x + t*dx, y: a.y + t*dy}; }
function projectPointOnLine(pt,a,b){ const dx=b.x-a.x, dy=b.y-a.y; const L2=dx*dx+dy*dy; if(L2===0) return {x:a.x,y:a.y}; const t=((pt.x-a.x)*dx + (pt.y-a.y)*dy)/L2; return {x:a.x + t*dx, y: a.y + t*dy}; }

function screenToWorld(svg, screenX, screenY){ 
  const rect = svg.getBoundingClientRect();
  const vb = svg.viewBox.baseVal; 
  // Use the actual rendered size of the SVG
  const scaleX = vb.width / rect.width;
  const scaleY = vb.height / rect.height;
  const localX = screenX - rect.left;
  const localY = screenY - rect.top;
  return { x: vb.x + localX * scaleX, y: vb.y + localY * scaleY }; 
}
function worldToScreen(svg, pt){ 
  const rect = svg.getBoundingClientRect();
  const vb = svg.viewBox.baseVal; 
  const scaleX = rect.width / vb.width;
  const scaleY = rect.height / vb.height;
  const localX = (pt.x - vb.x) * scaleX;
  const localY = (pt.y - vb.y) * scaleY;
  return { x: rect.left + localX, y: rect.top + localY }; 
}

function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

// Rectangle helper: create 4 joints and 4 line shapes from two opposite corners (2-point mode)
// Returns { shapes: [...], constraints: [...] } with H/V constraints on sides
function makeRectFromTwoJoints(joints, j1Id, j3Id, genJ){
	const j1 = joints.get(j1Id), j3 = joints.get(j3Id); if(!j1||!j3) return { shapes: [], constraints: [] };
	const j2Id = genJ(), j4Id = genJ();
	joints.set(j2Id, { x: j3.x, y: j1.y, fixed:false }); // top-right
	joints.set(j4Id, { x: j1.x, y: j3.y, fixed:false }); // bottom-left
	const gid = 'rect_' + Date.now();
	const shapes = [
		{ id: 's'+Date.now()+'_1', type:'line', joints:[j1Id,j2Id], groupId:gid }, // top (horizontal)
		{ id: 's'+Date.now()+'_2', type:'line', joints:[j2Id,j3Id], groupId:gid }, // right (vertical)
		{ id: 's'+Date.now()+'_3', type:'line', joints:[j3Id,j4Id], groupId:gid }, // bottom (horizontal)
		{ id: 's'+Date.now()+'_4', type:'line', joints:[j4Id,j1Id], groupId:gid }  // left (vertical)
	];
	// Add H/V constraints for axis-aligned rectangle
	const constraints = [
		{ type: 'horizontal', joints: [j1Id, j2Id] }, // top
		{ type: 'vertical', joints: [j2Id, j3Id] },   // right
		{ type: 'horizontal', joints: [j3Id, j4Id] }, // bottom
		{ type: 'vertical', joints: [j4Id, j1Id] }    // left
	];
	return { shapes, constraints };
}

// Rectangle from center point and corner (center mode)
function makeRectFromCenter(joints, centerId, cornerId, genJ){
	const center = joints.get(centerId), corner = joints.get(cornerId); if(!center||!corner) return [];
	const dx = corner.x - center.x, dy = corner.y - center.y;
	const j1Id = genJ(), j2Id = genJ(), j3Id = genJ(), j4Id = genJ();
	joints.set(j1Id, { x: center.x - dx, y: center.y - dy, fixed:false }); // top-left
	joints.set(j2Id, { x: center.x + dx, y: center.y - dy, fixed:false }); // top-right
	joints.set(j3Id, { x: center.x + dx, y: center.y + dy, fixed:false }); // bottom-right (corner)
	joints.set(j4Id, { x: center.x - dx, y: center.y + dy, fixed:false }); // bottom-left
	// Remove the corner joint we created temporarily, use j3 position
	joints.delete(cornerId);
	const gid = 'rect_' + Date.now();
	return [ { id: 's'+Date.now()+'_1', type:'line', joints:[j1Id,j2Id], groupId:gid }, { id: 's'+Date.now()+'_2', type:'line', joints:[j2Id,j3Id], groupId:gid }, { id: 's'+Date.now()+'_3', type:'line', joints:[j3Id,j4Id], groupId:gid }, { id: 's'+Date.now()+'_4', type:'line', joints:[j4Id,j1Id], groupId:gid } ];
}

// Rectangle from 3 points: p1-p2 define width edge, p3 defines height
function makeRectFrom3Points(joints, j1Id, j2Id, j3Id, genJ){
	const j1 = joints.get(j1Id), j2 = joints.get(j2Id), j3 = joints.get(j3Id); if(!j1||!j2||!j3) return [];
	// Vector from j1 to j2 (width direction)
	const dx = j2.x - j1.x, dy = j2.y - j1.y;
	const len = Math.hypot(dx, dy); if(len < 0.001) return [];
	// Unit perpendicular vector
	const px = -dy/len, py = dx/len;
	// Project j3 onto perpendicular to get height
	const h = (j3.x - j1.x) * px + (j3.y - j1.y) * py;
	// Create 4th corner
	const j4Id = genJ();
	joints.set(j4Id, { x: j1.x + px * h, y: j1.y + py * h, fixed:false });
	// Update j3 to be proper corner
	j3.x = j2.x + px * h;
	j3.y = j2.y + py * h;
	const gid = 'rect_' + Date.now();
	return [ { id: 's'+Date.now()+'_1', type:'line', joints:[j1Id,j2Id], groupId:gid }, { id: 's'+Date.now()+'_2', type:'line', joints:[j2Id,j3Id], groupId:gid }, { id: 's'+Date.now()+'_3', type:'line', joints:[j3Id,j4Id], groupId:gid }, { id: 's'+Date.now()+'_4', type:'line', joints:[j4Id,j1Id], groupId:gid } ];
}


// ---- 2-solver.js (inlined) ----

// Iterative relaxation solver; mutates joint positions in-place
function solveConstraints(joints, shapes, constraints, iter=20){
  for(let k=0;k<iter;k++){
    for(const c of constraints){
      if(c.type==='coincident'){
        const a=joints.get(c.joints[0]), b=joints.get(c.joints[1]); if(!a||!b) continue;
        const mx=(a.x+b.x)/2, my=(a.y+b.y)/2; if(!a.fixed){ a.x=mx; a.y=my; } if(!b.fixed){ b.x=mx; b.y=my; }
      }
      else if(c.type==='horizontal'){
        const a=joints.get(c.joints[0]), b=joints.get(c.joints[1]); if(!a||!b) continue; const my=(a.y+b.y)/2; if(!a.fixed) a.y=my; if(!b.fixed) b.y=my;
      }
      else if(c.type==='vertical'){
        const a=joints.get(c.joints[0]), b=joints.get(c.joints[1]); if(!a||!b) continue; const mx=(a.x+b.x)/2; if(!a.fixed) a.x=mx; if(!b.fixed) b.x=mx;
      }
      else if(c.type==='distance'){
        const a=joints.get(c.joints[0]), b=joints.get(c.joints[1]); if(!a||!b) continue; const dx=b.x-a.x, dy=b.y-a.y; let d=Math.hypot(dx,dy); if(d<1e-6) continue; const target=c.value; const err=(d-target)/d*0.5; if(!a.fixed){ a.x+=dx*err; a.y+=dy*err; } if(!b.fixed){ b.x-=dx*err; b.y-=dy*err; }
      }
      else if(c.type==='parallel' || c.type==='perpendicular'){
        // Handle both shape-based (newer) and joint-based (legacy) constraints
        let a, b, p, q;
        
        if(c.shapes && c.shapes.length >= 2){
          // Shape-based: find joints from shape IDs
          const s1 = shapes.find(s => s.id === c.shapes[0]);
          const s2 = shapes.find(s => s.id === c.shapes[1]);
          if(!s1 || !s2 || !s1.joints || !s2.joints || s1.joints.length < 2 || s2.joints.length < 2) continue;
          a = joints.get(s1.joints[0]);
          b = joints.get(s1.joints[1]);
          p = joints.get(s2.joints[0]);
          q = joints.get(s2.joints[1]);
        } else if(c.joints && c.joints.length >= 4){
          // Joint-based (legacy)
          a = joints.get(c.joints[0]);
          b = joints.get(c.joints[1]);
          p = joints.get(c.joints[2]);
          q = joints.get(c.joints[3]);
        } else {
          continue;
        }
        
        if(!a||!b||!p||!q) continue;
        const refAng=Math.atan2(b.y-a.y,b.x-a.x); 
        let targetAng;
        if(c.type==='parallel'){
          targetAng = refAng;
        } else {
          // Perpendicular: choose +90Â° or -90Â° based on which is closer to current angle
          const currentAng = Math.atan2(q.y-p.y, q.x-p.x);
          const option1 = refAng + Math.PI/2;
          const option2 = refAng - Math.PI/2;
          // Normalize angle differences to [-Ï€, Ï€]
          const diff1 = Math.atan2(Math.sin(option1 - currentAng), Math.cos(option1 - currentAng));
          const diff2 = Math.atan2(Math.sin(option2 - currentAng), Math.cos(option2 - currentAng));
          targetAng = Math.abs(diff1) < Math.abs(diff2) ? option1 : option2;
        }
        const len=Math.hypot(q.x-p.x,q.y-p.y)||1; const cx=(p.x+q.x)/2, cy=(p.y+q.y)/2; if(!p.fixed){ p.x = cx - Math.cos(targetAng)*len*0.5; p.y = cy - Math.sin(targetAng)*len*0.5; } if(!q.fixed){ q.x = cx + Math.cos(targetAng)*len*0.5; q.y = cy + Math.sin(targetAng)*len*0.5; }
      }
      else if(c.type==='pointOnLine'){
        // Project point onto line
        const shape = shapes.find(s => s.id === c.shape);
        if(!shape || !shape.joints || shape.joints.length < 2) continue;
        const pt = joints.get(c.joint);
        const a = joints.get(shape.joints[0]), b = joints.get(shape.joints[1]);
        if(!pt || !a || !b) continue;
        if(pt.fixed) continue;
        const proj = projectPointOnSegment(pt, a, b);
        // Move point toward projection
        pt.x = pt.x + (proj.x - pt.x) * 0.5;
        pt.y = pt.y + (proj.y - pt.y) * 0.5;
      }
      else if(c.type==='collinear'){
        // Forces 3 or more joints to lie on the same line
        if(!c.joints || c.joints.length < 3) continue;
        const pts = c.joints.map(id => joints.get(id)).filter(j => j);
        if(pts.length < 3) continue;
        
        // Use first two points to define the line
        const p0 = pts[0], p1 = pts[1];
        const dx = p1.x - p0.x, dy = p1.y - p0.y;
        const len = Math.hypot(dx, dy);
        if(len < 1e-6) continue;
        
        // Project remaining points onto the line defined by p0-p1
        for(let i = 2; i < pts.length; i++){
          const pt = pts[i];
          if(pt.fixed) continue;
          const proj = projectPointOnLine(pt, p0, p1);
          pt.x = pt.x + (proj.x - pt.x) * 0.5;
          pt.y = pt.y + (proj.y - pt.y) * 0.5;
        }
      }
      else if(c.type==='tangent'){
        // Line tangent to circle
        if(!c.line || !c.circle) continue;
        const lineShape = shapes.find(s => s.id === c.line);
        const circleShape = shapes.find(s => s.id === c.circle);
        if(!lineShape || !circleShape || lineShape.type !== 'line' || circleShape.type !== 'circle') continue;
        
        const a = joints.get(lineShape.joints[0]);
        const b = joints.get(lineShape.joints[1]);
        const center = joints.get(circleShape.joints[0]);
        const radiusPt = joints.get(circleShape.joints[1]);
        if(!a || !b || !center || !radiusPt) continue;
        
        const radius = getDist(center, radiusPt);
        // Project center onto line and ensure distance equals radius
        const proj = projectPointOnSegment(center, a, b);
        const dist = getDist(center, proj);
        const error = dist - radius;
        
        if(Math.abs(error) > 1e-3){
          // Move line points perpendicular to line to adjust distance
          const dx = b.x - a.x, dy = b.y - a.y;
          const lineLen = Math.hypot(dx, dy);
          if(lineLen < 1e-6) continue;
          const nx = -dy / lineLen, ny = dx / lineLen; // Normal vector
          const adjust = error * 0.5;
          if(!a.fixed){ a.x += nx * adjust; a.y += ny * adjust; }
          if(!b.fixed){ b.x += nx * adjust; b.y += ny * adjust; }
        }
      }
    }
  }
}


// ---- 3-snap.js (inlined) ----


function hitJointAtScreen(joints, svg, screenX, screenY, threshold=14){
  let best=null, bestD=threshold;
  for(const [id,j] of joints.entries()){ const s = worldToScreen(svg, j); const d = Math.hypot(s.x - screenX, s.y - screenY); if(d < bestD){ bestD = d; best = { id, j }; } }
  return best;
}

// Find line at screen position
function hitLineAtScreen(joints, shapes, svg, screenX, screenY, threshold=8){
  const w = screenToWorld(svg, screenX, screenY);
  let best = null, bestD = threshold;
  for(const s of shapes){
    if(s.type === 'line'){
      const a = joints.get(s.joints[0]), b = joints.get(s.joints[1]);
      if(!a || !b) continue;
      const proj = projectPointOnSegment(w, a, b);
      const sc = worldToScreen(svg, proj);
      const d = Math.hypot(sc.x - screenX, sc.y - screenY);
      if(d < bestD){ bestD = d; best = { shape: s, pt: proj }; }
    }
  }
  return best;
}

// Find circle at screen position (closest point on circumference)
function hitCircleAtScreen(joints, shapes, svg, screenX, screenY, threshold=10){
  const w = screenToWorld(svg, screenX, screenY);
  let best = null, bestD = threshold;
  for(const s of shapes){
    if(s.type === 'circle'){
      const center = joints.get(s.joints[0]);
      const edge = joints.get(s.joints[1]);
      if(!center || !edge) continue;
      const radius = Math.hypot(edge.x - center.x, edge.y - center.y);
      if(radius <= 1e-6) continue;
      // Project mouse onto circle along radial direction
      const vx = w.x - center.x, vy = w.y - center.y;
      const vlen = Math.hypot(vx, vy);
      const onCirc = vlen > 0 ? { x: center.x + vx * (radius / vlen), y: center.y + vy * (radius / vlen) } : { x: center.x + radius, y: center.y };
      const sc = worldToScreen(svg, onCirc);
      const d = Math.hypot(sc.x - screenX, sc.y - screenY);
      if(d < bestD){ bestD = d; best = { shape: s, pt: onCirc }; }
    }
  }
  return best;
}

// Find all joints in same coincident cluster
function findCoincidentCluster(jointId, constraints){
  const cluster = new Set([jointId]);
  let changed = true;
  while(changed){
    changed = false;
    for(const c of constraints){
      if(c.type === 'coincident'){
        const [j1, j2] = c.joints;
        if(cluster.has(j1) && !cluster.has(j2)){ cluster.add(j2); changed = true; }
        if(cluster.has(j2) && !cluster.has(j1)){ cluster.add(j1); changed = true; }
      }
    }
  }
  return cluster;
}

function findSnap(joints, shapes, svg, lastMouse, excludeIds=[], excludeLineSnap=false, useInferenceTolerance=false){
  if(!lastMouse) return null;
  // Use tighter tolerance for inference snaps on points
  const pointThreshold = useInferenceTolerance ? INFERENCE_SNAP_PX : SNAP_PX;
  // Normalize excludeIds to array
  const excluded = Array.isArray(excludeIds) ? excludeIds : (excludeIds ? [excludeIds] : []);
  let best=null; let bestDist=pointThreshold;
  // Always check joint snapping first (higher priority)
  for(const [id,j] of joints.entries()){ 
    if(excluded.includes(id)) continue;
    const s=worldToScreen(svg,j); 
    const d=Math.hypot(s.x-lastMouse.x,s.y-lastMouse.y); 
    if(d<bestDist){ bestDist=d; best={type:'joint',id,pt:{x:j.x,y:j.y}}; } 
  }
  // If joint was found, return it immediately - joints have absolute priority
  if(best && best.type === 'joint'){
    return best;
  }
  // Only check line snapping if not excluded and no joint snap found
  // Use smaller tolerance for lines so joints have priority
  if(!excludeLineSnap){
    const lineThreshold = LINE_SNAP_PX;
    for(const s of shapes){ 
      if(s.type==='line'){ 
        // Skip lines that contain any excluded joint
        if(s.joints.some(jid => excluded.includes(jid))) continue;
        const a=joints.get(s.joints[0]), b=joints.get(s.joints[1]); 
        if(!a||!b) continue; 
        const vp = projectPointOnSegment(screenToWorld(svg,lastMouse.x,lastMouse.y), a, b); 
        const sc = worldToScreen(svg, vp); 
        const d=Math.hypot(sc.x-lastMouse.x, sc.y-lastMouse.y); 
        if(d<lineThreshold){ bestDist=d; best={type:'line',shape:s,pt:vp}; } 
      } 
    }
  }
  return best;
}

// Find inference hints (horizontal, vertical, perpendicular) for line drawing
// Returns {type: 'horizontal'|'vertical'|'perpendicular', pt: {x,y}, refLine?: shape}
function findInference(startPt, endPt, shapes, joints, snapTarget){
  if(!startPt || !endPt) return null;
  
  const ANGLE_THRESHOLD = 5; // degrees tolerance for snapping to horizontal/vertical/perpendicular
  const dx = endPt.x - startPt.x;
  const dy = endPt.y - startPt.y;
  const len = Math.hypot(dx, dy);
  if(len < 0.1) return null; // Too short to infer direction
  
  const angle = Math.atan2(dy, dx) * 180 / Math.PI;
  
  // Check horizontal (0Â° or Â±180Â°)
  const horizontalDiff = Math.min(Math.abs(angle), Math.abs(Math.abs(angle) - 180));
  if(horizontalDiff < ANGLE_THRESHOLD){
    return { type: 'horizontal', pt: { x: endPt.x, y: startPt.y } };
  }
  
  // Check vertical (Â±90Â°)
  const verticalDiff = Math.abs(Math.abs(angle) - 90);
  if(verticalDiff < ANGLE_THRESHOLD){
    return { type: 'vertical', pt: { x: startPt.x, y: endPt.y } };
  }
  
  // Check perpendicular to other lines
  // Find reference line: either the line we're snapping to, or the last drawn line
  let refLine = null;
  
  // Priority 1: If snapping to a line, use that
  if(snapTarget && snapTarget.type === 'line'){
    refLine = snapTarget.shape;
  }
  
  // Priority 2: Find most recent line that shares the start point
  if(!refLine){
    for(let i = shapes.length - 1; i >= 0; i--){
      const s = shapes[i];
      if(s.type === 'line'){
        const j1 = s.joints[0];
        const j2 = s.joints[1];
        // Check if this line connects to our start point
        const a = joints.get(j1);
        const b = joints.get(j2);
        if(!a || !b) continue;
        
        // Check if start point is at either end of this line
        const distToA = Math.hypot(startPt.x - a.x, startPt.y - a.y);
        const distToB = Math.hypot(startPt.x - b.x, startPt.y - b.y);
        if(distToA < 0.1 || distToB < 0.1){
          refLine = s;
          break;
        }
      }
    }
  }
  
  // Check perpendicularity to reference line
  if(refLine && refLine.type === 'line'){
    const ra = joints.get(refLine.joints[0]);
    const rb = joints.get(refLine.joints[1]);
    if(ra && rb){
      const rdx = rb.x - ra.x;
      const rdy = rb.y - ra.y;
      const rlen = Math.hypot(rdx, rdy);
      if(rlen > 0.1){
        const refAngle = Math.atan2(rdy, rdx) * 180 / Math.PI;
        const perpAngle1 = refAngle + 90;
        const perpAngle2 = refAngle - 90;
        
        // Normalize angles to -180 to 180
        const normAngle = ((angle % 360) + 540) % 360 - 180;
        const normPerp1 = ((perpAngle1 % 360) + 540) % 360 - 180;
        const normPerp2 = ((perpAngle2 % 360) + 540) % 360 - 180;
        
        const perpDiff1 = Math.abs(normAngle - normPerp1);
        const perpDiff2 = Math.abs(normAngle - normPerp2);
        const minPerpDiff = Math.min(perpDiff1, perpDiff2);
        
        if(minPerpDiff < ANGLE_THRESHOLD){
          // Calculate the perpendicular end point
          const perpAngleRad = (perpDiff1 < perpDiff2 ? perpAngle1 : perpAngle2) * Math.PI / 180;
          const perpPt = {
            x: startPt.x + len * Math.cos(perpAngleRad),
            y: startPt.y + len * Math.sin(perpAngleRad)
          };
          return { type: 'perpendicular', pt: perpPt, refLine };
        }
      }
    }
  }
  
  return null;
}


// ---- 4-render.js (inlined) ----

function draw(joints, shapes, svg, active, snapTarget, constraints=[], selectedJoints=new Set(), selectedConstraint=null, currentTool=null, inference=null, selectedShape=null, hoveredShape=null, hoveredJoint=null, hoveredConstraint=null){ 
  // Toggle snapping class for background color change
  if(snapTarget) svg.classList.add('snapping'); else svg.classList.remove('snapping');
  svg.innerHTML=''; 
  // Calculate zoom factor to keep stroke widths constant in screen space
  const vb = svg.viewBox.baseVal;
  const rect = svg.getBoundingClientRect();
  const zoomX = vb.width / rect.width;
  const zoomY = vb.height / rect.height;
  const zoom = Math.max(zoomX, zoomY); // Use larger zoom to ensure visibility
  
  // Base sizes in screen pixels - will be scaled by inverse zoom
  const BASE_LINE_STROKE = 6;
  const BASE_LINE_STROKE_SELECTED = 12;
  const BASE_LINE_STROKE_HOVERED = 18;
  const BASE_JOINT_RADIUS = 18;
  const BASE_JOINT_STROKE = 4;
  const BASE_JOINT_STROKE_SELECTED = 8;
  const BASE_JOINT_STROKE_HOVERED = 12;
  
  // Scale function to convert screen-space sizes to world-space
  const scale = (screenSize) => screenSize * zoom;
  
  // Common glyph sizes used throughout rendering
  const glyphSize = scale(12);
  const hitZoneRadius = scale(20);
  
  // draw grid
  const gridSize = 50;
  const startX = Math.floor(vb.x / gridSize) * gridSize;
  const startY = Math.floor(vb.y / gridSize) * gridSize;
  for(let x = startX; x < vb.x + vb.width; x += gridSize){
    svg.insertAdjacentHTML('beforeend', `<line x1="${x}" y1="${vb.y}" x2="${x}" y2="${vb.y+vb.height}" stroke="#d0d0d0" stroke-width="1" stroke-opacity="0.5"/>`);
  }
  for(let y = startY; y < vb.y + vb.height; y += gridSize){
    svg.insertAdjacentHTML('beforeend', `<line x1="${vb.x}" y1="${y}" x2="${vb.x+vb.width}" y2="${y}" stroke="#d0d0d0" stroke-width="1" stroke-opacity="0.5"/>`);
  }
  
  // Draw origin axes with zoom-scaled stroke
  const originStroke = scale(1.5);
  // X axis (horizontal, red)
  svg.insertAdjacentHTML('beforeend', `<line x1="${vb.x}" y1="0" x2="${vb.x+vb.width}" y2="0" stroke="#ef4444" stroke-width="${originStroke}" stroke-opacity="0.6"/>`);
  // Y axis (vertical, green)  
  svg.insertAdjacentHTML('beforeend', `<line x1="0" y1="${vb.y}" x2="0" y2="${vb.y+vb.height}" stroke="#22c55e" stroke-width="${originStroke}" stroke-opacity="0.6"/>`);
  
  // If a constraint object has an explicit __selected flag but selectedConstraint argument is null,
  // prefer the flagged one so rendering can show selection reliably.
  if(!selectedConstraint){
    selectedConstraint = constraints.find(c => c && c.__selected) || null;
  } else if(selectedConstraint && !selectedConstraint.__selected){
    // Keep the flag in sync with the passed selectedConstraint
    selectedConstraint.__selected = true;
  }

  // Determine which joints and shapes are part of the selected constraint (for highlighting)
  let constraintJoints = new Set();
  let constraintShapes = new Set();
  if(selectedConstraint){
    if(selectedConstraint.type === 'coincident' && selectedConstraint.joints){
      // Coincident: highlight the joints and all shapes using those joints
      for(const jid of selectedConstraint.joints){
        constraintJoints.add(jid);
      }
      for(const s of shapes){
        if(s.joints && s.joints.some(jid => constraintJoints.has(jid))){
          constraintShapes.add(s.id);
        }
      }
    } else if((selectedConstraint.type === 'horizontal' || selectedConstraint.type === 'vertical') && selectedConstraint.joints){
      // H/V: highlight the two joints and shapes using them
      for(const jid of selectedConstraint.joints){
        constraintJoints.add(jid);
      }
      for(const s of shapes){
        if(s.joints && s.joints.some(jid => constraintJoints.has(jid))){
          constraintShapes.add(s.id);
        }
      }
    } else if((selectedConstraint.type === 'parallel' || selectedConstraint.type === 'perpendicular') && selectedConstraint.shapes){
      // Parallel/Perpendicular: highlight the two shapes
      for(const sid of selectedConstraint.shapes){
        constraintShapes.add(sid);
      }
    } else if(selectedConstraint.type === 'collinear' && selectedConstraint.joints){
      // Collinear: highlight all three joints and shapes using them
      for(const jid of selectedConstraint.joints){
        constraintJoints.add(jid);
      }
      for(const s of shapes){
        if(s.joints && s.joints.some(jid => constraintJoints.has(jid))){
          constraintShapes.add(s.id);
        }
      }
    } else if(selectedConstraint.type === 'tangent'){
      // Tangent: highlight the line shape and circle shape
      if(selectedConstraint.line) constraintShapes.add(selectedConstraint.line);
      if(selectedConstraint.circle) constraintShapes.add(selectedConstraint.circle);
    } else if(selectedConstraint.type === 'pointOnLine'){
      // Point-on-line: highlight the joint and the line shape
      if(selectedConstraint.joint) constraintJoints.add(selectedConstraint.joint);
      if(selectedConstraint.shape) constraintShapes.add(selectedConstraint.shape);
    } else if(selectedConstraint.type === 'distance' && selectedConstraint.joints){
      // Distance: highlight the two joints and shapes using them
      for(const jid of selectedConstraint.joints){
        constraintJoints.add(jid);
      }
      for(const s of shapes){
        if(s.joints && s.joints.some(jid => constraintJoints.has(jid))){
          constraintShapes.add(s.id);
        }
      }
    }
  }
  
  // draw shapes (clickable for selection)
  for(const s of shapes){ 
    const isSelected = selectedShape && selectedShape.id === s.id;
    const isHovered = hoveredShape && hoveredShape.id === s.id;
    const isConstraintPart = constraintShapes.has(s.id);
    
    let strokeWidth = scale(BASE_LINE_STROKE);
    let strokeColor = '#2563eb'; // base blue
    
    if(isConstraintPart){
      // Highlight shapes that are part of selected constraint
      strokeWidth = scale(BASE_LINE_STROKE_SELECTED);
      strokeColor = '#ef4444'; // red highlight
    } else if(isHovered){
      strokeWidth = scale(BASE_LINE_STROKE_HOVERED);
      strokeColor = '#1e40af'; // darker blue
    } else if(isSelected){
      strokeWidth = scale(BASE_LINE_STROKE_SELECTED);
      strokeColor = '#1e40af'; // darker blue
    }
    
    if(s.type==='line'){ 
      const a=joints.get(s.joints[0]), b=joints.get(s.joints[1]); 
      if(a && b) svg.insertAdjacentHTML('beforeend', `<line class="shape-elem" data-shape-id="${s.id}" x1="${a.x}" y1="${a.y}" x2="${b.x}" y2="${b.y}" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-linecap="round" style="cursor:pointer"/>`); 
    } else if(s.type==='circle'){ 
      const c=joints.get(s.joints[0]), p=joints.get(s.joints[1]); 
      if(c && p){ const r=Math.hypot(p.x-c.x,p.y-c.y); svg.insertAdjacentHTML('beforeend', `<circle class="shape-elem" data-shape-id="${s.id}" cx="${c.x}" cy="${c.y}" r="${r}" fill="none" stroke="${strokeColor}" stroke-width="${strokeWidth}" style="cursor:pointer"/>`); }
    } 
  }
  
  // Draw preview constraint glyph when setting up a constraint
  if(active && active.mode){
    const constraintModes = ['coincident', 'parallel', 'perp', 'hv', 'collinear', 'tangent'];
    if(constraintModes.includes(active.mode)){
      // Show preview glyph at first selected element
      if(active.mode === 'coincident' && active.j1){
        const j1 = joints.get(active.j1);
        if(j1){
          const offset = scale(10);
          const x = j1.x + offset, y = j1.y - offset;
          const previewC = { type: 'coincident', joints: [active.j1, active.j1], __isPreview: true, __pos: { x, y } };
          drawConstraintGlyph(svg, previewC);
        }
      } else if(active.mode === 'parallel' && active.shape1){
        const shape = shapes.find(s => s.id === active.shape1);
        if(shape && shape.joints){
          const a = joints.get(shape.joints[0]), b = joints.get(shape.joints[1]);
          if(a && b){
            const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
            const dx = b.x - a.x, dy = b.y - a.y;
            const len = Math.hypot(dx, dy);
            const nx = len > 0 ? -dy / len : 0;
            const ny = len > 0 ? dx / len : 1;
            const offset = scale(10);
            const gx = mx + nx * offset, gy = my + ny * offset;
            const previewC = { type: 'parallel', shapes: [active.shape1, active.shape1], __isPreview: true, __pos: { x: gx, y: gy } };
            drawConstraintGlyph(svg, previewC);
          }
        }
      } else if(active.mode === 'perp' && active.shape1){
        const shape = shapes.find(s => s.id === active.shape1);
        if(shape && shape.joints){
          const a = joints.get(shape.joints[0]), b = joints.get(shape.joints[1]);
          if(a && b){
            const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
            const dx = b.x - a.x, dy = b.y - a.y;
            const len = Math.hypot(dx, dy);
            const nx = len > 0 ? -dy / len : 0;
            const ny = len > 0 ? dx / len : 1;
            const offset = scale(10);
            const gx = mx + nx * offset, gy = my + ny * offset;
            const previewC = { type: 'perpendicular', shapes: [active.shape1, active.shape1], __isPreview: true, __pos: { x: gx, y: gy } };
            drawConstraintGlyph(svg, previewC);
          }
        }
      } else if(active.mode === 'hv'){
        // H/V will show on the line being evaluated
      } else if(active.mode === 'collinear' && active.joints && active.joints.length > 0){
        const lastJoint = joints.get(active.joints[active.joints.length - 1]);
        if(lastJoint){
          const offset = scale(10);
          const x = lastJoint.x + offset, y = lastJoint.y - offset;
          const previewC = { type: 'collinear', joints: active.joints.slice(), __isPreview: true, __pos: { x, y } };
          drawConstraintGlyph(svg, previewC);
        }
      } else if(active.mode === 'tangent' && (active.line || active.circle)){
        // Show on line or circle
        if(active.line){
          const shape = shapes.find(s => s.id === active.line);
          if(shape && shape.joints){
            const a = joints.get(shape.joints[0]), b = joints.get(shape.joints[1]);
            if(a && b){
              const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
              const dx = b.x - a.x, dy = b.y - a.y;
              const len = Math.hypot(dx, dy);
              const nx = len > 0 ? -dy / len : 0;
              const ny = len > 0 ? dx / len : 1;
              const offset = scale(10);
              const gx = mx + nx * offset, gy = my + ny * offset;
              const symbolSize = glyphSize * 0.6;
              const bgRadius = glyphSize + scale(5);
              const previewC = { type: 'tangent', line: active.line, circle: active.circle, __isPreview: true, __pos: { x: gx, y: gy } };
              drawConstraintGlyph(svg, previewC);
            }
          }
        }
      }
    }
  }
  
  // draw origin first (underneath everything)
  const origin = joints.get('j_origin');
  if(origin){
    svg.insertAdjacentHTML('beforeend', `<circle cx="${origin.x}" cy="${origin.y}" r="${scale(6)}" fill="#ef4444" style="cursor:pointer"/>`); 
  }
  
  // Check which points are coincident to origin (via constraints, not distance)
  const pointsCoincidentToOrigin = new Set();
  for(const c of constraints){
    if(c.type === 'coincident' && c.joints){
      const [j1, j2] = c.joints;
      if(j1 === 'j_origin') pointsCoincidentToOrigin.add(j2);
      if(j2 === 'j_origin') pointsCoincidentToOrigin.add(j1);
    }
  }
  
  // draw joints
  const pointsAtOrigin = [];
  
  for(const [id,j] of joints.entries()){ 
    if(id === 'j_origin') continue; // Skip origin, already drawn
    const isSelected = selectedJoints.has(id);
    const isHovered = hoveredJoint && hoveredJoint.id === id;
    const isConstraintPart = constraintJoints.has(id);
    
    // Draw regular point styling with zoom-scaled sizes
    const r = scale(BASE_JOINT_RADIUS);
    const fill = 'white';
    let stroke = '#2563eb'; // base blue
    let strokeW = scale(BASE_JOINT_STROKE); // base
    
    if(isConstraintPart){
      // Highlight joints that are part of selected constraint
      stroke = '#ef4444'; // red highlight
      strokeW = scale(BASE_JOINT_STROKE_SELECTED);
    } else if(isHovered){
      stroke = '#1e40af'; // darker blue
      strokeW = scale(BASE_JOINT_STROKE_HOVERED);
    } else if(isSelected){
      stroke = '#1e40af'; // darker blue
      strokeW = scale(BASE_JOINT_STROKE_SELECTED);
    }
    svg.insertAdjacentHTML('beforeend', `<circle cx="${j.x}" cy="${j.y}" r="${r}" fill="${fill}" stroke="${stroke}" stroke-width="${strokeW}" style="cursor:pointer"/>`);
    
    // Show snap ring feedback when hovered (unified with active snap target visual)
    if(isHovered){
      svg.insertAdjacentHTML('beforeend', `<circle cx="${j.x}" cy="${j.y}" r="${scale(32)}" fill="#2563eb" fill-opacity="0.15" stroke="none"/>`);
      svg.insertAdjacentHTML('beforeend', `<circle cx="${j.x}" cy="${j.y}" r="${scale(24)}" fill="none" stroke="#2563eb" stroke-width="${scale(3)}"/>`);
    }
    
    // Track if coincident to origin for later overlay
    if(pointsCoincidentToOrigin.has(id)){
      pointsAtOrigin.push(j);
    }
  }
  
  // Draw red overlay circles for points coincident to origin (on top)
  for(const j of pointsAtOrigin){
    svg.insertAdjacentHTML('beforeend', `<circle cx="${j.x}" cy="${j.y}" r="${scale(8)}" fill="#ef4444" style="cursor:pointer; pointer-events:none;"/>`); 
  }
  // draw preview
  if(active && active.preview){ 
    const a=joints.get(active.start);
    if(a){
      const p=active.preview.pt;
      if(active.preview.type==='line'){ 
        svg.insertAdjacentHTML('beforeend', `<line x1="${a.x}" y1="${a.y}" x2="${p.x}" y2="${p.y}" stroke="#10b981" stroke-width="2" stroke-dasharray="6"/>`); 
      } else if(active.preview.type==='circle'){
        const r = Math.hypot(p.x-a.x, p.y-a.y);
        svg.insertAdjacentHTML('beforeend', `<circle cx="${a.x}" cy="${a.y}" r="${r}" fill="none" stroke="#10b981" stroke-width="2" stroke-dasharray="6"/>`);
      } else if(active.preview.type==='rect'){
        svg.insertAdjacentHTML('beforeend', `<rect x="${Math.min(a.x,p.x)}" y="${Math.min(a.y,p.y)}" width="${Math.abs(p.x-a.x)}" height="${Math.abs(p.y-a.y)}" fill="none" stroke="#10b981" stroke-width="2" stroke-dasharray="6"/>`);
      } else if(active.preview.type==='rect-center'){
        // Center point rect preview: a is center, p is corner
        const dx = p.x - a.x, dy = p.y - a.y;
        svg.insertAdjacentHTML('beforeend', `<rect x="${a.x-dx}" y="${a.y-dy}" width="${Math.abs(dx)*2}" height="${Math.abs(dy)*2}" fill="none" stroke="#10b981" stroke-width="2" stroke-dasharray="6"/>`);
        // Show center marker
        svg.insertAdjacentHTML('beforeend', `<circle cx="${a.x}" cy="${a.y}" r="4" fill="#10b981" fill-opacity="0.5"/>`);
      } else if(active.preview.type==='rect-3pt'){
        // 3-point rect: show the first edge being defined
        const b = active.secondPt ? joints.get(active.secondPt) : null;
        if(b){
          // Have 2 points, show projected rectangle
          const dx = b.x - a.x, dy = b.y - a.y;
          const len = Math.hypot(dx, dy); if(len > 0.001){
            const px = -dy/len, py = dx/len;
            const h = (p.x - a.x) * px + (p.y - a.y) * py;
            const c3 = { x: b.x + px * h, y: b.y + py * h };
            const c4 = { x: a.x + px * h, y: a.y + py * h };
            svg.insertAdjacentHTML('beforeend', `<polygon points="${a.x},${a.y} ${b.x},${b.y} ${c3.x},${c3.y} ${c4.x},${c4.y}" fill="none" stroke="#10b981" stroke-width="2" stroke-dasharray="6"/>`);
          }
        } else {
          // Just first edge
          svg.insertAdjacentHTML('beforeend', `<line x1="${a.x}" y1="${a.y}" x2="${p.x}" y2="${p.y}" stroke="#10b981" stroke-width="2" stroke-dasharray="6"/>`);
        }
      }
    }
  }
  
  // Draw dimension preview while dragging
  if(active && (active.mode === 'dim-line' || (active.mode === 'dim-p2p' && active.j2))){
    const j1 = joints.get(active.joints[0]), j2 = joints.get(active.joints[1]);
    if(j1 && j2){
      const mx = (j1.x + j2.x)/2, my = (j1.y + j2.y)/2;
      const dx = j2.x - j1.x, dy = j2.y - j1.y;
      const len = Math.hypot(dx, dy);
      const offset = active.offset || 30;
      const dist = active.value ? active.value.toFixed(1) : len.toFixed(1);
      
      let nx = 0, ny = -1;
      if(len > 0.01){ nx = -dy / len; ny = dx / len; }
      
      const annotX = mx + nx * offset;
      const annotY = my + ny * offset;
      const ext1End = { x: j1.x + nx * offset, y: j1.y + ny * offset };
      const ext2End = { x: j2.x + nx * offset, y: j2.y + ny * offset };
      const ext1Start = { x: j1.x + nx * 5, y: j1.y + ny * 5 };
      const ext2Start = { x: j2.x + nx * 5, y: j2.y + ny * 5 };
      
      // Preview extension lines
      svg.insertAdjacentHTML('beforeend', `<line x1="${ext1Start.x}" y1="${ext1Start.y}" x2="${ext1End.x}" y2="${ext1End.y}" stroke="#10b981" stroke-width="1" stroke-dasharray="4"/>`);
      svg.insertAdjacentHTML('beforeend', `<line x1="${ext2Start.x}" y1="${ext2Start.y}" x2="${ext2End.x}" y2="${ext2End.y}" stroke="#10b981" stroke-width="1" stroke-dasharray="4"/>`);
      // Preview dimension line
      svg.insertAdjacentHTML('beforeend', `<line x1="${ext1End.x}" y1="${ext1End.y}" x2="${ext2End.x}" y2="${ext2End.y}" stroke="#10b981" stroke-width="2" stroke-dasharray="4"/>`);
      // Preview text
      svg.insertAdjacentHTML('beforeend', `<rect x="${annotX - 18}" y="${annotY - 8}" width="36" height="14" fill="#10b981" fill-opacity="0.2" rx="2"/>`);
      svg.insertAdjacentHTML('beforeend', `<text x="${annotX}" y="${annotY + 3}" text-anchor="middle" font-size="11" fill="#10b981" font-weight="bold">${dist}</text>`);
    }
  }
  
  // draw snap indicator - only when actively drawing/dragging, not just hovering
  if(snapTarget && active){ 
    const p=snapTarget.pt;
    const isConstraintTool = ['coincident', 'hv', 'parallel', 'perp', 'collinear', 'tangent'].includes(currentTool);
    
    if(snapTarget.type === 'joint'){
      // Only show joint highlight for tools that can use joints
      const canUseJoint = !isConstraintTool || currentTool === 'coincident';
      if(canUseJoint){
        // Circle indicator for point snap with glow - bigger highlight
        svg.insertAdjacentHTML('beforeend', `<circle cx="${p.x}" cy="${p.y}" r="${scale(32)}" fill="#2563eb" fill-opacity="0.15" stroke="none"/>`);
        svg.insertAdjacentHTML('beforeend', `<circle cx="${p.x}" cy="${p.y}" r="${scale(24)}" fill="none" stroke="#2563eb" stroke-width="${scale(3)}"/>`);
        svg.insertAdjacentHTML('beforeend', `<circle cx="${p.x}" cy="${p.y}" r="${scale(3)}" fill="#2563eb"/>`);;
      }
    } else if(snapTarget.type === 'line'){
      // Highlight the line being snapped to
      const shape = snapTarget.shape;
      if(shape && shape.joints){
        const a = joints.get(shape.joints[0]), b = joints.get(shape.joints[1]);
        if(a && b){
          svg.insertAdjacentHTML('beforeend', `<line x1="${a.x}" y1="${a.y}" x2="${b.x}" y2="${b.y}" stroke="#2563eb" stroke-width="${scale(4)}" stroke-opacity="0.5"/>`);
        }
      }
      // Only show diamond and X for drawing tools, not constraint tools
      if(!isConstraintTool){
        // Diamond indicator for line snap point
        const diamondSize = 6;
        const diamondStroke = scale(2);
        svg.insertAdjacentHTML('beforeend', `<rect x="${p.x-scale(diamondSize)}" y="${p.y-scale(diamondSize)}" width="${scale(diamondSize*2)}" height="${scale(diamondSize*2)}" fill="#2563eb" fill-opacity="0.3" stroke="#2563eb" stroke-width="${diamondStroke}" transform="rotate(45 ${p.x} ${p.y})"/>`);
        // Small X to indicate coincident will be added
        const xSize = 4;
        const xStroke = scale(2);
        svg.insertAdjacentHTML('beforeend', `<line x1="${p.x-scale(xSize)}" y1="${p.y-scale(xSize)}" x2="${p.x+scale(xSize)}" y2="${p.y+scale(xSize)}" stroke="#2563eb" stroke-width="${xStroke}"/>`);
        svg.insertAdjacentHTML('beforeend', `<line x1="${p.x+scale(xSize)}" y1="${p.y-scale(xSize)}" x2="${p.x-scale(xSize)}" y2="${p.y+scale(xSize)}" stroke="#2563eb" stroke-width="${xStroke}"/>`);
      }
    } else {
      // Generic snap indicator
      if(!isConstraintTool){
        const diamondSize = 6;
        const diamondStroke = scale(2);
        svg.insertAdjacentHTML('beforeend', `<rect x="${p.x-scale(diamondSize)}" y="${p.y-scale(diamondSize)}" width="${scale(diamondSize*2)}" height="${scale(diamondSize*2)}" fill="none" stroke="#2563eb" stroke-width="${diamondStroke}" transform="rotate(45 ${p.x} ${p.y})"/>`);
      }
    }
  }
  
  // Draw inference hint (horizontal, vertical, perpendicular)
  if(inference && active && active.start){
    const start = joints.get(active.start);
    if(start){
      const iconSize = scale(20);
      const offset = scale(30);
      const strokeW = scale(2.5);
      const circleR = iconSize / 2;
      const circleStroke = scale(2);
      const mx = (start.x + inference.pt.x) / 2;
      const my = (start.y + inference.pt.y) / 2;
      
      if(inference.type === 'horizontal'){
        // H icon with horizontal line
        svg.insertAdjacentHTML('beforeend', `<g transform="translate(${mx},${my - offset})" opacity="0.8">
          <circle cx="0" cy="0" r="${circleR}" fill="#fbbf24" stroke="#f59e0b" stroke-width="${circleStroke}"/>
          <line x1="-${iconSize/3}" y1="0" x2="${iconSize/3}" y2="0" stroke="white" stroke-width="${strokeW}" stroke-linecap="round"/>
        </g>`);
      } else if(inference.type === 'vertical'){
        // V icon with vertical line
        svg.insertAdjacentHTML('beforeend', `<g transform="translate(${mx + offset},${my})" opacity="0.8">
          <circle cx="0" cy="0" r="${circleR}" fill="#10b981" stroke="#059669" stroke-width="${circleStroke}"/>
          <line x1="0" y1="-${iconSize/3}" x2="0" y2="${iconSize/3}" stroke="white" stroke-width="${strokeW}" stroke-linecap="round"/>
        </g>`);
      } else if(inference.type === 'perpendicular'){
        // Perpendicular icon (âŠ¥ symbol) - purple to match constraint
        svg.insertAdjacentHTML('beforeend', `<g transform="translate(${mx},${my - offset})" opacity="0.8">
          <circle cx="0" cy="0" r="${circleR}" fill="#a855f7" stroke="#7c3aed" stroke-width="${circleStroke}"/>
          <line x1="-${iconSize/3}" y1="${iconSize/4}" x2="${iconSize/3}" y2="${iconSize/4}" stroke="white" stroke-width="${strokeW}" stroke-linecap="round"/>
          <line x1="0" y1="${iconSize/4}" x2="0" y2="-${iconSize/3}" stroke="white" stroke-width="${strokeW}" stroke-linecap="round"/>
        </g>`);
      }
    }
  }
  
  // Draw a single constraint glyph (handles preview visuals when c.__isPreview is set)
  function drawConstraintGlyph(svg, c, opts = {}){
    const preview = !!c.__isPreview || !!opts.isPreview;
    const previewAttr = preview ? ' data-preview="1"' : '';
    const groupStyle = preview ? 'opacity:0.5; pointer-events:none' : 'cursor:pointer';
    // Compose data attributes for hit testing
    let dataAttrs = `data-ctype="${c.type}"`;
    if(c.type === 'coincident' || c.type === 'horizontal' || c.type === 'vertical'){
      if(c.joints && c.joints.length >= 2) dataAttrs += ` data-cj0="${c.joints[0]}" data-cj1="${c.joints[1]}"`;
    } else if(c.type === 'parallel' || c.type === 'perpendicular'){
      if(c.shapes && c.shapes.length >= 2) dataAttrs += ` data-cs0="${c.shapes[0]}" data-cs1="${c.shapes[1]}"`;
    } else if(c.type === 'pointOnLine'){
      if(c.joint && c.shape) dataAttrs += ` data-cjoint="${c.joint}" data-cshape="${c.shape}"`;
    } else if(c.type === 'collinear'){
      if(c.joints) dataAttrs += ` data-cjoints="${c.joints.join(',')}"`;
    } else if(c.type === 'tangent'){
      if(c.line && c.circle) dataAttrs += ` data-cline="${c.line}" data-ccircle="${c.circle}"`;
    }
    const makeGroup = (inner, transform) => {
      const tr = transform ? ` transform="${transform}"` : '';
      svg.insertAdjacentHTML('beforeend', `<g class="constraint-glyph" ${dataAttrs}${previewAttr}${tr} style="${groupStyle}">${inner}</g>`);
    };

    // Compute hover/selection state and dynamic stroke widths here so inner HTML can use them
    const isHoveredGlob = !preview && hoveredConstraint === c;
    const isSelectedGlob = !preview && (selectedConstraint === c || c.__selected);
    // Stronger visual feedback for selection/hover
    const bgStrokeW = (isHoveredGlob || isSelectedGlob) ? scale(7) : scale(3.5);
    const glowColor = (isHoveredGlob || isSelectedGlob) ? '#1e40af' : 'none';
    const glowOpacity = (isHoveredGlob || isSelectedGlob) ? 0.35 : 0;

      if (c.type === 'coincident') {
        // Position offset near one of the coincident joints
        const j1 = (c.joints && joints.get(c.joints[0])) || null; if(!j1) return;
        const offset = scale(10);
        const x = j1.x + offset, y = j1.y - offset;
        const isHovered = !preview && hoveredConstraint === c;
        const isSelected = !preview && (selectedConstraint === c || c.__selected);
        const stroke = (isHovered || isSelected) ? '#1e40af' : '#2563eb';
        const strokeW = (isHovered || isSelected) ? scale(5) : scale(2.5);
        const bgRadius = (isHovered || isSelected) ? glyphSize + scale(10) : glyphSize + scale(5);
        const bgOpacity = (isHovered || isSelected) ? '0.98' : '0.85';
        // Strong glow for selected/hovered
        const glowHtml = (isHovered || isSelected) ? `<circle cx="0" cy="0" r="${bgRadius + scale(10)}" fill="${stroke}" fill-opacity="0.25"/>` : '';
        const symbolSize = glyphSize * 0.6;
        const inner = `<circle cx="0" cy="0" r="${hitZoneRadius}" fill="transparent"/>${glowHtml}<circle cx="0" cy="0" r="${bgRadius}" fill="#ef4444" fill-opacity="${bgOpacity}" stroke="#dc2626" stroke-width="${bgStrokeW}"/><line x1="-${symbolSize}" y1="-${symbolSize}" x2="${symbolSize}" y2="${symbolSize}" stroke="white" stroke-width="${strokeW}"/><line x1="${symbolSize}" y1="-${symbolSize}" x2="-${symbolSize}" y2="${symbolSize}" stroke="white" stroke-width="${strokeW}"/>`;
        makeGroup(inner, `translate(${x},${y})`);
        return;
      }

      if(c.type === 'horizontal') {
        const j1 = joints.get(c.joints[0]), j2 = joints.get(c.joints[1]);
        if(!j1 || !j2) return;
        const mx = (j1.x + j2.x)/2, my = (j1.y + j2.y)/2 + scale(10);
        const isHovered = !preview && hoveredConstraint === c;
        const isSelected = !preview && (selectedConstraint === c || c.__selected);
        const stroke = (isHovered || isSelected) ? '#1e40af' : '#059669';
        const strokeW = (isHovered || isSelected) ? scale(4) : scale(2.5);
        const bgRadius = (isHovered || isSelected) ? glyphSize + scale(8) : glyphSize + scale(5);
        const bgOpacity = (isHovered || isSelected) ? '0.95' : '0.85';
        const bgColor = '#22c55e';
        const glow = (isHovered || isSelected) ? `<circle cx="${mx}" cy="${my}" r="${bgRadius + scale(4)}" fill="${stroke}" fill-opacity="0.15"/>` : '';
        const symbolSize = glyphSize * 0.6;
        const inner = `<circle cx="${mx}" cy="${my}" r="${hitZoneRadius}" fill="transparent"/>${glow}<circle cx="${mx}" cy="${my}" r="${bgRadius}" fill="${bgColor}" fill-opacity="${bgOpacity}" stroke="#15803d" stroke-width="${bgStrokeW}"/><line x1="${mx - symbolSize}" y1="${my}" x2="${mx + symbolSize}" y2="${my}" stroke="white" stroke-width="${strokeW}"/>`;
        makeGroup(inner);
        return;
      }

      if(c.type === 'vertical') {
        const j1 = joints.get(c.joints[0]), j2 = joints.get(c.joints[1]);
        if(!j1 || !j2) return;
        const mx = (j1.x + j2.x)/2 + scale(10), my = (j1.y + j2.y)/2;
        const isHovered = !preview && hoveredConstraint === c;
        const isSelected = !preview && (selectedConstraint === c || c.__selected);
        const strokeW = (isHovered || isSelected) ? scale(4) : scale(2.5);
        const bgRadius = (isHovered || isSelected) ? glyphSize + scale(8) : glyphSize + scale(5);
        const bgOpacity = (isHovered || isSelected) ? '0.95' : '0.85';
        const bgColor = '#22c55e';
        const glow = (isHovered || isSelected) ? `<circle cx="${mx}" cy="${my}" r="${bgRadius + scale(4)}" fill="#1e40af" fill-opacity="0.15"/>` : '';
        const symbolSize = glyphSize * 0.6;
        const inner = `<circle cx="${mx}" cy="${my}" r="${hitZoneRadius}" fill="transparent"/>${glow}<circle cx="${mx}" cy="${my}" r="${bgRadius}" fill="${bgColor}" fill-opacity="${bgOpacity}" stroke="#0369a1" stroke-width="${bgStrokeW}"/><line x1="${mx}" y1="${my - symbolSize}" x2="${mx}" y2="${my + symbolSize}" stroke="white" stroke-width="${strokeW}"/>`;
        makeGroup(inner);
        return;
      }

      if(c.type === 'parallel' || c.type === 'perpendicular') {
        const s1 = shapes.find(s => s.id === c.shapes[0]);
        if(!s1 || !s1.joints) return;
        const j1 = joints.get(s1.joints[0]), j2 = joints.get(s1.joints[1]);
        if(!j1 || !j2) return;
        const mx = (j1.x + j2.x)/2, my = (j1.y + j2.y)/2;
        const dx = j2.x - j1.x, dy = j2.y - j1.y; const len = Math.hypot(dx, dy);
        const nx = len > 0 ? -dy/len : 0; const ny = len > 0 ? dx/len : 1; const offset = scale(10);
        const gx = mx + nx * offset, gy = my + ny * offset;
        const isHovered = !preview && hoveredConstraint === c;
        const isSelected = !preview && (selectedConstraint === c || c.__selected);
        const stroke = (isHovered || isSelected) ? '#1e40af' : (c.type === 'perpendicular' ? '#0891b2' : '#7c3aed');
        const strokeW = (isHovered || isSelected) ? scale(4) : scale(2.5);
        const bgRadius = (isHovered || isSelected) ? glyphSize + scale(8) : glyphSize + scale(5);
        const bgOpacity = (isHovered || isSelected) ? '0.95' : '0.85';
        const bgColor = (c.type === 'perpendicular') ? '#a855f7' : '#3b82f6';
        const glow = (isHovered || isSelected) ? `<circle cx="0" cy="0" r="${bgRadius + scale(4)}" fill="${stroke}" fill-opacity="0.15"/>` : '';
        if(c.type === 'parallel'){
          const symbolSize = glyphSize * 0.6;
          const inner = `<circle cx="0" cy="0" r="${hitZoneRadius}" fill="transparent"/>${glow}<circle cx="0" cy="0" r="${bgRadius}" fill="${bgColor}" fill-opacity="${bgOpacity}" stroke="#ca8a04" stroke-width="${bgStrokeW}"/><line x1="-${symbolSize}" y1="-${symbolSize/3}" x2="${symbolSize}" y2="-${symbolSize/3}" stroke="white" stroke-width="${strokeW}"/><line x1="-${symbolSize}" y1="${symbolSize/3}" x2="${symbolSize}" y2="${symbolSize/3}" stroke="white" stroke-width="${strokeW}"/>`;
          makeGroup(inner, `translate(${gx},${gy})`);
        } else {
          const symbolSize = glyphSize * 0.6;
          const inner = `<circle cx="0" cy="0" r="${hitZoneRadius}" fill="transparent"/>${glow}<circle cx="0" cy="0" r="${bgRadius}" fill="${bgColor}" fill-opacity="${bgOpacity}" stroke="#7c3aed" stroke-width="${bgStrokeW}"/><line x1="-${symbolSize}" y1="${symbolSize}" x2="${symbolSize}" y2="${symbolSize}" stroke="white" stroke-width="${strokeW}"/><line x1="0" y1="${symbolSize}" x2="0" y2="-${symbolSize}" stroke="white" stroke-width="${strokeW}"/>`;
          makeGroup(inner, `translate(${gx},${gy})`);
        }
        return;
      }

      if(c.type === 'pointOnLine') {
        const pt = joints.get(c.joint); if(!pt) return;
        const isHovered = !preview && hoveredConstraint === c;
        const isSelected = !preview && (selectedConstraint === c || c.__selected);
        const strokeW = (isHovered || isSelected) ? scale(2.5) : scale(1.5);
        const bgOpacity = (isHovered || isSelected) ? '0.95' : '0.85';
        const bgColor = '#fb923c';
        const glow = (isHovered || isSelected) ? `<circle cx="0" cy="-${scale(12)}" r="${scale(9)}" fill="#f97316" fill-opacity="0.15"/>` : '';
        const inner = `<circle cx="0" cy="-${scale(12)}" r="${hitZoneRadius}" fill="transparent"/>${glow}<circle cx="0" cy="-${scale(12)}" r="${scale(7)}" fill="${bgColor}" fill-opacity="${bgOpacity}" stroke="#ea580c" stroke-width="${scale(3)}"/><circle cx="0" cy="-${scale(12)}" r="${scale(1.4)}" fill="white"/>`;
        makeGroup(inner, `translate(${pt.x},${pt.y})`);
        return;
      }

      if(c.type === 'collinear') {
        // Allow preview-only position via c.__pos or fall back to middle joint
        let px, py;
        if(c.__pos){ px = c.__pos.x; py = c.__pos.y; }
        else {
          if(!c.joints || c.joints.length < 3) return;
          const midIdx = Math.floor(c.joints.length / 2);
          const midJoint = joints.get(c.joints[midIdx]); if(!midJoint) return;
          px = midJoint.x; py = midJoint.y;
        }
        const isHovered = !preview && hoveredConstraint === c;
        const isSelected = !preview && (selectedConstraint === c || c.__selected);
        const stroke = (isHovered || isSelected) ? '#1e40af' : '#8b5cf6';
        const bgOpacity = (isHovered || isSelected) ? '0.95' : '0.85';
        const bgColor = '#14b8a6';
        const dotSize = scale(2.5); const spacing = scale(5);
        const glow = (isHovered || isSelected) ? `<circle cx="0" cy="-${scale(12)}" r="${glyphSize + scale(4)}" fill="${stroke}" fill-opacity="0.15"/>` : '';
        const inner = `<circle cx="0" cy="-${scale(12)}" r="${hitZoneRadius}" fill="transparent"/>${glow}<circle cx="0" cy="-${scale(12)}" r="${glyphSize + scale(5)}" fill="${bgColor}" fill-opacity="${bgOpacity}" stroke="#0d9488" stroke-width="${scale(3.5)}"/><circle cx="${-spacing}" cy="-${scale(12)}" r="${dotSize * 0.6}" fill="white"/><circle cx="0" cy="-${scale(12)}" r="${dotSize * 0.6}" fill="white"/><circle cx="${spacing}" cy="-${scale(12)}" r="${dotSize * 0.6}" fill="white"/>`;
        makeGroup(inner, `translate(${px},${py})`);
        return;
      }

      if(c.type === 'tangent') {
        const lineShape = shapes.find(s => s.id === c.line); const circleShape = shapes.find(s => s.id === c.circle);
        if(!lineShape || !circleShape || !lineShape.joints || !circleShape.joints) return;
        const la = joints.get(lineShape.joints[0]); const lb = joints.get(lineShape.joints[1]); const center = joints.get(circleShape.joints[0]);
        if(!la || !lb || !center) return;
        const mx = (la.x + lb.x) / 2, my = (la.y + lb.y) / 2;
        const dx = lb.x - la.x, dy = lb.y - la.y; const len = Math.hypot(dx, dy);
        const nx = len > 0 ? -dy/len : 0; const ny = len > 0 ? dx/len : 1; const offset = scale(10);
        const gx = mx + nx * offset, gy = my + ny * offset;
        const isHovered = !preview && hoveredConstraint === c;
        const isSelected = !preview && (selectedConstraint === c || c.__selected);
        const bgOpacity = (isHovered || isSelected) ? '0.95' : '0.85';
        const bgColor = '#fbbf24';
        const glow = (isHovered || isSelected) ? `<circle cx="0" cy="0" r="${glyphSize + scale(4)}" fill="#1e40af" fill-opacity="0.15"/>` : '';
        const symbolSize = glyphSize * 0.6;
        const inner = `<circle cx="0" cy="0" r="${hitZoneRadius}" fill="transparent"/>${glow}<circle cx="0" cy="0" r="${glyphSize + scale(5)}" fill="${bgColor}" fill-opacity="${bgOpacity}" stroke="white" stroke-width="${bgStrokeW}"/><circle cx="0" cy="-${scale(3)}" r="${scale(3.5)}" fill="none" stroke="white" stroke-width="${scale(2)}"/><line x1="-${symbolSize}" y1="${scale(6)}" x2="${symbolSize}" y2="${scale(6)}" stroke="white" stroke-width="${scale(2)}"/>`;
        makeGroup(inner, `translate(${gx},${gy})`);
        return;
      }
  }

  // CONSTRAINT GLYPHS - Rendered last so they appear on top of everything
  // glyphSize and hitZoneRadius already defined at top of function
  for(const c of constraints){
    if(c.type === 'coincident' && c.joints && c.joints.length >= 2){
      // Show one glyph per coincident constraint when any of its joints are selected
      const isRelated = c.joints.some(jid => selectedJoints.has(jid)) || selectedConstraint === c || c.__selected;
      if(!isRelated) continue;
      drawConstraintGlyph(svg, c);
    } else if(c.type === 'horizontal' && c.joints && c.joints.length >= 2){
      // Horizontal line glyph at midpoint - offset perpendicular (downward)
      const j1 = joints.get(c.joints[0]), j2 = joints.get(c.joints[1]);
      if(j1 && j2){
        const mx = (j1.x + j2.x)/2, my = (j1.y + j2.y)/2 + scale(10); // perpendicular offset
        const isHovered = hoveredConstraint === c;
        const isSelected = (selectedConstraint === c || c.__selected);
        const stroke = (isHovered || isSelected) ? '#1e40af' : '#059669';
        const strokeW = (isHovered || isSelected) ? scale(4) : scale(2.5);
        const bgRadius = (isHovered || isSelected) ? glyphSize + scale(8) : glyphSize + scale(5);
        const bgOpacity = (isHovered || isSelected) ? '0.95' : '0.85';
        const bgColor = '#22c55e'; // green for horizontal
        const glow = (isHovered || isSelected) ? `<circle cx="${mx}" cy="${my}" r="${bgRadius + scale(4)}" fill="${stroke}" fill-opacity="0.15"/>` : '';
        const symbolSize = glyphSize * 0.6; // Smaller symbols
        drawConstraintGlyph(svg, c);
      }
    } else if(c.type === 'vertical' && c.joints && c.joints.length >= 2){
      // Vertical line glyph at midpoint - offset perpendicular (rightward)
      const j1 = joints.get(c.joints[0]), j2 = joints.get(c.joints[1]);
      if(j1 && j2){
        const mx = (j1.x + j2.x)/2 + scale(10), my = (j1.y + j2.y)/2; // perpendicular offset
        const isHovered = hoveredConstraint === c;
        const isSelected = (selectedConstraint === c || c.__selected);
        const stroke = (isHovered || isSelected) ? '#1e40af' : '#059669';
        const strokeW = (isHovered || isSelected) ? scale(4) : scale(2.5);
        const bgRadius = (isHovered || isSelected) ? glyphSize + scale(8) : glyphSize + scale(5);
        const bgOpacity = (isHovered || isSelected) ? '0.95' : '0.85';
        const bgColor = '#22c55e'; // green for vertical
        const glow = (isHovered || isSelected) ? `<circle cx="${mx}" cy="${my}" r="${bgRadius + scale(4)}" fill="${stroke}" fill-opacity="0.15"/>` : '';
        const symbolSize = glyphSize * 0.6; // Smaller symbols
        drawConstraintGlyph(svg, c);
      }
    } else if(c.type === 'parallel' && c.shapes && c.shapes.length >= 2){
      // Double diagonal lines at midpoint of first shape - offset perpendicular to line
      const s1 = shapes.find(s => s.id === c.shapes[0]);
      if(s1 && s1.joints){
        const j1 = joints.get(s1.joints[0]), j2 = joints.get(s1.joints[1]);
        if(j1 && j2){
          const mx = (j1.x + j2.x)/2, my = (j1.y + j2.y)/2;
          // Calculate perpendicular direction
          const dx = j2.x - j1.x, dy = j2.y - j1.y;
          const len = Math.hypot(dx, dy);
          const nx = len > 0 ? -dy/len : 0; // perpendicular x
          const ny = len > 0 ? dx/len : 1;  // perpendicular y
          const offset = scale(10);
          const gx = mx + nx * offset, gy = my + ny * offset;
          const isHovered = hoveredConstraint === c;
          const isSelected = (selectedConstraint === c || c.__selected);
          const stroke = (isHovered || isSelected) ? '#1e40af' : '#7c3aed';
          const strokeW = (isHovered || isSelected) ? scale(4) : scale(2.5);
          const bgRadius = (isHovered || isSelected) ? glyphSize + scale(8) : glyphSize + scale(5);
          const bgOpacity = (isHovered || isSelected) ? '0.95' : '0.85';
          const bgColor = '#3b82f6'; // blue for parallel
          const glow = (isHovered || isSelected) ? `<circle cx="0" cy="0" r="${bgRadius + scale(4)}" fill="${stroke}" fill-opacity="0.15"/>` : '';
          const symbolSize = glyphSize * 0.6; // Smaller symbols
          drawConstraintGlyph(svg, c);
        }
      }
    } else if(c.type === 'perpendicular' && c.shapes && c.shapes.length >= 2){
      // T shape at intersection - offset perpendicular to first line
      const s1 = shapes.find(s => s.id === c.shapes[0]);
      if(s1 && s1.joints){
        const j1 = joints.get(s1.joints[0]), j2 = joints.get(s1.joints[1]);
        if(j1 && j2){
          const mx = (j1.x + j2.x)/2, my = (j1.y + j2.y)/2;
          // Calculate perpendicular direction
          const dx = j2.x - j1.x, dy = j2.y - j1.y;
          const len = Math.hypot(dx, dy);
          const nx = len > 0 ? -dy/len : 0;
          const ny = len > 0 ? dx/len : 1;
          const offset = scale(10);
          const gx = mx + nx * offset, gy = my + ny * offset;
          const isHovered = hoveredConstraint === c;
          const isSelected = (selectedConstraint === c || c.__selected);
          const stroke = (isHovered || isSelected) ? '#1e40af' : '#0891b2';
          const strokeW = (isHovered || isSelected) ? scale(4) : scale(2.5);
          const bgRadius = (isHovered || isSelected) ? glyphSize + scale(8) : glyphSize + scale(5);
          const bgOpacity = (isHovered || isSelected) ? '0.95' : '0.85';
          const bgColor = '#a855f7'; // purple for perpendicular
          const glow = (isHovered || isSelected) ? `<circle cx="0" cy="0" r="${bgRadius + scale(4)}" fill="${stroke}" fill-opacity="0.15"/>` : '';
          const symbolSize = glyphSize * 0.6; // Smaller symbols
          drawConstraintGlyph(svg, c);
        }
      }
    } else if(c.type === 'distance' && c.joints && c.joints.length >= 2){
      // Dimension annotation with leader lines
      const j1 = joints.get(c.joints[0]), j2 = joints.get(c.joints[1]);
      if(j1 && j2){
        const offset = c.offset || 30;
        const cIdx = constraints.indexOf(c);
        const canEdit = currentTool === 'select' || currentTool === 'dim';
        
        const isHoveredDim = hoveredConstraint === c;
        const isSelectedDim = (selectedConstraint === c || c.__selected);
        const labelStroke = (isHoveredDim || isSelectedDim) ? '#1e40af' : '#2563eb';
        const labelStrokeW = (isHoveredDim || isSelectedDim) ? 2.5 : 1.5;
        
        if(c.isRadius){
          // Circle radius dimension
          const center = j1;
          const radiusPt = j2;
          const radius = Math.hypot(radiusPt.x - center.x, radiusPt.y - center.y);
          const dist = c.value ? c.value.toFixed(1) : radius.toFixed(1);
          
          // Direction from center to label (use offset as radial distance)
          const angle = Math.atan2(radiusPt.y - center.y, radiusPt.x - center.x);
          const labelX = center.x + Math.cos(angle) * offset;
          const labelY = center.y + Math.sin(angle) * offset;
          
          // Leader line from circle edge to label
          const edgeX = center.x + Math.cos(angle) * radius;
          const edgeY = center.y + Math.sin(angle) * radius;
          
          // Draw leader line
          svg.insertAdjacentHTML('beforeend', `<line x1="${edgeX}" y1="${edgeY}" x2="${labelX}" y2="${labelY}" stroke="${labelStroke}" stroke-width="1.5"/>`);
          
          // Draw radius line
          svg.insertAdjacentHTML('beforeend', `<line x1="${center.x}" y1="${center.y}" x2="${edgeX}" y2="${edgeY}" stroke="${labelStroke}" stroke-width="1" stroke-dasharray="3,2" stroke-opacity="0.6"/>`);
          
          // Arrow at circle edge
          const arrowSize = 6;
          svg.insertAdjacentHTML('beforeend', `<polygon points="${edgeX},${edgeY} ${edgeX - Math.cos(angle)*arrowSize + Math.sin(angle)*arrowSize/2},${edgeY - Math.sin(angle)*arrowSize - Math.cos(angle)*arrowSize/2} ${edgeX - Math.cos(angle)*arrowSize - Math.sin(angle)*arrowSize/2},${edgeY - Math.sin(angle)*arrowSize + Math.cos(angle)*arrowSize/2}" fill="${labelStroke}"/>`);
          
          // Label with "R" prefix
          const labelHtml = `<g class="dim-label" data-constraint-idx="${cIdx}" style="cursor:${canEdit ? 'pointer' : 'default'}">
            <rect x="${labelX - 25}" y="${labelY - 10}" width="50" height="18" fill="#9ca3af" fill-opacity="0.9" rx="2" stroke="${labelStroke}" stroke-width="${labelStrokeW}"/>
            <text x="${labelX}" y="${labelY + 4}" text-anchor="middle" font-size="11" fill="white" font-weight="bold">R ${dist}</text>
          </g>`;
          svg.insertAdjacentHTML('beforeend', labelHtml);
        } else {
          // Linear dimension (line or point-to-point)
          const mx = (j1.x + j2.x)/2, my = (j1.y + j2.y)/2;
          const dx = j2.x - j1.x, dy = j2.y - j1.y;
          const len = Math.hypot(dx, dy);
          const dist = c.value ? c.value.toFixed(1) : len.toFixed(1);
          
          // Calculate perpendicular direction
          let nx = 0, ny = -1; // default up
          if(len > 0.01){
            nx = -dy / len;
            ny = dx / len;
          }
          
          // Annotation position
          const annotX = mx + nx * offset;
          const annotY = my + ny * offset;
          
          // Extension line endpoints (from joints toward annotation)
          const ext1Start = { x: j1.x + nx * 5, y: j1.y + ny * 5 };
          const ext1End = { x: j1.x + nx * offset, y: j1.y + ny * offset };
          const ext2Start = { x: j2.x + nx * 5, y: j2.y + ny * 5 };
          const ext2End = { x: j2.x + nx * offset, y: j2.y + ny * offset };
          
          // Dimension line (parallel to the measured segment)
          const dimLineStart = ext1End;
          const dimLineEnd = ext2End;
          
          // Draw extension lines
          svg.insertAdjacentHTML('beforeend', `<line x1="${ext1Start.x}" y1="${ext1Start.y}" x2="${ext1End.x}" y2="${ext1End.y}" stroke="${labelStroke}" stroke-width="1" stroke-opacity="0.6"/>`);
          svg.insertAdjacentHTML('beforeend', `<line x1="${ext2Start.x}" y1="${ext2Start.y}" x2="${ext2End.x}" y2="${ext2End.y}" stroke="${labelStroke}" stroke-width="1" stroke-opacity="0.6"/>`);
          
          // Draw dimension line with arrows
          svg.insertAdjacentHTML('beforeend', `<line x1="${dimLineStart.x}" y1="${dimLineStart.y}" x2="${dimLineEnd.x}" y2="${dimLineEnd.y}" stroke="${labelStroke}" stroke-width="1.5"/>`);
          
          // Arrow markers (small triangles at ends)
          const arrowSize = 6;
          const adx = dx / len, ady = dy / len;
          svg.insertAdjacentHTML('beforeend', `<polygon points="${dimLineStart.x},${dimLineStart.y} ${dimLineStart.x + adx*arrowSize + nx*arrowSize/2},${dimLineStart.y + ady*arrowSize + ny*arrowSize/2} ${dimLineStart.x + adx*arrowSize - nx*arrowSize/2},${dimLineStart.y + ady*arrowSize - ny*arrowSize/2}" fill="${labelStroke}"/>`);
          svg.insertAdjacentHTML('beforeend', `<polygon points="${dimLineEnd.x},${dimLineEnd.y} ${dimLineEnd.x - adx*arrowSize + nx*arrowSize/2},${dimLineEnd.y - ady*arrowSize + ny*arrowSize/2} ${dimLineEnd.x - adx*arrowSize - nx*arrowSize/2},${dimLineEnd.y - ady*arrowSize - ny*arrowSize/2}" fill="${labelStroke}"/>`);
          
          // Clickable text label with background (only editable in select or dim tool)
          const labelHtml = `<g class="dim-label" data-constraint-idx="${cIdx}" style="cursor:${canEdit ? 'pointer' : 'default'}">
            <rect x="${annotX - 20}" y="${annotY - 10}" width="40" height="18" fill="#9ca3af" fill-opacity="0.9" rx="2" stroke="${labelStroke}" stroke-width="${labelStrokeW}"/>
            <text x="${annotX}" y="${annotY + 4}" text-anchor="middle" font-size="11" fill="white" font-weight="bold">${dist}</text>
          </g>`;
          svg.insertAdjacentHTML('beforeend', labelHtml);
        }
      }
    } else if(c.type === 'pointOnLine'){
      // Small circle with dot for point-on-line constraint
      // Only show when the joint is selected (same behavior as coincident)
      const isRelated = selectedJoints.has(c.joint) || selectedConstraint === c || c.__selected;
      if(!isRelated) continue;
      drawConstraintGlyph(svg, c);
    } else if(c.type === 'collinear'){
      // Three dots in a line for collinear constraint
      if(c.joints && c.joints.length >= 3){
        // Position at the middle joint
        const midIdx = Math.floor(c.joints.length / 2);
        const midJoint = joints.get(c.joints[midIdx]);
        if(midJoint){
          const isHovered = hoveredConstraint === c;
          const isSelected = (selectedConstraint === c || c.__selected);
          drawConstraintGlyph(svg, c);
        }
      }
    } else if(c.type === 'tangent'){
      // Circle touching a line for tangent constraint
      const lineShape = shapes.find(s => s.id === c.line);
      const circleShape = shapes.find(s => s.id === c.circle);
      if(lineShape && circleShape && lineShape.joints && circleShape.joints){
        const la = joints.get(lineShape.joints[0]);
        const lb = joints.get(lineShape.joints[1]);
        const center = joints.get(circleShape.joints[0]);
        if(la && lb && center){
          // Position glyph at the midpoint of the line
          const mx = (la.x + lb.x) / 2, my = (la.y + lb.y) / 2;
          const dx = lb.x - la.x, dy = lb.y - la.y;
          const len = Math.hypot(dx, dy);
          const nx = len > 0 ? -dy/len : 0;
          const ny = len > 0 ? dx/len : 1;
          const offset = scale(10);
          const gx = mx + nx * offset, gy = my + ny * offset;
          
          const isHovered = hoveredConstraint === c;
          const isSelected = (selectedConstraint === c || c.__selected);
          drawConstraintGlyph(svg, c);
        }
      }
    }
  }

  // Tooltip: show a small hint near the selected constraint glyph
  try{
    const tooltip = document.getElementById('constraintTooltip');
    if(tooltip){
      if(selectedConstraint){
        let anchor = null;
        // Prefer midpoint of first two joints if available
        if(selectedConstraint.joints && selectedConstraint.joints.length >= 2){
          const j1 = joints.get(selectedConstraint.joints[0]);
          const j2 = joints.get(selectedConstraint.joints[1]);
          if(j1 && j2) anchor = { x: (j1.x + j2.x)/2, y: (j1.y + j2.y)/2 - scale(10) };
        }
        // Fallback to single joint
        if(!anchor && selectedConstraint.joint){
          const j = joints.get(selectedConstraint.joint);
          if(j) anchor = { x: j.x, y: j.y - scale(10) };
        }
        // Fallback to first shape midpoint
        if(!anchor && selectedConstraint.shapes && selectedConstraint.shapes.length){
          const s = shapes.find(s => s.id === selectedConstraint.shapes[0]);
          if(s && s.joints && s.joints.length >= 2){
            const a = joints.get(s.joints[0]), b = joints.get(s.joints[1]);
            if(a && b) anchor = { x: (a.x + b.x)/2, y: (a.y + b.y)/2 - scale(10) };
          }
        }
        if(anchor){
          const pos = worldToScreen(svg, anchor);
          tooltip.style.left = pos.x + 'px';
          tooltip.style.top = pos.y + 'px';
          tooltip.classList.remove('hidden');
          tooltip.textContent = 'Press Delete to remove constraint';
        } else {
          tooltip.classList.add('hidden');
        }
      } else {
        tooltip.classList.add('hidden');
      }
    }
  }catch(_){ }
}



// ---- 5-engine.js (inlined) ----


// Embedded store (was store.js)
const joints = new Map();
const shapes = [];
const constraints = [];
let jid = 0;
function _genJ(){ return 'j'+(++jid)+'_'+Date.now(); }
function _initStore(){ joints.clear(); shapes.length = 0; constraints.length = 0; jid = 0; joints.set('j_origin',{x:0,y:0,fixed:true}); }

function createEngine(svg){
  function init(){ _initStore(); }
  function genJ(){ return _genJ(); }
  function getJoints(){ return joints; }
  function getShapes(){ return shapes; }
  function getConstraints(){ return constraints; }
  function addJoint(id,x,y,fixed=false){ joints.set(id,{x,y,fixed}); }
  function addShape(shape){ shapes.push(shape); }
  function addConstraint(c){ constraints.push(c); }
  function mergeJoints(fromId,toId){ if(!joints.has(fromId)||!joints.has(toId)||fromId===toId) return; for(const s of shapes){ for(let i=0;i<s.joints.length;i++) if(s.joints[i]===fromId) s.joints[i]=toId; } joints.delete(fromId); }
  function solve(iter=20){ solveConstraints(joints, shapes, constraints, iter); }
  function findSnap(lastMouse){ return snapFind(joints, shapes, svg, lastMouse); }
  function hitJointAtScreen(screenX,screenY,threshold=10){ return snapHit(joints, svg, screenX, screenY, threshold); }

  return { init, genJ, getJoints, getShapes, getConstraints, addJoint, addShape, addConstraint, mergeJoints, solve, findSnap, hitJointAtScreen };
}


// ---- 6-input.js (inlined) ----


// Show dimension input for editing a constraint value
function showDimInput(svg, state, constraint){
  const dimInput = document.getElementById('dimInput');
  if(!dimInput || !constraint.joints || constraint.joints.length < 2) return;
  
  const j1 = state.joints.get(constraint.joints[0]);
  const j2 = state.joints.get(constraint.joints[1]);
  if(!j1 || !j2) return;
  
  // Position at the annotation location
  const mx = (j1.x + j2.x) / 2, my = (j1.y + j2.y) / 2;
  const dx = j2.x - j1.x, dy = j2.y - j1.y;
  const len = Math.hypot(dx, dy);
  const offset = constraint.offset || 30;
  
  let annotX = mx, annotY = my - 20;
  if(len > 0.01){
    const nx = -dy / len, ny = dx / len;
    annotX = mx + nx * offset;
    annotY = my + ny * offset;
  }
  
  const screenPos = worldToScreen(svg, { x: annotX, y: annotY });
  dimInput.style.left = (screenPos.x - 40) + 'px';
  dimInput.style.top = (screenPos.y - 15) + 'px';
  dimInput.value = constraint.value.toFixed(1);
  dimInput.classList.remove('hidden');
  dimInput.focus();
  dimInput.select();
  
  // Handle input
  const onKeydown = (e) => {
    if(e.key === 'Enter'){
      const newVal = parseFloat(dimInput.value);
      if(!isNaN(newVal) && newVal > 0){
        constraint.value = newVal;
      }
      dimInput.classList.add('hidden');
      dimInput.removeEventListener('keydown', onKeydown);
      dimInput.removeEventListener('blur', onBlur);
    } else if(e.key === 'Escape'){
      dimInput.classList.add('hidden');
      dimInput.removeEventListener('keydown', onKeydown);
      dimInput.removeEventListener('blur', onBlur);
    }
  };
  const onBlur = () => {
    const newVal = parseFloat(dimInput.value);
    if(!isNaN(newVal) && newVal > 0){
      constraint.value = newVal;
    }
    dimInput.classList.add('hidden');
    dimInput.removeEventListener('keydown', onKeydown);
    dimInput.removeEventListener('blur', onBlur);
  };
  
  dimInput.addEventListener('keydown', onKeydown);
  dimInput.addEventListener('blur', onBlur);
}

function setupInput(svg, state){
  // Track continuation point for sequential clicking (all drawing tools)
  let continueFrom = null;
  let polylineOrigin = null; // Track the very first point of a polyline sequence
  let isDragging = false;
  let dragStartScreen = null; // Track where mouse went down
  const DRAG_THRESHOLD = 2; // pixels to consider it a drag vs click - reduced for touch responsiveness
  let justCreatedActive = false; // Track if state.active was just created in pointerdown

  // Helper: find an existing joint close to the given point (returns joint id or null)
  function findNearbyJoint(jointsMap, pt, excludeId, eps = 0.01){
    if(!pt) return null;
    for(const [id, j] of jointsMap.entries()){
      if(id === excludeId) continue;
      const dx = j.x - pt.x, dy = j.y - pt.y;
      if(Math.hypot(dx, dy) < eps) return id;
    }
    return null;
  }
  
  // Track last clicked dimension for double-click detection
  let lastDimClick = { constraint: null, time: 0 };
  const DOUBLE_CLICK_THRESHOLD = 300; // milliseconds
  
  svg.addEventListener('pointermove',(e)=>{
    state.lastMouse = { x: e.clientX, y: e.clientY };
    const w = screenToWorld(svg, e.clientX, e.clientY);
    // Exclude dragged joints from snap, and disable line snap when dragging
    const excludeIds = state.drag ? state.drag.jointIds : (state.active ? [state.active.start] : (continueFrom ? [continueFrom] : []));
    const isDraggingPoint = state.drag && (state.drag.type === 'joint' || state.drag.type === 'cluster');
    // Use tighter tolerance for inference snaps during line drawing
    const useInferenceTolerance = state.active && (state.active.mode === 'line');
    
    // For constraint tools that only work on lines (hv, parallel, perp, tangent), skip joint snapping
    // Collinear works on joints, so it should use normal snapping
    const lineOnlyTools = ['hv', 'parallel', 'perp', 'tangent'];
    const skipJointSnap = lineOnlyTools.includes(state.currentTool);
    
    if(skipJointSnap){
      // Only detect line snaps for these tools
      state.snapTarget = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
      if(state.snapTarget){
        state.snapTarget.type = 'line'; // Ensure it has the type property
      }
    } else {
      state.snapTarget = findSnap(state.joints, state.shapes, svg, state.lastMouse, excludeIds, isDraggingPoint, useInferenceTolerance);
    }
    
    // Track hover for selection feedback (when in select mode and not dragging)
    if(!state.drag && state.currentTool === 'select'){
      // Check for hovering over constraint glyphs FIRST (priority over lines/joints)
      // Only check if pointer is over the SVG canvas to avoid interfering with UI
      const targetElem = e.target;
      const isOverCanvas = targetElem && (targetElem === svg || svg.contains(targetElem));
      
      if(isOverCanvas){
        const glyphElem = document.elementFromPoint(e.clientX, e.clientY);
        const glyphGroup = glyphElem?.closest('.constraint-glyph');
        if(glyphGroup){
          const ctype = glyphGroup.dataset.ctype;
          if(ctype === 'coincident'){
            const cj0 = glyphGroup.dataset.cj0, cj1 = glyphGroup.dataset.cj1;
            state.hoveredConstraint = state.constraints.find(c => 
              c.type === 'coincident' && c.joints && c.joints[0] === cj0 && c.joints[1] === cj1
            );
          } else if(ctype === 'horizontal'){
            const cj0 = glyphGroup.dataset.cj0, cj1 = glyphGroup.dataset.cj1;
            state.hoveredConstraint = state.constraints.find(c => 
              c.type === 'horizontal' && c.joints && c.joints[0] === cj0 && c.joints[1] === cj1
            );
          } else if(ctype === 'vertical'){
            const cj0 = glyphGroup.dataset.cj0, cj1 = glyphGroup.dataset.cj1;
            state.hoveredConstraint = state.constraints.find(c => 
              c.type === 'vertical' && c.joints && c.joints[0] === cj0 && c.joints[1] === cj1
            );
          } else if(ctype === 'parallel'){
            const cs0 = glyphGroup.dataset.cs0, cs1 = glyphGroup.dataset.cs1;
            state.hoveredConstraint = state.constraints.find(c => 
              c.type === 'parallel' && c.shapes && c.shapes[0] === cs0 && c.shapes[1] === cs1
            );
          } else if(ctype === 'perpendicular'){
            const cs0 = glyphGroup.dataset.cs0, cs1 = glyphGroup.dataset.cs1;
            state.hoveredConstraint = state.constraints.find(c => 
              c.type === 'perpendicular' && c.shapes && c.shapes[0] === cs0 && c.shapes[1] === cs1
            );
          } else if(ctype === 'pointOnLine'){
            const cjoint = glyphGroup.dataset.cjoint, cshape = glyphGroup.dataset.cshape;
            state.hoveredConstraint = state.constraints.find(c => 
              c.type === 'pointOnLine' && c.joint === cjoint && c.shape === cshape
            );
          } else if(ctype === 'collinear'){
            const cjoints = glyphGroup.dataset.cjoints?.split(',') || [];
            state.hoveredConstraint = state.constraints.find(c => 
              c.type === 'collinear' && c.joints && c.joints.length === cjoints.length &&
              c.joints.every((j, i) => j === cjoints[i])
            );
          } else if(ctype === 'tangent'){
            const cline = glyphGroup.dataset.cline, ccircle = glyphGroup.dataset.ccircle;
            state.hoveredConstraint = state.constraints.find(c => 
              c.type === 'tangent' && c.line === cline && c.circle === ccircle
            );
          }
          // When hovering over glyph, suppress line/joint hover
          state.hoveredJoint = null;
          state.hoveredShape = null;
        } else {
          state.hoveredConstraint = null;
          
          // Check for hovering over joints
          const hoveredJoint = hitJointAtScreen(state.joints, svg, e.clientX, e.clientY, 20);
          state.hoveredJoint = hoveredJoint || null;
          
          // Check for hovering over shapes
          const hoveredLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
          state.hoveredShape = hoveredLine ? hoveredLine.shape : null;
        }
      } else {
        // Not over canvas - clear all hover states
        state.hoveredConstraint = null;
        state.hoveredJoint = null;
        state.hoveredShape = null;
      }
    } else {
      state.hoveredJoint = null;
      state.hoveredShape = null;
      state.hoveredConstraint = null;
    }
    
    // Track if we've moved enough to be considered dragging (for drawing tools)
    if(dragStartScreen && state.active){
      const dist = Math.hypot(e.clientX - dragStartScreen.x, e.clientY - dragStartScreen.y);
      if(dist > DRAG_THRESHOLD) isDragging = true;
    }
    
    if(state.drag){ 
      isDragging = true;
      if(state.drag.type==='joint' || state.drag.type==='cluster'){ 
        const wpt = screenToWorld(svg, e.clientX, e.clientY); 
        // Apply snap if available
        const targetPt = state.snapTarget ? state.snapTarget.pt : wpt;
        const dx = targetPt.x - state.drag.startWorld.x;
        const dy = targetPt.y - state.drag.startWorld.y;
        for(const id of state.drag.jointIds){
          const init = state.drag.initial.get(id);
          const j = state.joints.get(id);
          if(j && init && !j.fixed){ j.x = init.x + dx; j.y = init.y + dy; }
        }
      } else if(state.drag.type==='line'){
        const wpt = screenToWorld(svg, e.clientX, e.clientY);
        const dx = wpt.x - state.drag.startWorld.x;
        const dy = wpt.y - state.drag.startWorld.y;
        for(const id of state.drag.jointIds){
          const init = state.drag.initial.get(id);
          const j = state.joints.get(id);
          if(j && init && !j.fixed){ j.x = init.x + dx; j.y = init.y + dy; }
        }
      } else if(state.drag.type==='pan'){
        const rect = svg.getBoundingClientRect();
        const dx = e.clientX - state.drag.start.x;
        const dy = e.clientY - state.drag.start.y;
        const scaleX = state.view.w / rect.width;
        const scaleY = state.view.h / rect.height;
        state.view.x = state.drag.initialPan.x - dx * scaleX;
        state.view.y = state.drag.initialPan.y - dy * scaleY;
        svg.setAttribute('viewBox', `${state.view.x-state.view.w/2} ${state.view.y-state.view.h/2} ${state.view.w} ${state.view.h}`);
      } else if(state.drag.type==='dim'){
        // Dragging dimension label - update offset perpendicular to the line
        const constraint = state.drag.constraint;
        if(constraint && constraint.joints && constraint.joints.length >= 2){
          const j1 = state.joints.get(constraint.joints[0]);
          const j2 = state.joints.get(constraint.joints[1]);
          if(j1 && j2){
            const w = screenToWorld(svg, e.clientX, e.clientY);
            const mx = (j1.x + j2.x) / 2, my = (j1.y + j2.y) / 2;
            const dx = j2.x - j1.x, dy = j2.y - j1.y;
            const len = Math.hypot(dx, dy);
            if(len > 0.01){
              const nx = -dy / len, ny = dx / len;
              const toMouse = { x: w.x - mx, y: w.y - my };
              constraint.offset = toMouse.x * nx + toMouse.y * ny;
            }
          }
        }
      }
    }
    // Show preview for drawing tools
    if(state.active && (state.active.mode==='line' || state.active.mode==='rect' || state.active.mode==='circle')){ 
      let previewType = state.active.mode;
      // Use rect sub-mode for preview type
      if(state.active.mode === 'rect'){
        const rectMode = state.rectMode || 'rect-2pt';
        if(rectMode === 'rect-center') previewType = 'rect-center';
        else if(rectMode === 'rect-3pt') previewType = 'rect-3pt';
      }
      let previewPt = state.snapTarget ? state.snapTarget.pt : w;
      
      // Apply inference for line drawing (horizontal, vertical, perpendicular)
      state.inference = null;
      if(state.active.mode === 'line' && state.active.start){
        const startJoint = state.joints.get(state.active.start);
        if(startJoint){
          const inference = findInference(startJoint, previewPt, state.shapes, state.joints, state.snapTarget);
          if(inference){
            state.inference = inference;
            previewPt = inference.pt; // Snap to inferred position
          }
        }
      }
      
      state.active.preview = { type: previewType, pt: previewPt }; 
    }
    // Show preview for continuation mode
    if(continueFrom && (state.currentTool === 'line' || state.currentTool === 'rect' || state.currentTool === 'circle') && !state.active){
      const previewPt = state.snapTarget ? state.snapTarget.pt : w;
      
      // Apply inference for continuation
      let finalPt = previewPt;
      state.inference = null;
      if(state.currentTool === 'line'){
        const startJoint = state.joints.get(continueFrom);
        if(startJoint){
          const inference = findInference(startJoint, previewPt, state.shapes, state.joints, state.snapTarget);
          if(inference){
            state.inference = inference;
            finalPt = inference.pt;
          }
        }
      }
      
      state.active = { mode: state.currentTool, start: continueFrom, preview: { type: state.currentTool, pt: finalPt } };
    }
    
    // Dimension tool: update offset while dragging
    if(state.active && (state.active.mode === 'dim-line' || state.active.mode === 'dim-circle' || (state.active.mode === 'dim-p2p' && state.active.j2))){
      if(state.active.mode === 'dim-circle'){
        // For circle: update radial offset
        const center = state.joints.get(state.active.joints[0]);
        if(center){
          const distFromCenter = Math.hypot(w.x - center.x, w.y - center.y);
          state.active.offset = distFromCenter;
        }
      } else {
        // For line: update perpendicular offset
        const j1 = state.joints.get(state.active.joints[0]);
        const j2 = state.joints.get(state.active.joints[1]);
        if(j1 && j2){
          // Calculate perpendicular distance from mouse to line
          const mx = (j1.x + j2.x) / 2, my = (j1.y + j2.y) / 2;
          const dx = j2.x - j1.x, dy = j2.y - j1.y;
          const len = Math.hypot(dx, dy);
          if(len > 0.01){
            // Normal vector (perpendicular)
            const nx = -dy / len, ny = dx / len;
            // Vector from midpoint to mouse
            const toMouse = { x: w.x - mx, y: w.y - my };
            // Project onto normal to get signed offset
            state.active.offset = toMouse.x * nx + toMouse.y * ny;
          }
        }
      }
    }
  });

  svg.addEventListener('pointerdown',(e)=>{
    // Allow middle mouse button to pan regardless of current tool or state
    if(e.button === 1){ // Middle mouse button
      svg.setPointerCapture(e.pointerId);
      state.drag = { 
        type: 'pan', 
        start: { x: e.clientX, y: e.clientY }, 
        initialPan: { x: state.view.x, y: state.view.y }, 
        pointerId: e.pointerId 
      };
      return;
    }
    
    // FIRST: Check if clicking on a dimension label - only in select or dim tool
    if(state.currentTool === 'select' || state.currentTool === 'dim'){
      // Check if clicked element or any parent has dim-label class
      let dimLabel = null;
      let target = e.target;
      for(let i = 0; i < 10 && target; i++){
        if(target.classList && target.classList.contains('dim-label')){
          dimLabel = target;
          break;
        }
        target = target.parentElement;
      }
      
      if(dimLabel){
        const cIdx = parseInt(dimLabel.getAttribute('data-constraint-idx'));
        const constraint = state.constraints[cIdx];
        if(constraint && constraint.type === 'distance'){
          e.stopPropagation();
          e.preventDefault();
          
          // Check for double-click
          const now = Date.now();
          const isDoubleClick = lastDimClick.constraint === constraint && (now - lastDimClick.time) < DOUBLE_CLICK_THRESHOLD;
          
          if(isDoubleClick){
            // Double-click: edit the dimension
            showDimInput(svg, state, constraint);
            lastDimClick = { constraint: null, time: 0 };
          } else {
            // Single click: select the dimension and allow dragging
            state.selectedConstraint = constraint;
            lastDimClick = { constraint, time: now };
            
            // Start dragging if user wants to move the label
            svg.setPointerCapture(e.pointerId);
            state.drag = {
              type: 'dim',
              constraint: constraint,
              pointerId: e.pointerId,
              dragStartScreen: { x: e.clientX, y: e.clientY }
            };
          }
          return;
        }
      }
    }
    
    const w = screenToWorld(svg, e.clientX, e.clientY);
    state.lastMouse = { x: e.clientX, y: e.clientY };
    isDragging = false;
    dragStartScreen = { x: e.clientX, y: e.clientY };
    const excludeIds = continueFrom ? [continueFrom] : [];
    const hitSnap = findSnap(state.joints, state.shapes, svg, state.lastMouse, excludeIds);
    const hitJoint = hitJointAtScreen(state.joints, svg, e.clientX, e.clientY, 30);
    
    // Check if clicking on a constraint glyph FIRST (priority over joints)
    const target = e.target.closest('.constraint-glyph');
    if(target && state.currentTool === 'select'){
      const ctype = target.dataset.ctype;
      let constraint = null;
      // Match common glyph types to constraints
      if(ctype === 'coincident' || ctype === 'horizontal' || ctype === 'vertical'){
        const cj0 = target.dataset.cj0, cj1 = target.dataset.cj1;
        constraint = state.constraints.find(c => c.type === ctype && c.joints && ((c.joints[0] === cj0 && c.joints[1] === cj1) || (c.joints[0] === cj1 && c.joints[1] === cj0)));
      } else if(ctype === 'parallel' || ctype === 'perpendicular'){
        const cs0 = target.dataset.cs0, cs1 = target.dataset.cs1;
        constraint = state.constraints.find(c => c.type === ctype && c.shapes && ((c.shapes[0] === cs0 && c.shapes[1] === cs1) || (c.shapes[0] === cs1 && c.shapes[1] === cs0)));
      } else if(ctype === 'pointOnLine'){
        const cjoint = target.dataset.cjoint, cshape = target.dataset.cshape;
        constraint = state.constraints.find(c => c.type === 'pointOnLine' && c.joint === cjoint && c.shape === cshape);
      } else if(ctype === 'collinear'){
        const cjoints = target.dataset.cjoints ? target.dataset.cjoints.split(',') : [];
        constraint = state.constraints.find(c => c.type === 'collinear' && c.joints && c.joints.length === cjoints.length && c.joints.every((j,i) => j === cjoints[i]));
      } else if(ctype === 'tangent'){
        const cline = target.dataset.cline, ccircle = target.dataset.ccircle;
        constraint = state.constraints.find(c => c.type === 'tangent' && c.line === cline && c.circle === ccircle);
      }

      if(constraint){
        // Select constraint glyph for visual feedback (do NOT delete immediately)
        state.selectItem('constraint', constraint);
        // Ensure we are in select mode visually
        state.currentTool = 'select';
        document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
        const selBtn = document.getElementById('tool-select');
        if(selBtn) selBtn.classList.add('active');
        // Re-render to show selection feedback (safe-call if render is available)
        try{ render(); }catch(_){ }
        return;
      }
    }
    
    if(state.currentTool==='line' || state.currentTool==='rect' || state.currentTool==='circle'){
      // If already active (in continuation mode), complete the shape
      if(state.active && state.active.start){
        // Already have a start point from previous click, so this click completes the segment
        // Process the completion in pointerup instead - do nothing here
        return;
      }
      // If continuing from previous shape, use that endpoint as start
      if(continueFrom){
        state.active = { mode: state.currentTool, start: continueFrom, startPt: state.joints.get(continueFrom), preview: null, polylineOrigin: polylineOrigin };
        continueFrom = null; // Clear it so we don't keep reusing
        justCreatedActive = true; // Mark that we just created active in this click
      } else {
        // Snap to existing joint or create new one
        const startPt = hitSnap ? hitSnap.pt : w;
        const startId = hitSnap && hitSnap.type==='joint' ? hitSnap.id : state.genJ(); 
        if(!state.joints.has(startId)) state.joints.set(startId, {x: startPt.x, y: startPt.y, fixed:false}); 
        state.active = { mode: state.currentTool, start: startId, startPt: startPt, preview: null, polylineOrigin: startId };
        polylineOrigin = startId; // Remember the origin of this polyline
        justCreatedActive = true; // Mark that we just created active
      }
    } else if(state.currentTool==='select'){
      continueFrom = null;
      // Clear previous selections when clicking elsewhere
      state.clearSelection();
      
      if(hitJoint){ 
        svg.setPointerCapture(e.pointerId);
        // Find all joints in coincident cluster first
        const cluster = findCoincidentCluster(hitJoint.id, state.constraints);
        const jointIds = Array.from(cluster);
        // Select this joint cluster (add to selection with Shift, replace otherwise)
        if(!e.shiftKey) state.clearSelection();
        state.selectItem('joints', jointIds);
        const initial = new Map();
        for(const id of jointIds){
          const j = state.joints.get(id);
          if(j) initial.set(id, { x: j.x, y: j.y });
        }
        // Only allow dragging if it's a single joint with no coincident constraints
        // Or if it's part of a cluster, drag the entire cluster together
        state.drag = { 
          type: cluster.size > 1 ? 'cluster' : 'joint', 
          id: hitJoint.id, 
          jointIds,
          initial, 
          startWorld: { x: w.x, y: w.y },
          pointerId: e.pointerId 
        };
        state.active = null;
        // If user selected a joint, auto-select any coincident constraint involving it
        // This ensures the glyph appears immediately when clicking the joint
        const coincidentConstraint = state.constraints.find(c => c.type === 'coincident' && c.joints && c.joints.includes(hitJoint.id));
        if(coincidentConstraint){
          console.log('[select] auto-select coincident constraint for joint', hitJoint.id, coincidentConstraint);
          state.selectedConstraint = coincidentConstraint;
          try{ render(); }catch(_){ /* render may be provided by outer scope; ignore if not */ }
        } 
      } else {
        // Check if clicking on a line/shape
        const hitLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
        if(hitLine){
          // Select and prepare to drag the line
          state.selectItem('shape', hitLine.shape);
          state.active = null;
          svg.setPointerCapture(e.pointerId);
          // Start dragging the line by tracking both its joints
          const initial = new Map();
          const jointIds = hitLine.shape.joints;
          for(const id of jointIds){
            const j = state.joints.get(id);
            if(j) initial.set(id, { x: j.x, y: j.y });
          }
          state.drag = {
            type: 'line',
            id: hitLine.shape.id,
            jointIds: jointIds,
            initial: initial,
            startWorld: { x: w.x, y: w.y },
            pointerId: e.pointerId
          };
        } else {
          svg.setPointerCapture(e.pointerId); 
          state.drag = { type:'pan', start: { x: e.clientX, y: e.clientY }, initialPan: { x: state.view.x, y: state.view.y }, pointerId: e.pointerId }; 
        }
      }
    } else if(state.pendingConstraint){
      // Handle pending constraint - second element selection
      continueFrom = null;
      const constraintType = state.pendingConstraint.type;
      const firstElement = state.pendingConstraint.firstElement;
      
      // Determine what type of element we need for the second click
      const lineOnlyTools = ['hv', 'parallel', 'perp', 'tangent'];
      const jointOnlyTools = ['coincident', 'collinear'];
      
      state.saveState(); // Save state BEFORE making changes
      
      if(constraintType === 'parallel' || constraintType === 'perp'){
        // These tools work on lines
        const hitLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
        if(hitLine && hitLine.shape.type === 'line' && hitLine.shape.id !== firstElement.id){
          addConstraint(state, constraintType === 'parallel' ? 'parallel' : 'perpendicular', {
            shapes: [firstElement.id, hitLine.shape.id]
          });
          state.pendingConstraint = null;
          // Reset to select mode
          document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
          document.getElementById('tool-select').classList.add('active');
          const mt = document.getElementById('modeText');
          if(mt) mt.innerText = 'MODE: SELECT';
        }
      } else if(constraintType === 'coincident'){
        // Coincident works on joints OR joint+line (pointOnLine)
        const hitLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
        
        if(firstElement.type === 'joint'){
          // First element was joint
          if(hitSnap && hitSnap.type === 'joint' && hitSnap.id !== firstElement.id){
            // Joint to joint = coincident
            console.log('[UI] Attempting to add coincident constraint between joints', firstElement.id, hitSnap.id);
            addConstraint(state, 'coincident', { joints: [firstElement.id, hitSnap.id] });
            state.pendingConstraint = null;
            state.currentTool = 'select';
            document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
            document.getElementById('tool-select').classList.add('active');
            const mt = document.getElementById('modeText');
            if(mt) mt.innerText = 'MODE: SELECT';
            render();
          } else if(hitLine && hitLine.shape.type === 'line'){
            // Joint to line = pointOnLine (check joint not part of line)
            if(!hitLine.shape.joints.includes(firstElement.id)){
              addConstraint(state, 'pointOnLine', { joint: firstElement.id, shape: hitLine.shape.id });
              state.pendingConstraint = null;
              state.currentTool = 'select';
              document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
              document.getElementById('tool-select').classList.add('active');
              const mt = document.getElementById('modeText');
              if(mt) mt.innerText = 'MODE: SELECT';
              render();
            }
          }
        } else if(firstElement.type === 'shape'){
          // First element was line - second must be joint
          if(hitSnap && hitSnap.type === 'joint'){
            const lineShape = state.shapes.find(s => s.id === firstElement.id);
            if(lineShape && !lineShape.joints.includes(hitSnap.id)){
              addConstraint(state, 'pointOnLine', { joint: hitSnap.id, shape: firstElement.id });
              state.pendingConstraint = null;
              state.currentTool = 'select';
              document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
              document.getElementById('tool-select').classList.add('active');
              const mt = document.getElementById('modeText');
              if(mt) mt.innerText = 'MODE: SELECT';
              render();
            }
          }
        }
      } else if(constraintType === 'hv'){
        // H/V works on lines/joints
        const hitLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
        if(hitLine && hitLine.shape.type === 'line'){
          const j1 = state.joints.get(hitLine.shape.joints[0]);
          const j2 = state.joints.get(hitLine.shape.joints[1]);
          if(j1 && j2){
            const dx = j2.x - j1.x;
            const dy = j2.y - j1.y;
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            const absAngle = Math.abs(angle);
            const isCloserToHorizontal = (absAngle < 45) || (absAngle > 135);
            
            addConstraint(state, isCloserToHorizontal ? 'horizontal' : 'vertical', {
              joints: hitLine.shape.joints.slice()
            });
            state.pendingConstraint = null;
            // Reset to select mode
            document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
            document.getElementById('tool-select').classList.add('active');
            const mt = document.getElementById('modeText');
            if(mt) mt.innerText = 'MODE: SELECT';
          }
        }
      } else if(constraintType === 'collinear'){
        // Collinear works on joints or lines
        if(hitSnap && hitSnap.type === 'joint'){
          // Initialize joints array if needed
          if(!state.pendingConstraint.joints){
            state.pendingConstraint.joints = [firstElement.id];
          }
          
          // Add new joint if not already present
          if(!state.pendingConstraint.joints.includes(hitSnap.id)){
            state.pendingConstraint.joints.push(hitSnap.id);
          }
          
          if(state.pendingConstraint.joints.length >= 3){
            // Can apply collinear now
            addConstraint(state, 'collinear', {
              joints: state.pendingConstraint.joints.slice()
            });
            state.pendingConstraint = null;
            // Reset to select mode
            document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
            document.getElementById('tool-select').classList.add('active');
            const mt = document.getElementById('modeText');
            if(mt) mt.innerText = 'MODE: SELECT';
          } else {
            // Still collecting joints - show how many we have
            const mt = document.getElementById('modeText');
            if(mt) mt.innerText = 'MODE: COLLINEAR - ' + state.pendingConstraint.joints.length + '/3 Points';
          }
        }
      } else if(constraintType === 'tangent'){
        // Tangent works on line + circle pairs
        const hitLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
        const hitCircle = hitLine && hitLine.shape.type === 'circle' ? hitLine.shape : null;
        const hitLineShape = hitLine && hitLine.shape.type === 'line' ? hitLine.shape : null;
        
        const firstIsLine = firstElement.type === 'shape' && state.shapes.find(s => s.id === firstElement.id)?.type === 'line';
        const firstIsCircle = firstElement.type === 'shape' && state.shapes.find(s => s.id === firstElement.id)?.type === 'circle';
        
        if((firstIsLine && hitCircle) || (firstIsCircle && hitLineShape)){
          const lineId = firstIsLine ? firstElement.id : hitLineShape.id;
          const circleId = firstIsCircle ? firstElement.id : hitCircle.id;
          
          addConstraint(state, 'tangent', {
            line: lineId,
            circle: circleId
          });
          state.pendingConstraint = null;
          // Reset to select mode
          document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
          document.getElementById('tool-select').classList.add('active');
          const mt = document.getElementById('modeText');
          if(mt) mt.innerText = 'MODE: SELECT';
        }
      }
    } else if(state.currentTool==='coincident'){
      continueFrom = null;
      // Get fresh snap and line detection for coincident tool
      const coincidentSnap = findSnap(state.joints, state.shapes, svg, state.lastMouse, []);
      const coincidentLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
      
      if(!state.active){ 
        // First click - select joint or line (joint has priority)
        if(coincidentSnap && coincidentSnap.type==='joint'){ 
          state.active = { mode:'coincident', j1: coincidentSnap.id, firstType: 'joint' }; 
          const mt = document.getElementById('modeText');
          if(mt) mt.innerText = 'MODE: COINCIDENT - Click Joint or Line';
        } else if(coincidentLine && coincidentLine.shape.type === 'line'){
          state.active = { mode:'coincident', line1: coincidentLine.shape.id, firstType: 'line' };
          const mt = document.getElementById('modeText');
          if(mt) mt.innerText = 'MODE: COINCIDENT - Click Joint';
        }
      } else { 
        // Second click
        if(state.active.firstType === 'joint'){
          // First was joint - second can be joint (coincident) or line (pointOnLine)
          if(coincidentSnap && coincidentSnap.type==='joint' && coincidentSnap.id !== state.active.j1){ 
            state.saveState();
            addConstraint(state, 'coincident', { joints: [state.active.j1, coincidentSnap.id] }); 
            state.active = null;
            const mt = document.getElementById('modeText');
            if(mt) mt.innerText = 'MODE: COINCIDENT';
            render();
          } else if(coincidentLine && coincidentLine.shape.type === 'line'){
            // Check joint is not part of the line
            if(!coincidentLine.shape.joints.includes(state.active.j1)){
              state.saveState();
              addConstraint(state, 'pointOnLine', { joint: state.active.j1, shape: coincidentLine.shape.id }); 
              state.active = null;
              const mt = document.getElementById('modeText');
              if(mt) mt.innerText = 'MODE: COINCIDENT';
              render();
            }
          }
        } else if(state.active.firstType === 'line'){
          // First was line - second must be joint (pointOnLine)
          if(coincidentSnap && coincidentSnap.type==='joint'){
            const lineShape = state.shapes.find(s => s.id === state.active.line1);
            // Check joint is not part of the line
            if(lineShape && !lineShape.joints.includes(coincidentSnap.id)){
              state.saveState();
              addConstraint(state, 'pointOnLine', { joint: coincidentSnap.id, shape: state.active.line1 }); 
              state.active = null;
              const mt = document.getElementById('modeText');
              if(mt) mt.innerText = 'MODE: COINCIDENT';
              render();
            }
          }
        }
      }
    } else if(state.currentTool==='hv'){
      continueFrom = null;
      const hitLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
      
      if(hitLine && hitLine.shape.type === 'line'){
        // Get line joints
        const j1 = state.joints.get(hitLine.shape.joints[0]);
        const j2 = state.joints.get(hitLine.shape.joints[1]);
        
        if(j1 && j2){
          // Check if line already has horizontal or vertical constraint
          const lineJoints = hitLine.shape.joints;
          const hasHVConstraint = state.constraints.some(c => 
            (c.type === 'horizontal' || c.type === 'vertical') &&
            c.joints && 
            ((c.joints[0] === lineJoints[0] && c.joints[1] === lineJoints[1]) ||
             (c.joints[0] === lineJoints[1] && c.joints[1] === lineJoints[0]))
          );
          
          if(hasHVConstraint){
            // Already has HV constraint, do nothing
            return;
          }
          
          // Calculate line angle
          const dx = j2.x - j1.x;
          const dy = j2.y - j1.y;
          const angle = Math.atan2(dy, dx) * 180 / Math.PI;
          const absAngle = Math.abs(angle);
          
          // 45Â° threshold: closer to horizontal (0Â°/180Â°) or vertical (90Â°)
          const isCloserToHorizontal = (absAngle < 45) || (absAngle > 135);
          
          state.saveState(); // Save state BEFORE making changes
          if(isCloserToHorizontal){
            // Apply horizontal constraint
            addConstraint(state, 'horizontal', { joints: hitLine.shape.joints.slice() });
          } else {
            // Apply vertical constraint
            addConstraint(state, 'vertical', { joints: hitLine.shape.joints.slice() });
          }
        }
      }
    } else if(state.currentTool==='parallel'){
      continueFrom = null;
      const hitLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
      
      if(!state.active){
        // First click: select first line
        if(hitLine && hitLine.shape.type === 'line'){
          state.active = { mode: 'parallel', shape1: hitLine.shape.id };
        }
      } else {
        // Second click: select second line
        if(hitLine && hitLine.shape.type === 'line' && hitLine.shape.id !== state.active.shape1){
          state.saveState(); // Save state BEFORE making changes
          addConstraint(state, 'parallel', { shapes: [state.active.shape1, hitLine.shape.id] });
          state.active = null;
        }
      }
    } else if(state.currentTool==='perp'){
      continueFrom = null;
      const hitLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
      
      if(!state.active){
        // First click: select first line
        if(hitLine && hitLine.shape.type === 'line'){
          state.active = { mode: 'perp', shape1: hitLine.shape.id };
        }
      } else {
        // Second click: select second line
        if(hitLine && hitLine.shape.type === 'line' && hitLine.shape.id !== state.active.shape1){
          state.saveState(); // Save state BEFORE making changes
          addConstraint(state, 'perpendicular', { shapes: [state.active.shape1, hitLine.shape.id] });
          state.active = null;
        }
      }
    } else if(state.currentTool==='collinear'){
      continueFrom = null;
      // Collinear: select 3 or more joints to make them lie on same line
      // Can click joints directly OR click lines to add all their joints
      if(!state.active){
        if(hitSnap && hitSnap.type==='joint'){
          state.active = { mode: 'collinear', joints: [hitSnap.id] };
        } else if(hitSnap && hitSnap.type==='line' && hitSnap.shape){
          // Clicked a line - add all its joints
          const lineJoints = hitSnap.shape.joints || [];
          state.active = { mode: 'collinear', joints: lineJoints.slice() };
        }
      } else {
        if(hitSnap && hitSnap.type==='joint' && !state.active.joints.includes(hitSnap.id)){
          state.active.joints.push(hitSnap.id);
          // Need at least 3 joints
          if(state.active.joints.length >= 3){
            // Can optionally apply now, or wait for more clicks
            // Let's apply on each additional joint after 3rd
            state.saveState(); // Save state BEFORE making changes
            addConstraint(state, 'collinear', { joints: state.active.joints.slice() });
            state.active = null; // Reset to start new collinear constraint
          }
        } else if(hitSnap && hitSnap.type==='line' && hitSnap.shape){
          // Clicked a line - add all its joints that aren't already included
          const lineJoints = hitSnap.shape.joints || [];
          lineJoints.forEach(jid => {
            if(!state.active.joints.includes(jid)){
              state.active.joints.push(jid);
            }
          });
          // Need at least 3 joints
          if(state.active.joints.length >= 3){
            state.saveState(); // Save state BEFORE making changes
            addConstraint(state, 'collinear', { joints: state.active.joints.slice() });
            state.active = null; // Reset to start new collinear constraint
          }
        }
      }

    } else if(state.currentTool==='tangent'){
      continueFrom = null;
      const hitLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
      
      if(!state.active){
        // First click: select line or circle
        if(hitLine && hitLine.shape.type === 'line'){
          state.active = { mode: 'tangent', line: hitLine.shape.id };
        } else {
          // Check if clicking on circle
          const hitCircle = state.shapes.find(s => {
            if(s.type !== 'circle') return false;
            const center = state.joints.get(s.joints[0]);
            const radiusPt = state.joints.get(s.joints[1]);
            if(!center || !radiusPt) return false;
            const radius = Math.hypot(radiusPt.x - center.x, radiusPt.y - center.y);
            const dist = Math.hypot(w.x - center.x, w.y - center.y);
            return Math.abs(dist - radius) < 10; // Click near circle perimeter
          });
          if(hitCircle){
            state.active = { mode: 'tangent', circle: hitCircle.id };
          }
        }
      } else {
        // Second click: select the other element
        if(state.active.line && !state.active.circle){
          // Line selected, now need circle
          const hitCircle = state.shapes.find(s => {
            if(s.type !== 'circle') return false;
            const center = state.joints.get(s.joints[0]);
            const radiusPt = state.joints.get(s.joints[1]);
            if(!center || !radiusPt) return false;
            const radius = Math.hypot(radiusPt.x - center.x, radiusPt.y - center.y);
            const dist = Math.hypot(w.x - center.x, w.y - center.y);
            return Math.abs(dist - radius) < 10;
          });
          if(hitCircle){
            state.saveState(); // Save state BEFORE making changes
            addConstraint(state, 'tangent', { line: state.active.line, circle: hitCircle.id });
            state.active = null;
          }
        } else if(state.active.circle && !state.active.line){
          // Circle selected, now need line
          if(hitLine && hitLine.shape.type === 'line'){
            state.saveState(); // Save state BEFORE making changes
            addConstraint(state, 'tangent', { line: hitLine.shape.id, circle: state.active.circle });
            state.active = null;
          }
        }
      }
    } else if(state.currentTool==='dim'){
      continueFrom = null;
      const hitLine = hitLineAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
      const hitCircle = hitCircleAtScreen(state.joints, state.shapes, svg, e.clientX, e.clientY, 10);
      
      if(!state.active){
        // Phase 0: click on line, circle, or first point
        if(hitCircle){
          // Circle mode: clicked on a circle, dimension its radius
          const center = state.joints.get(hitCircle.joints[0]);
          const radiusPt = state.joints.get(hitCircle.joints[1]);
          if(center && radiusPt){
            const radius = getDist(center, radiusPt);
            state.active = { 
              mode: 'dim-circle', 
              joints: hitCircle.joints.slice(),
              shape: hitCircle,
              value: radius,
              offset: 30 // default offset from circle
            };
            svg.setPointerCapture(e.pointerId);
          }
        } else if(hitLine && hitLine.shape.type === 'line'){
          // Line mode: clicked on a line, start dragging to position annotation
          const j1 = state.joints.get(hitLine.shape.joints[0]);
          const j2 = state.joints.get(hitLine.shape.joints[1]);
          if(j1 && j2){
            const dist = getDist(j1, j2);
            state.active = { 
              mode: 'dim-line', 
              joints: hitLine.shape.joints.slice(),
              shape: hitLine.shape,
              value: dist,
              offset: 30 // default offset perpendicular to line
            };
            svg.setPointerCapture(e.pointerId);
          }
        } else if(hitSnap && hitSnap.type === 'joint'){
          // Point-to-point mode: first point selected
          state.active = { mode: 'dim-p2p', j1: hitSnap.id };
        }
      } else if(state.active.mode === 'dim-p2p' && !state.active.j2){
        // Phase 1: selecting second point
        if(hitSnap && hitSnap.type === 'joint' && hitSnap.id !== state.active.j1){
          const j1 = state.joints.get(state.active.j1);
          const j2 = state.joints.get(hitSnap.id);
          if(j1 && j2){
            const dist = getDist(j1, j2);
            state.active.j2 = hitSnap.id;
            state.active.joints = [state.active.j1, hitSnap.id];
            state.active.value = dist;
            state.active.offset = 30;
            svg.setPointerCapture(e.pointerId);
          }
        }
      }
    } else {
      continueFrom = null;
    }
  });

  svg.addEventListener('pointerup',(e)=>{
    // If we were panning, just clean up and don't process any drawing operations
    if(state.drag && state.drag.type === 'pan'){
      if(state.drag.pointerId) try{ svg.releasePointerCapture(state.drag.pointerId); }catch(_){}
      state.drag = null;
      justCreatedActive = false;
      return;
    }
    
    // Skip drawing operations if middle mouse button was released
    if(e.button === 1){
      justCreatedActive = false;
      return;
    }
    
    const w = screenToWorld(svg, e.clientX, e.clientY);
    state.lastMouse = { x: e.clientX, y: e.clientY };
    // Use the snapTarget from pointermove (what user saw during preview) instead of recalculating
    // This ensures the snap feedback matches what actually gets applied
    const hitSnap = state.snapTarget;
    const wasDragging = isDragging;
    dragStartScreen = null;
    
    if(state.active && state.active.mode==='line'){
      // Skip if state.active was just created in pointerdown (user needs to click again to complete)
      if(justCreatedActive){
        justCreatedActive = false;
        isDragging = false;
        return;
      }
      
      // Polyline mode: complete on every click (no double-click needed)
      // Determine endpoint: snap takes priority, then inference, then raw position
      let endPt = w;
      let endId;
      
      if(hitSnap && hitSnap.type === 'joint'){
        // Special handling for snapping to origin - create new point with coincident constraint
        if(hitSnap.id === 'j_origin'){
          endPt = hitSnap.pt;
          endId = state.genJ();
          state.joints.set(endId, {x:endPt.x, y:endPt.y, fixed:false});
          // Create coincident constraint to origin
          addConstraint(state, 'coincident', { joints: [endId, 'j_origin'] });
        } else {
          // Snapping to other existing joint - use it directly
          endId = hitSnap.id;
        }
      } else {
        // Creating new joint - use inferred position if available, otherwise snap or raw position
        if(state.inference && state.inference.pt){
          endPt = state.inference.pt;
        } else if(hitSnap){
          endPt = hitSnap.pt;
        }
        endId = state.genJ();
        state.joints.set(endId, {x:endPt.x, y:endPt.y, fixed:false});
      }
      
      // Save state BEFORE creating the line and constraints
      state.saveState();
      
      // Create shape with proper ID (needed for perpendicular constraint)
      const newShapeId = 's'+Date.now();
      state.shapes.push({ id: newShapeId, type:'line', joints:[state.active.start, endId] }); 
      
      // If snapped to existing joint (not origin), create coincident constraint
      if(hitSnap && hitSnap.type === 'joint' && hitSnap.id !== 'j_origin'){
        addConstraint(state, 'coincident', { joints: [endId, hitSnap.id] });
      }
      // If snapped to a line, add point-on-line constraint
      if(hitSnap && hitSnap.type === 'line' && hitSnap.shape){
        addConstraint(state, 'pointOnLine', { joint: endId, shape: hitSnap.shape.id });
      }

      // Auto-coincident detection for new endpoints created very close to any existing joint
      // This ensures pairs created by drawing (end of a line and start of another) get a persistent coincident constraint
      if(!(hitSnap && hitSnap.type === 'joint')){
        const pt = state.joints.get(endId);
        const nearby = findNearbyJoint(state.joints, pt, endId, 0.01);
        if(nearby){
          console.log('[polyline] Auto-coincident added between', endId, 'and', nearby);
          addConstraint(state, 'coincident', { joints: [endId, nearby] });
        }
      }
      
      // Add inferred constraints (horizontal, vertical, perpendicular)
      // Only add if geometry is already very close to satisfying the constraint (within 0.5Â° tolerance)
      // This prevents unwanted shifts when inference was used during drawing but final geometry drifted
      if(state.inference){
        const startJoint = state.joints.get(state.active.start);
        const endJoint = state.joints.get(endId);
        if(startJoint && endJoint){
          const dx = endJoint.x - startJoint.x;
          const dy = endJoint.y - startJoint.y;
          const len = Math.hypot(dx, dy);
          
          if(len > 0.1){
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            const CONSTRAINT_TOLERANCE = 5; // degrees - match inference threshold for consistent behavior
            
            if(state.inference.type === 'horizontal'){
              const horizontalDiff = Math.min(Math.abs(angle), Math.abs(Math.abs(angle) - 180));
              if(horizontalDiff < CONSTRAINT_TOLERANCE){
                addConstraint(state, 'horizontal', { joints: [state.active.start, endId] });
              }
            } else if(state.inference.type === 'vertical'){
              const verticalDiff = Math.abs(Math.abs(angle) - 90);
              if(verticalDiff < CONSTRAINT_TOLERANCE){
                addConstraint(state, 'vertical', { joints: [state.active.start, endId] });
              }
            } else if(state.inference.type === 'perpendicular' && state.inference.refLine){
              // Check if current line is actually perpendicular to reference line
              const refShape = state.shapes.find(s => s.id === state.inference.refLine.id);
              if(refShape && refShape.joints){
                const ra = state.joints.get(refShape.joints[0]);
                const rb = state.joints.get(refShape.joints[1]);
                if(ra && rb){
                  const rdx = rb.x - ra.x;
                  const rdy = rb.y - ra.y;
                  const refAngle = Math.atan2(rdy, rdx) * 180 / Math.PI;
                  const perpAngle1 = refAngle + 90;
                  const perpAngle2 = refAngle - 90;
                  
                  const normAngle = ((angle % 360) + 360) % 360;
                  const normPerp1 = ((perpAngle1 % 360) + 360) % 360;
                  const normPerp2 = ((perpAngle2 % 360) + 360) % 360;
                  
                  const diff1 = Math.min(Math.abs(normAngle - normPerp1), 360 - Math.abs(normAngle - normPerp1));
                  const diff2 = Math.min(Math.abs(normAngle - normPerp2), 360 - Math.abs(normAngle - normPerp2));
                  
                  if(Math.min(diff1, diff2) < CONSTRAINT_TOLERANCE){
                    addConstraint(state, 'perpendicular', { shapes: [newShapeId, state.inference.refLine.id] });
                  }
                }
              }
            }
          }
        }
      }
      
      // Check if we should end the polyline sequence
      const origin = state.active.polylineOrigin || polylineOrigin;
      const snappedToExistingJoint = hitSnap && hitSnap.type === 'joint';
      
      if(endId === origin && origin !== state.active.start){
        // Shape closed! End polyline but keep line tool active
        continueFrom = null;
        polylineOrigin = null;
      } else if(snappedToExistingJoint && endId !== state.active.start){
        // Ended on an existing point (not the start) - finish polyline but stay in line tool
        continueFrom = null;
        polylineOrigin = null;
      } else {
        // Continue from endpoint for next segment
        // Save state after each segment so undo can remove one segment at a time
        state.saveState();
        continueFrom = endId;
      }
      isDragging = false;
      state.active = null;
      state.inference = null; // Clear inference after using it
    } else if(state.active && state.active.mode==='circle'){
      // For circle: if just clicked (not dragged), wait for second click
      if(!wasDragging && !state.active.waitingForSecondClick){
        state.active.waitingForSecondClick = true;
        isDragging = false;
        return;
      }
      
      const endPt = hitSnap? hitSnap.pt : w; 
      const endId = hitSnap && hitSnap.type==='joint' ? hitSnap.id : state.genJ(); 
      if(!state.joints.has(endId)) state.joints.set(endId,{x:endPt.x,y:endPt.y,fixed:false}); 
      state.saveState(); // Save state BEFORE creating circle
      state.shapes.push({ id:'s'+Date.now(), type:'circle', joints:[state.active.start, endId] });
      // If snapped to existing joint, create coincident constraint
      if(hitSnap && hitSnap.type==='joint' && hitSnap.id !== 'j_origin'){
        addConstraint(state, 'coincident', { joints: [endId, hitSnap.id] });
      }
      // Auto-coincident detection for newly created circle endpoint
      if(!(hitSnap && hitSnap.type === 'joint')){
        const pt = state.joints.get(endId);
        const nearby = findNearbyJoint(state.joints, pt, endId, 0.01);
        if(nearby){
          console.log('[circle] Auto-coincident added between', endId, 'and', nearby);
          addConstraint(state, 'coincident', { joints: [endId, nearby] });
        }
      } 
      // Circle complete - don't continue, wait for new click
      continueFrom = null;
      polylineOrigin = null;
      isDragging = false;
      state.active = null;
    } else if(state.active && state.active.mode==='rect'){
      const rectMode = state.rectMode || 'rect-2pt';
      
      // For rect (2pt and center modes): if just clicked (not dragged), wait for second click
      // 3pt mode always uses clicks
      if(rectMode !== 'rect-3pt' && !wasDragging && !state.active.waitingForSecondClick){
        state.active.waitingForSecondClick = true;
        isDragging = false;
        return;
      }
      
      const endPt = hitSnap? hitSnap.pt : w; 
      const endId = hitSnap && hitSnap.type==='joint' ? hitSnap.id : state.genJ(); 
      if(!state.joints.has(endId)) state.joints.set(endId,{x:endPt.x,y:endPt.y,fixed:false});
      
      if(rectMode === 'rect-3pt' && !state.active.secondPt){
        // 3-point mode: first two points define width, need third for height
        state.saveState(); // Save after first click so user can undo each click
        // If snapped to existing joint, create coincident constraint
        if(hitSnap && hitSnap.type==='joint' && hitSnap.id !== 'j_origin'){
          addConstraint(state, 'coincident', { joints: [endId, hitSnap.id] });
        }
        state.active.secondPt = endId;
        state.active.preview = { type: 'rect-3pt', pt: endPt };
        isDragging = false;
      } else if(rectMode === 'rect-3pt' && state.active.secondPt){
        // 3-point mode: third point defines height
        state.saveState(); // Save state BEFORE creating rectangle
        // If snapped to existing joint, create coincident constraint
        if(hitSnap && hitSnap.type==='joint' && hitSnap.id !== 'j_origin'){
          addConstraint(state, 'coincident', { joints: [endId, hitSnap.id] });
        }
        const rectShapes = makeRectFrom3Points(state.joints, state.active.start, state.active.secondPt, endId, state.genJ);
        rectShapes.forEach(s => state.shapes.push(s));
        continueFrom = null;
        polylineOrigin = null;
        isDragging = false;
        state.active = null;
      } else if(rectMode === 'rect-center'){
        // Center mode: first point is center, second is corner
        state.saveState(); // Save state BEFORE creating rectangle
        // If snapped to existing joint, create coincident constraint
        if(hitSnap && hitSnap.type==='joint' && hitSnap.id !== 'j_origin'){
          addConstraint(state, 'coincident', { joints: [endId, hitSnap.id] });
        }
        const rectShapes = makeRectFromCenter(state.joints, state.active.start, endId, state.genJ);
        rectShapes.forEach(s => state.shapes.push(s));
        continueFrom = null;
        polylineOrigin = null;
        isDragging = false;
        state.active = null;
      } else {
        // Default 2-point corner mode - includes H/V constraints
        state.saveState(); // Save state BEFORE creating rectangle and constraints
        // If snapped to existing joint, create coincident constraint
        if(hitSnap && hitSnap.type==='joint' && hitSnap.id !== 'j_origin'){
          addConstraint(state, 'coincident', { joints: [endId, hitSnap.id] });
        }
        const rectResult = makeRectFromTwoJoints(state.joints, state.active.start, endId, state.genJ);
        rectResult.shapes.forEach(s => state.shapes.push(s));
        rectResult.constraints.forEach(c => addConstraint(state, c.type, c));
        // Auto-coincident detection for rectangle endpoints: check start and end corner joints
        const sPt = state.joints.get(state.active.start);
        const nearS = findNearbyJoint(state.joints, sPt, state.active.start, 0.01);
        if(nearS){ console.log('[rect] Auto-coincident added between', state.active.start, 'and', nearS); addConstraint(state, 'coincident', { joints: [state.active.start, nearS] }); }
        const ePt = state.joints.get(endId);
        const nearE = findNearbyJoint(state.joints, ePt, endId, 0.01);
        if(nearE){ console.log('[rect] Auto-coincident added between', endId, 'and', nearE); addConstraint(state, 'coincident', { joints: [endId, nearE] }); }
        continueFrom = null;
        polylineOrigin = null;
        isDragging = false;
        state.active = null;
      }
    }
    
    if(state.drag && (state.drag.type==='joint' || state.drag.type==='cluster')){
      const other = hitJointAtScreen(state.joints, svg, e.clientX, e.clientY, 14);
      if(other && !state.drag.jointIds.includes(other.id)){ 
        state.saveState(); // Save state before creating constraint
        // Create coincident constraint between dragged joint and target joint
        // The solver will keep them at the same position - no need to merge them
        addConstraint(state, 'coincident', { joints: [state.drag.id, other.id] });
      }
    }
    
    if(state.drag && state.drag.pointerId) try{ svg.releasePointerCapture(state.drag.pointerId); }catch(_){}
    state.drag=null;
    
    // Dimension tool: finalize on release (after dragging to position)
    if(state.active && (state.active.mode === 'dim-line' || state.active.mode === 'dim-circle' || (state.active.mode === 'dim-p2p' && state.active.j2))){
      // Defensive validation: ensure joints array exists and a numeric value is present
      if(!state.active.joints || state.active.joints.length < 2){
        if(state.active.mode === 'dim-line' && state.active.shape && state.active.shape.joints){
          state.active.joints = state.active.shape.joints.slice();
        } else if(state.active.mode === 'dim-circle' && state.active.joints && state.active.joints.length >= 2){
          // OK
        } else if(state.active.mode === 'dim-p2p' && state.active.j1 && state.active.j2){
          state.active.joints = [state.active.j1, state.active.j2];
        } else {
          console.warn('[dim] Missing joints for dimension creation:', state.active);
        }
      }

      // Compute value if missing from active state
      if((state.active.value === undefined || state.active.value === null) && state.active.joints && state.active.joints.length >= 2){
        const j1 = state.joints.get(state.active.joints[0]);
        const j2 = state.joints.get(state.active.joints[1]);
        if(j1 && j2){
          state.active.value = getDist(j1, j2);
        }
      }

      state.saveState(); // Save state BEFORE adding constraint
      console.log('[dim] Adding distance constraint:', { joints: state.active.joints, value: state.active.value, offset: state.active.offset, mode: state.active.mode });
      const added = addConstraint(state, 'distance', {
        joints: state.active.joints ? state.active.joints.slice() : [],
        value: state.active.value,
        offset: state.active.offset || 30,
        isRadius: state.active.mode === 'dim-circle'
      });
      
      // Find the newly added constraint for selection and editing
      if(added){
        const newConstraint = state.constraints[state.constraints.length - 1];
        state.selectItem('constraint', newConstraint);
        // Show dimension input for editing
        showDimInput(svg, state, newConstraint);
      }
      
      try{ svg.releasePointerCapture(e.pointerId); }catch(_){}
      state.active = null;
    }
    
    justCreatedActive = false; // Reset flag at end of pointerup
  });
  
  svg.addEventListener('contextmenu',(e)=>{
    e.preventDefault();
    continueFrom = null;
    polylineOrigin = null;
    state.active = null;
  });
  
  // Handle Delete key to remove selected constraint or shape
  document.addEventListener('keydown', (e) => {
    if(e.key === 'Delete'){
      if(state.selectedConstraint){
        // Remove the selected constraint
        const idx = state.constraints.indexOf(state.selectedConstraint);
        if(idx !== -1){
          state.saveState(); // Save state BEFORE deleting
          // Clear selection flag on the removed constraint
          if(state.selectedConstraint && state.selectedConstraint.__selected) state.selectedConstraint.__selected = false;
          state.constraints.splice(idx, 1);
          state.selectedConstraint = null;
        }
      } else if(state.selectedShape){
        // Remove the selected shape and any constraints applied to it
        state.saveState(); // Save state BEFORE deleting
        const shapeIdx = state.shapes.indexOf(state.selectedShape);
        if(shapeIdx !== -1){
          const deletedShapeId = state.selectedShape.id;
          state.shapes.splice(shapeIdx, 1);
          
          // Remove constraints that reference the deleted shape
          state.constraints = state.constraints.filter(c => {
            // Remove if constraint references this shape
            if(c.shapes && c.shapes.includes(deletedShapeId)) return false;
            if(c.shape === deletedShapeId) return false;
            if(c.line === deletedShapeId) return false;
            if(c.circle === deletedShapeId) return false;
            
            // Keep all other constraints
            return true;
          });
          
          state.selectedShape = null;
        }
      }
    } else if(e.key === 'Escape'){
      // Escape key: exit tool and activate select tool
      state.currentTool = 'select';
      state.active = null;
      continueFrom = null;
      polylineOrigin = null;
      state.clearSelection();
      
      // Update UI to show select tool is active
      document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
      const selectBtn = document.getElementById('tool-select');
      if(selectBtn) selectBtn.classList.add('active');
      
      const modeText = document.getElementById('modeText');
      if(modeText) modeText.innerText = 'MODE: SELECT';
    }
  });
  
  // mouse wheel for zoom
  svg.addEventListener('wheel',(e)=>{
    e.preventDefault();
    const factor = e.deltaY > 0 ? 1.1 : 0.9;
    // Maintain aspect ratio
    const rect = svg.getBoundingClientRect();
    const aspectRatio = rect.width / rect.height;
    state.view.w *= factor;
    state.view.h = state.view.w / aspectRatio;
    svg.setAttribute('viewBox', `${state.view.x-state.view.w/2} ${state.view.y-state.view.h/2} ${state.view.w} ${state.view.h}`);
  }, {passive:false});
  
  // Expose reset for tool changes
  state.resetPolyline = () => { continueFrom = null; polylineOrigin = null; };
}


// ---- 7-ui.js (inlined) ----
function setupUI(state){
  // Remove active class from all buttons initially
  document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
  
  // Track rect sub-mode
  state.rectMode = 'rect-2pt'; // default: 2-point corner rect
  
  function setTool(t){ 
    console.log('Setting tool to:', t); // Debug log
    state.currentTool = t; 
    state.active = null; // clear any in-progress action
    if(state.resetPolyline) state.resetPolyline(); // end polyline mode
    
    // Remove active from all buttons
    document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active')); 
    
    // Add active to selected button
    const el = document.getElementById('tool-'+t); 
    if(el) {
      el.classList.add('active');
      console.log('Added active class to:', el.id); // Debug log
    } else {
      console.warn('Button not found for tool:', t); // Debug log
    }
    
    // Update mode text
    const mt = document.getElementById('modeText');
    let modeText = t.toUpperCase();
    if(t === 'rect') {
      const modeNames = { 'rect-2pt': '2PT', 'rect-center': 'CENTER', 'rect-3pt': '3PT' };
      modeText = 'RECT ' + (modeNames[state.rectMode] || '');
    }
    if(mt) mt.innerText = 'MODE: ' + modeText; 
  }
  
  // Attach click handlers to all tool buttons
  ['line','rect','circle','coincident','hv','parallel','perp','collinear','tangent','dim','select'].forEach(t=>{ 
    const el=document.getElementById('tool-'+t); 
    if(el) {
      el.addEventListener('click', (e) => {
        console.log('Tool button clicked:', t); // Debug log
        const constraintTools = ['coincident','hv','parallel','perp','collinear','tangent'];
        if(constraintTools.includes(t)){
          // Always enter pendingConstraint mode and wait for user picks
          state.selectedJoints.clear();
          state.selectedShape = null;
          state.pendingConstraint = { type: t, firstElement: null };
          state.active = null;
          setTool(t);
          // Update mode text to show pending constraint
          const mt = document.getElementById('modeText');
          let modeText = t === 'collinear' ? (t.toUpperCase() + ' - 1/3 Points') : (t.toUpperCase() + ' - Select 1st Element');
          if(mt) mt.innerText = 'MODE: ' + modeText;
          document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
          el.classList.add('active');
          return;
        }
        // Normal tool selection
        setTool(t);
      }); 
    } else {
      console.warn('Tool button not found:', 'tool-'+t); // Debug log
    }
  });
  
  // Undo button
  const undoBtn = document.getElementById('btn-undo');
  if(undoBtn) {
    undoBtn.disabled = true; // Initially disabled
    undoBtn.addEventListener('click', () => {
      state.undo();
    });
  }
  
  // Rect dropdown handling
  const rectBtn = document.getElementById('tool-rect');
  const rectDropdown = document.getElementById('rect-dropdown');
  let longPressTimer = null;
  let dropdownOpenedByLongPress = false;
  let hoveredDropdownItem = null;
  
  if(rectBtn && rectDropdown) {
    // Long press to show dropdown
    rectBtn.addEventListener('pointerdown', (e) => {
      dropdownOpenedByLongPress = false;
      longPressTimer = setTimeout(() => {
        rectDropdown.classList.add('show');
        dropdownOpenedByLongPress = true;
        longPressTimer = null;
      }, 400); // 400ms for long press
    });
    
    // Track hovered item while dropdown is open
    rectDropdown.querySelectorAll('.tool-dropdown-item').forEach(item => {
      item.addEventListener('pointerenter', () => {
        hoveredDropdownItem = item;
        // Visual feedback
        rectDropdown.querySelectorAll('.tool-dropdown-item').forEach(i => i.classList.remove('hover'));
        item.classList.add('hover');
      });
      item.addEventListener('pointerleave', () => {
        if(hoveredDropdownItem === item) hoveredDropdownItem = null;
        item.classList.remove('hover');
      });
    });
    
    // On pointerup anywhere, if dropdown was opened by long press, select hovered item
    document.addEventListener('pointerup', (e) => {
      if(longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      
      if(dropdownOpenedByLongPress && rectDropdown.classList.contains('show')) {
        if(hoveredDropdownItem) {
          // Select the hovered item
          const mode = hoveredDropdownItem.dataset.mode;
          state.rectMode = mode;
          rectDropdown.querySelectorAll('.tool-dropdown-item').forEach(i => i.classList.remove('active'));
          hoveredDropdownItem.classList.add('active');
          updateRectIcon(mode);
          setTool('rect');
        }
        rectDropdown.classList.remove('show');
        rectDropdown.querySelectorAll('.tool-dropdown-item').forEach(i => i.classList.remove('hover'));
        dropdownOpenedByLongPress = false;
        hoveredDropdownItem = null;
      }
    });
    
    rectBtn.addEventListener('pointerleave', () => {
      if(longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    });
    
    // Function to update rect icon based on mode
    function updateRectIcon(mode) {
      const icon2pt = document.querySelectorAll('.rect-icon-2pt');
      const iconCenter = document.querySelectorAll('.rect-icon-center');
      const icon3pt = document.querySelectorAll('.rect-icon-3pt');
      const rectLabel = document.getElementById('rect-label');
      
      // Hide all
      icon2pt.forEach(el => el.style.display = 'none');
      iconCenter.forEach(el => el.style.display = 'none');
      icon3pt.forEach(el => el.style.display = 'none');
      
      // Show active mode
      if(mode === 'rect-2pt') {
        icon2pt.forEach(el => el.style.display = '');
        if(rectLabel) rectLabel.textContent = 'Rect';
      } else if(mode === 'rect-center') {
        iconCenter.forEach(el => el.style.display = '');
        if(rectLabel) rectLabel.textContent = 'Ctr';
      } else if(mode === 'rect-3pt') {
        icon3pt.forEach(el => el.style.display = '');
        if(rectLabel) rectLabel.textContent = '3Pt';
      }
    }
    
    // Dropdown item selection
    rectDropdown.querySelectorAll('.tool-dropdown-item').forEach(item => {
      item.addEventListener('click', (e) => {
        e.stopPropagation();
        const mode = item.dataset.mode;
        state.rectMode = mode;
        // Update active state in dropdown
        rectDropdown.querySelectorAll('.tool-dropdown-item').forEach(i => i.classList.remove('active'));
        item.classList.add('active');
        // Update toolbar icon
        updateRectIcon(mode);
        // Hide dropdown and select rect tool
        rectDropdown.classList.remove('show');
        setTool('rect');
      });
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if(!rectBtn.contains(e.target) && !rectDropdown.contains(e.target)) {
        rectDropdown.classList.remove('show');
      }
    });
  }
  
  // Keyboard shortcuts
  const shortcuts = {
    'l': 'line',
    'r': 'rect',
    'c': 'circle',
    's': 'select',
    'v': 'select',      // V for pointer/select (like Illustrator)
    'o': 'coincident',  // O for cOincident
    'h': 'hv',          // H for horizontal/vertical
    'p': 'parallel',
    't': 'perp',        // T for perpendicular (T-shape)
    'd': 'dim',
  };
  window.addEventListener('keydown', (e) => {
    // Don't trigger if typing in an input
    if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    const key = e.key.toLowerCase();
    
    // Escape cancels current action
    if(e.key === 'Escape'){
      state.active = null;
      state.pendingConstraint = null;
      if(state.resetPolyline) state.resetPolyline();
      
      // Reset mode text if there was a pending constraint
      const mt = document.getElementById('modeText');
      if(mt) mt.innerText = 'MODE: SELECT';
      
      // Reset toolbar buttons
      document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
      document.getElementById('tool-select').classList.add('active');
      return;
    }
    
    // Tool shortcuts
    if(shortcuts[key]){
      e.preventDefault();
      setTool(shortcuts[key]);
      return;
    }
    // Undo with Ctrl+Z
    if((e.key === 'z' || e.key === 'Z') && (e.ctrlKey || e.metaKey)){
      e.preventDefault();
      if(state.shapes.length) state.shapes.pop();
      return;
    }
    // Delete/Backspace to delete selected item (constraint/shape/joint(s))
    if(e.key === 'Delete' || e.key === 'Backspace'){
      const sel = state.getSelected ? state.getSelected() : state.selection;
      if(sel && sel.type === 'constraint'){
        const c = sel.payload;
        const idx = state.constraints.indexOf(c);
        if(idx >= 0){
          // Save state and remove
          state.saveState();
          if(c.__selected) c.__selected = false;
          state.constraints.splice(idx, 1);
        }
        state.clearSelection();
        return;
      }
      if(sel && sel.type === 'shape'){
        const s = sel.payload;
        const shapeIdx = state.shapes.indexOf(s);
        if(shapeIdx !== -1){
          state.saveState();
          const deletedShapeId = s.id;
          state.shapes.splice(shapeIdx, 1);
          state.constraints = state.constraints.filter(c => {
            if(c.shapes && c.shapes.includes(deletedShapeId)) return false;
            if(c.shape === deletedShapeId) return false;
            if(c.line === deletedShapeId) return false;
            if(c.circle === deletedShapeId) return false;
            return true;
          });
        }
        state.clearSelection();
        return;
      }
      if(sel && (sel.type === 'joint' || sel.type === 'joints')){
        // Deleting joints is not supported via Delete key to avoid accidental heavy changes
        // Consider leaving as future improvement
        return;
      }
      // Nothing selected: do nothing (prevent accidental clear of whole drawing)
      return;
    }
  }, true); // Use capture phase
  
  // add undo/clear
  document.getElementById('btn-undo')?.addEventListener('click', ()=>{ if(state.shapes.length) state.shapes.pop(); });
  document.getElementById('btn-clear')?.addEventListener('click', ()=>{ state.initStore(); });
  // ensure default
  setTool(state.currentTool || 'select');
}


// ---- 8-main.js (inlined) ----





const svg = document.getElementById('svgCanvas');
let view = { ...DEFAULT_VIEW };

function updateView(){ 
  // Match viewBox aspect ratio to SVG element
  const rect = svg.getBoundingClientRect();
  const aspectRatio = rect.width / rect.height;
  view.h = view.w / aspectRatio;
  svg.setAttribute('viewBox', `${view.x-view.w/2} ${view.y-view.h/2} ${view.w} ${view.h}`); 
}

// Update on resize
window.addEventListener('resize', updateView);
setTimeout(updateView, 0); // Initial update after layout

// create engine instance bound to this svg
const engine = createEngine(svg);

// shared app state passed to input and ui modules
const state = {
  // expose engine proxies for modules to use
  engine,
  joints: engine.getJoints(),
  shapes: engine.getShapes(),
  constraints: engine.getConstraints(),
  genJ: () => engine.genJ(),
  initStore: () => engine.init(),
  mergeJoints: (a,b) => engine.mergeJoints(a,b),
  currentTool: 'select',
  active: null,
  drag: null,
  snapTarget: null,
  inference: null,  // Track inference hints (horizontal, vertical, perpendicular)
  lastMouse: null,
  pendingConstraint: null,  // { type: 'parallel', firstElement: { type: 'line|joint', id }, ... }
  view,

  // Unified selection model
  selection: { type: null, payload: null }, // { type: 'constraint'|'shape'|'joint'|'joints'|null, payload }
  selectedJoints: new Set(),  // Track selected joints for showing constraint glyphs
  selectedConstraint: null,    // For backwards compatibility - kept in sync with selection
  selectedShape: null,         // For backwards compatibility - kept in sync with selection

  // Hover state
  hoveredShape: null,          // Track hovered shape for visual feedback
  hoveredJoint: null,          // Track hovered joint for visual feedback
  hoveredConstraint: null,     // Track hovered constraint for visual feedback

  history: [],  // Store last 5 states for undo
  maxHistory: 5,

  // Selection helpers
  selectItem: function(type, payload, opts = {}){
    // Clear existing selection safely
    this.clearSelection();
    this.selection = { type, payload };
    console.log('[selection] selectItem', type, payload);

    if(type === 'constraint'){
      // Clear __selected from all constraints
      if(this.constraints) {
        for(const c of this.constraints) {
          if(c && c.__selected) c.__selected = false;
        }
      }
      this.selectedConstraint = payload || null;
      if(this.selectedConstraint) this.selectedConstraint.__selected = true;
      this.selectedShape = null;
      this.selectedJoints.clear();
    } else if(type === 'shape'){
      this.selectedShape = payload || null;
      this.selectedConstraint = null;
      this.selectedJoints.clear();
    } else if(type === 'joint'){
      this.selectedJoints.clear();
      if(payload) this.selectedJoints.add(payload);
      this.selectedConstraint = null;
      this.selectedShape = null;
    } else if(type === 'joints'){
      this.selectedJoints.clear();
      if(Array.isArray(payload)) payload.forEach(j => this.selectedJoints.add(j));
      this.selectedConstraint = null;
      this.selectedShape = null;
    } else {
      // Unknown / null selection
      this.selectedConstraint = null;
      this.selectedShape = null;
      this.selectedJoints.clear();
    }
  },

  clearSelection: function(){
    if(this.selectedConstraint && this.selectedConstraint.__selected) this.selectedConstraint.__selected = false;
    this.selection = { type: null, payload: null };
    this.selectedConstraint = null;
    this.selectedShape = null;
    this.selectedJoints.clear();
  },

  getSelected: function(){ return this.selection; },

  saveState: function() {
    // Deep copy current state BEFORE making changes
    const snapshot = {
      joints: new Map(Array.from(this.joints.entries()).map(([k,v]) => [k, {...v}])),
      shapes: this.shapes.map(s => ({...s, joints: s.joints ? [...s.joints] : []})),
      constraints: this.constraints.map(c => ({...c, joints: c.joints ? [...c.joints] : undefined, shapes: c.shapes ? [...c.shapes] : undefined}))
    };
    this.history.push(snapshot);
    if(this.history.length > this.maxHistory) this.history.shift();
    // Update undo button state
    const undoBtn = document.getElementById('btn-undo');
    if(undoBtn) undoBtn.disabled = false;
  },
  undo: function() {
    if(this.history.length === 0) return;
    // Get the previous state (not the current one)
    const snapshot = this.history.pop();
    // Restore state
    this.joints.clear();
    for(const [k,v] of snapshot.joints) this.joints.set(k, {...v});
    this.shapes.length = 0;
    this.shapes.push(...snapshot.shapes.map(s => ({...s, joints: s.joints ? [...s.joints] : []})));
    this.constraints.length = 0;
    this.constraints.push(...snapshot.constraints.map(c => ({...c, joints: c.joints ? [...c.joints] : undefined, shapes: c.shapes ? [...c.shapes] : undefined})));
    // Clear selections and active tool state
    this.clearSelection();
    this.active = null;
    // Update undo button state
    const undoBtn = document.getElementById('btn-undo');
    if(undoBtn && this.history.length === 0) undoBtn.disabled = true;
  }
};

// initialize
engine.init();
setupUI(state);
setupInput(svg, state);

// Setup dimension edit handler
window.__dimEditHandler = (cIdx) => {
  const constraint = state.constraints[cIdx];
  if(constraint && constraint.type === 'distance'){
    showDimInput(svg, state, constraint);
  }
};

function loop(){ engine.solve(8); draw(state.joints, state.shapes, svg, state.active, state.snapTarget, state.constraints, state.selectedJoints, state.selectedConstraint, state.currentTool, state.inference, state.selectedShape, state.hoveredShape, state.hoveredJoint, state.hoveredConstraint); requestAnimationFrame(loop); }
loop();

// function for tests/external use
if(typeof module !== 'undefined' && module.exports) {
  module.exports = { state, engine };
}


</script>
</body>
</html>
